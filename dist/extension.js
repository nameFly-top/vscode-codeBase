/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ([
/* 0 */,
/* 1 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerChunkingCommands = registerChunkingCommands;
const vscode = __importStar(__webpack_require__(2));
const chunkingService_1 = __webpack_require__(3);
let chunkingService;
/**
 * 注册代码分块相关的所有命令
 */
function registerChunkingCommands(context) {
    // 初始化服务
    chunkingService = new chunkingService_1.ChunkingService();
    // 注册代码分块命令
    const chunkCodeCommand = vscode.commands.registerCommand('test-electron-treesitter.chunkCode', async () => {
        try {
            const res = await chunkingService.executeCodeChunking(context);
            return res;
        }
        catch (error) {
            console.error('[CodeChunker] 执行错误:', error);
            vscode.window.showErrorMessage(`代码分块执行失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // 注册进度查询命令
    const checkProgressCommand = vscode.commands.registerCommand('test-electron-treesitter.checkProgress', async () => {
        try {
            await chunkingService.checkChunkingProgress();
        }
        catch (error) {
            console.error('[CodeChunker] 进度查询错误:', error);
            vscode.window.showErrorMessage(`进度查询失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // 注册清除缓存命令
    const clearCacheCommand = vscode.commands.registerCommand('test-electron-treesitter.clearCache', async () => {
        try {
            await chunkingService.clearProcessingCache();
        }
        catch (error) {
            console.error('[CodeChunker] 清除缓存错误:', error);
            vscode.window.showErrorMessage(`清除缓存失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // 注册查看索引缓存统计命令
    const cacheStatsCommand = vscode.commands.registerCommand('test-electron-treesitter.cacheStats', async () => {
        try {
            const stats = await chunkingService.getCacheStats();
            if (stats) {
                vscode.window.showInformationMessage(`索引缓存统计:\n` +
                    `- 缓存文件数: ${stats.totalFiles}\n` +
                    `- 缓存大小: ${stats.totalSize}\n` +
                    `- 最早记录: ${stats.oldestRecord ? stats.oldestRecord.toLocaleString() : '无'}\n` +
                    `- 最新记录: ${stats.newestRecord ? stats.newestRecord.toLocaleString() : '无'}`);
            }
            else {
                vscode.window.showInformationMessage('索引缓存未启用');
            }
        }
        catch (error) {
            console.error('[CodeChunker] 获取缓存统计失败:', error);
            vscode.window.showErrorMessage(`获取缓存统计失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // 注册清除索引缓存命令
    const clearIndexCacheCommand = vscode.commands.registerCommand('test-electron-treesitter.clearIndexCache', async () => {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                vscode.window.showErrorMessage('请先打开一个工作区');
                return;
            }
            const config = vscode.workspace.getConfiguration('codeChunker');
            const userId = config.get('userId');
            const deviceId = config.get('deviceId');
            if (!userId || !deviceId) {
                vscode.window.showErrorMessage('缺少必要的配置信息');
                return;
            }
            const confirmation = await vscode.window.showWarningMessage('确定要清除当前工作区的索引缓存吗？这将导致下次处理时重新索引所有文件。', '确定清除', '取消');
            if (confirmation === '确定清除') {
                const workspacePath = workspaceFolder.uri.fsPath;
                await chunkingService.clearWorkspaceIndexCache(workspacePath, userId, deviceId);
                vscode.window.showInformationMessage('索引缓存已清除');
            }
        }
        catch (error) {
            console.error('[CodeChunker] 清除索引缓存失败:', error);
            vscode.window.showErrorMessage(`清除索引缓存失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // 注册网络性能分析报告命令
    const networkPerformanceCommand = vscode.commands.registerCommand('test-electron-treesitter.networkPerformance', async () => {
        try {
            const report = await chunkingService.generateNetworkPerformanceReport();
            if (report) {
                vscode.window.showInformationMessage(`网络性能报告已生成，详细信息请查看控制台输出。\n` +
                    `总请求数: ${report.summary.totalRequests}\n` +
                    `平均网络通信时间: ${report.performance.networkCommunicationTime.avg.toFixed(2)}ms\n` +
                    `网络时间占比: ${report.performance.networkRatio.avg.toFixed(1)}%`);
            }
            else {
                vscode.window.showInformationMessage('暂无网络性能数据，请先执行一些代码分块操作。');
            }
        }
        catch (error) {
            console.error('[CodeChunker] 生成网络性能报告失败:', error);
            vscode.window.showErrorMessage(`生成网络性能报告失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // 注册清除网络性能数据命令
    const clearNetworkDataCommand = vscode.commands.registerCommand('test-electron-treesitter.clearNetworkData', async () => {
        try {
            await chunkingService.clearNetworkPerformanceData();
            vscode.window.showInformationMessage('网络性能数据已清除');
        }
        catch (error) {
            console.error('[CodeChunker] 清除网络性能数据失败:', error);
            vscode.window.showErrorMessage(`清除网络性能数据失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    context.subscriptions.push(chunkCodeCommand, checkProgressCommand, clearCacheCommand, cacheStatsCommand, clearIndexCacheCommand, networkPerformanceCommand, clearNetworkDataCommand);
    console.log('[CodeChunker] 代码分块命令已注册');
}


/***/ }),
/* 2 */
/***/ ((module) => {

"use strict";
module.exports = require("vscode");

/***/ }),
/* 3 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChunkingService = void 0;
const vscode = __importStar(__webpack_require__(2));
const path = __importStar(__webpack_require__(4));
const fs = __importStar(__webpack_require__(5));
const commonViews_1 = __webpack_require__(6);
const indexCacheService_1 = __webpack_require__(7);
// 导入 code-chunker 模块
const codeChunker = __webpack_require__(9);
// 全局变量来跟踪活跃的chunker实例
let activeChunkerInstance = null;
let isProcessing = false;
class ChunkingService {
    indexCacheService = null;
    /**
     * 初始化索引缓存服务
     */
    initializeIndexCache(context) {
        if (!this.indexCacheService) {
            this.indexCacheService = new indexCacheService_1.IndexCacheService(context);
        }
    }
    /**
     * 执行代码分块
     */
    async executeCodeChunking(context) {
        if (isProcessing) {
            vscode.window.showWarningMessage('代码分块正在进行中，请等待当前处理完成');
            return;
        }
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('请先打开一个工作区');
            return;
        }
        // 获取配置
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        const ignorePatterns = config.get('ignorePatterns') || [];
        // 检查必要的配置
        if (!userId || !deviceId || !token) {
            const result = await vscode.window.showErrorMessage('缺少必要的配置信息（用户ID、设备ID或Token），是否现在配置？', '去配置', '取消');
            if (result === '去配置') {
                await commonViews_1.CommonViews.showConfiguration();
            }
            return;
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        const workspaceName = path.basename(workspacePath);
        // 检查工作区是否存在
        if (!fs.existsSync(workspacePath)) {
            vscode.window.showErrorMessage(`工作区路径不存在: ${workspacePath}`);
            return;
        }
        isProcessing = true;
        // 初始化索引缓存服务
        if (context) {
            this.initializeIndexCache(context);
        }
        return await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: '代码分块处理中...',
            cancellable: false
        }, async (progress) => {
            try {
                progress.report({ increment: 0, message: '初始化处理环境...' });
                // 获取或创建chunker实例
                activeChunkerInstance = codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
                progress.report({ increment: 10, message: '检查文件索引缓存...' });
                // 如果启用了索引缓存，先检查哪些文件需要处理
                let filesToProcess = [];
                let skippedFiles = [];
                if (this.indexCacheService) {
                    try {
                        // 扫描工作区获取文件列表
                        const allFiles = await this.scanWorkspaceFiles(workspacePath, ignorePatterns);
                        // 检查哪些文件已经索引过
                        const { indexed, unindexed } = await this.indexCacheService.filterUnindexedFiles(allFiles, workspacePath, userId, deviceId);
                        filesToProcess = unindexed;
                        skippedFiles = indexed;
                        progress.report({
                            increment: 10,
                            message: `缓存检查完成：跳过 ${skippedFiles.length} 个文件，处理 ${filesToProcess.length} 个文件...`
                        });
                        // 显示缓存统计
                        if (skippedFiles.length > 0) {
                        }
                    }
                    catch (error) {
                        console.warn('[ChunkingService] 索引缓存检查失败，将处理所有文件:', error);
                        filesToProcess = []; // 空数组表示处理所有文件
                    }
                }
                progress.report({ increment: 10, message: '开始处理工作区文件...' });
                // 执行代码分块处理
                let success;
                try {
                    success = filesToProcess.length === 0
                        ? await codeChunker.processWorkspace(userId, deviceId, workspacePath, token, ignorePatterns)
                        : await this.processSpecificFiles(userId, deviceId, workspacePath, token, filesToProcess);
                }
                catch (processingError) {
                    const error = processingError instanceof Error ? processingError : new Error(String(processingError));
                    console.error('🔥 代码分块处理出现异常:', error);
                    console.error('🔥 异常详情:', {
                        name: error.name,
                        message: error.message,
                        stack: error.stack
                    });
                    vscode.window.showErrorMessage(`代码分块处理失败: ${error.message || 'Unknown error'}`);
                    return false;
                }
                // 如果处理成功且启用了缓存，标记新处理的文件为已索引
                if (success && this.indexCacheService && filesToProcess.length > 0) {
                    try {
                        await this.indexCacheService.markFilesAsIndexed(filesToProcess, workspacePath, userId, deviceId);
                    }
                    catch (error) {
                        console.warn('[ChunkingService] 标记文件索引状态失败:', error);
                    }
                }
                if (success) {
                    progress.report({ increment: 100, message: '处理完成！' });
                    vscode.window.showInformationMessage(`工作区 "${workspaceName}" 代码分块处理完成！`);
                    return true;
                }
                else {
                    vscode.window.showErrorMessage('代码分块处理失败');
                    return false;
                }
            }
            catch (error) {
                console.error('[CodeChunker] 处理过程出错:', error);
                vscode.window.showErrorMessage(`处理失败: ${error instanceof Error ? error.message : String(error)}`);
                return false;
            }
            finally {
                isProcessing = false;
            }
        });
    }
    /**
     * 查看分块进度
     */
    async checkChunkingProgress() {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('请先打开一个工作区');
            return;
        }
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        if (!userId || !deviceId || !token) {
            vscode.window.showErrorMessage('缺少必要的配置信息，请先配置');
            return;
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        try {
            // 使用缓存的实例或创建新实例
            const chunkerInstance = activeChunkerInstance || codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
            if (!chunkerInstance || !chunkerInstance.progressTracker) {
                vscode.window.showInformationMessage('暂无进度信息，请先开始代码分块处理');
                return;
            }
            // 获取进度信息
            const overallProgress = chunkerInstance.progressTracker.getOverallProgress();
            const fileProgress = chunkerInstance.progressTracker.getFileProgress();
            const fileProgressSummary = chunkerInstance.progressTracker.getFileProgressSummary();
            // 计算文件级别的进度百分比
            const fileProgressPercentage = chunkerInstance.progressTracker.getFileProgressPercentage();
            // 显示进度信息
            await commonViews_1.CommonViews.showProgressDetails(overallProgress, fileProgress, fileProgressSummary, fileProgressPercentage);
        }
        catch (error) {
            console.error('[CodeChunker] 获取进度信息失败:', error);
            vscode.window.showErrorMessage(`获取进度信息失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * 清除处理缓存
     */
    async clearProcessingCache() {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('请先打开一个工作区');
            return;
        }
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        if (!userId || !deviceId || !token) {
            vscode.window.showErrorMessage('缺少必要的配置信息');
            return;
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        try {
            // 获取chunker实例
            const chunkerInstance = activeChunkerInstance || codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
            if (!chunkerInstance.vectorManager) {
                vscode.window.showErrorMessage('VectorManager未初始化，无法清除缓存');
                return;
            }
            await vscode.window.withProgress({
                location: vscode.ProgressLocation.Notification,
                title: '清除缓存中...',
                cancellable: false
            }, async (progress) => {
                progress.report({ increment: 0, message: '获取缓存信息...' });
                // 获取向量信息
                const vectorInfo = await chunkerInstance.vectorManager.getVectorInfo();
                progress.report({ increment: 50, message: '清空临时向量存储...' });
                // 清空临时向量存储
                if (chunkerInstance.vectorManager.tempVectors) {
                    chunkerInstance.vectorManager.tempVectors.clear();
                }
                progress.report({ increment: 100, message: '临时存储清空完成！' });
                // 显示清空结果
                vscode.window.showInformationMessage(`临时存储清空完成！\n` +
                    `清空向量数: ${vectorInfo.totalVectors}\n` +
                    `释放空间: ${(vectorInfo.cacheSize / 1024 / 1024).toFixed(2)} MB`);
            });
        }
        catch (error) {
            console.error('[CodeChunker] 清除缓存失败:', error);
            vscode.window.showErrorMessage(`清除缓存失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * 计算文件进度
     */
    async calculateFileProgress(workspacePath, totalVectors) {
        const config = vscode.workspace.getConfiguration('codeChunker');
        const ignorePatterns = config.get('ignorePatterns') || [];
        let totalFiles = 0;
        let processedFiles = 0;
        async function scanDirectory(dirPath) {
            try {
                const items = await fs.promises.readdir(dirPath, { withFileTypes: true });
                for (const item of items) {
                    const fullPath = path.join(dirPath, item.name);
                    const relativePath = path.relative(workspacePath, fullPath);
                    // 检查是否应该忽略
                    const shouldIgnore = ignorePatterns.some(pattern => {
                        return relativePath.includes(pattern.replace(/\*\*/g, '').replace(/\*/g, ''));
                    });
                    if (shouldIgnore) {
                        continue;
                    }
                    if (item.isDirectory()) {
                        await scanDirectory(fullPath);
                    }
                    else if (item.isFile()) {
                        // 只统计代码文件
                        const ext = path.extname(item.name).toLowerCase();
                        const codeExtensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.go', '.rs', '.php', '.rb'];
                        if (codeExtensions.includes(ext)) {
                            totalFiles++;
                            // 简单估算：假设每个文件平均产生10个向量
                            const estimatedVectorsPerFile = 10;
                            if (totalVectors > (processedFiles * estimatedVectorsPerFile)) {
                                processedFiles++;
                            }
                        }
                    }
                }
            }
            catch (error) {
                console.warn(`扫描目录失败: ${dirPath}`, error);
            }
        }
        await scanDirectory(workspacePath);
        return {
            totalFiles,
            processedFiles,
            progressPercentage: totalFiles > 0 ? (processedFiles / totalFiles) * 100 : 0
        };
    }
    /**
     * 扫描工作区文件
     */
    async scanWorkspaceFiles(workspacePath, ignorePatterns) {
        const files = [];
        async function scanDirectory(dirPath) {
            try {
                const items = await fs.promises.readdir(dirPath, { withFileTypes: true });
                for (const item of items) {
                    const fullPath = path.join(dirPath, item.name);
                    const relativePath = path.relative(workspacePath, fullPath);
                    // 检查是否应该忽略
                    const shouldIgnore = ignorePatterns.some(pattern => {
                        return relativePath.includes(pattern.replace(/\*\*/g, '').replace(/\*/g, ''));
                    });
                    if (shouldIgnore) {
                        continue;
                    }
                    if (item.isDirectory()) {
                        await scanDirectory(fullPath);
                    }
                    else if (item.isFile()) {
                        // 只包含代码文件
                        const ext = path.extname(item.name).toLowerCase();
                        const codeExtensions = ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.go', '.rs', '.php', '.rb', '.cs', '.css', '.html', '.json', '.xml', '.yaml', '.yml', '.md'];
                        if (codeExtensions.includes(ext)) {
                            files.push(relativePath);
                        }
                    }
                }
            }
            catch (error) {
                console.warn(`扫描目录失败: ${dirPath}`, error);
            }
        }
        await scanDirectory(workspacePath);
        return files;
    }
    /**
     * 处理特定文件列表
     */
    async processSpecificFiles(userId, deviceId, workspacePath, token, filesToProcess) {
        try {
            // 这里可以调用 code-chunker 的特定文件处理方法
            // 如果 code-chunker 没有提供此方法，可以使用完整处理但只标记特定文件
            // 临时解决方案：仍然处理所有文件，但索引缓存会记录具体的文件状态
            const success = await codeChunker.processWorkspace(userId, deviceId, workspacePath, token);
            return success;
        }
        catch (error) {
            console.error('[ChunkingService] 处理特定文件失败:', error);
            return false;
        }
    }
    /**
     * 获取索引缓存统计信息
     */
    async getCacheStats() {
        if (!this.indexCacheService) {
            return null;
        }
        return this.indexCacheService.getCacheStats();
    }
    /**
     * 清除工作区索引缓存
     */
    async clearWorkspaceIndexCache(workspacePath, userId, deviceId) {
        if (this.indexCacheService) {
            await this.indexCacheService.clearWorkspaceCache(workspacePath, userId, deviceId);
        }
    }
    /**
     * 生成网络性能分析报告
     */
    async generateNetworkPerformanceReport() {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                vscode.window.showErrorMessage('请先打开一个工作区');
                return null;
            }
            const config = vscode.workspace.getConfiguration('codeChunker');
            const userId = config.get('userId');
            const deviceId = config.get('deviceId');
            const token = config.get('token');
            if (!userId || !deviceId || !token) {
                vscode.window.showErrorMessage('缺少必要的配置信息');
                return null;
            }
            const workspacePath = workspaceFolder.uri.fsPath;
            // 获取chunker实例
            const chunkerInstance = activeChunkerInstance || codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
            if (!chunkerInstance.vectorManager || !chunkerInstance.vectorManager.embeddingClient) {
                vscode.window.showErrorMessage('EmbeddingClient未初始化，无法生成网络性能报告');
                return null;
            }
            // 调用embeddingClient的网络性能报告方法
            const report = chunkerInstance.vectorManager.embeddingClient.generateNetworkPerformanceReport();
            return report;
        }
        catch (error) {
            console.error('[ChunkingService] 生成网络性能报告失败:', error);
            throw error;
        }
    }
    /**
     * 清除网络性能数据
     */
    async clearNetworkPerformanceData() {
        try {
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                vscode.window.showErrorMessage('请先打开一个工作区');
                return;
            }
            const config = vscode.workspace.getConfiguration('codeChunker');
            const userId = config.get('userId');
            const deviceId = config.get('deviceId');
            const token = config.get('token');
            if (!userId || !deviceId || !token) {
                vscode.window.showErrorMessage('缺少必要的配置信息');
                return;
            }
            const workspacePath = workspaceFolder.uri.fsPath;
            // 获取chunker实例
            const chunkerInstance = activeChunkerInstance || codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
            if (!chunkerInstance.vectorManager || !chunkerInstance.vectorManager.embeddingClient) {
                vscode.window.showErrorMessage('EmbeddingClient未初始化，无法清除网络性能数据');
                return;
            }
            // 调用embeddingClient的清除网络性能数据方法
            chunkerInstance.vectorManager.embeddingClient.clearNetworkPerformanceData();
        }
        catch (error) {
            console.error('[ChunkingService] 清除网络性能数据失败:', error);
            throw error;
        }
    }
}
exports.ChunkingService = ChunkingService;


/***/ }),
/* 4 */
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),
/* 5 */
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),
/* 6 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommonViews = void 0;
const vscode = __importStar(__webpack_require__(2));
class CommonViews {
    /**
     * 显示配置界面
     */
    static async showConfiguration() {
        const config = vscode.workspace.getConfiguration('codeChunker');
        // 获取当前配置值
        const currentUserId = config.get('userId') || '';
        const currentDeviceId = config.get('deviceId') || '';
        const currentToken = config.get('token') || '';
        // 显示用户ID输入框
        const userId = await vscode.window.showInputBox({
            prompt: '请输入用户ID',
            value: currentUserId,
            placeHolder: '例如: user123',
            validateInput: (value) => {
                if (!value || value.trim().length === 0) {
                    return '用户ID不能为空';
                }
                if (value.trim().length < 3) {
                    return '用户ID至少需要3个字符';
                }
                return null;
            }
        });
        if (userId === undefined) {
            return; // 用户取消
        }
        // 显示设备ID输入框
        const deviceId = await vscode.window.showInputBox({
            prompt: '请输入设备ID',
            value: currentDeviceId,
            placeHolder: '例如: device456',
            validateInput: (value) => {
                if (!value || value.trim().length === 0) {
                    return '设备ID不能为空';
                }
                if (value.trim().length < 3) {
                    return '设备ID至少需要3个字符';
                }
                return null;
            }
        });
        if (deviceId === undefined) {
            return; // 用户取消
        }
        // 显示Token输入框
        const token = await vscode.window.showInputBox({
            prompt: '请输入访问令牌',
            value: currentToken,
            placeHolder: '例如: your_access_token',
            password: true, // 隐藏输入内容
            validateInput: (value) => {
                if (!value || value.trim().length === 0) {
                    return '访问令牌不能为空';
                }
                if (value.trim().length < 10) {
                    return '访问令牌至少需要10个字符';
                }
                return null;
            }
        });
        if (token === undefined) {
            return; // 用户取消
        }
        try {
            // 保存配置
            await config.update('userId', userId.trim(), vscode.ConfigurationTarget.Global);
            await config.update('deviceId', deviceId.trim(), vscode.ConfigurationTarget.Global);
            await config.update('token', token.trim(), vscode.ConfigurationTarget.Global);
            vscode.window.showInformationMessage(`配置已保存！\n用户ID: ${userId}\n设备ID: ${deviceId}\nToken: ${token.substring(0, 6)}...`);
        }
        catch (error) {
            console.error('[CommonViews] 保存配置失败:', error);
            vscode.window.showErrorMessage(`保存配置失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * 显示进度详情
     */
    static async showProgressDetails(overallProgress, fileProgress, fileProgressSummary, fileProgressPercentage) {
        const outputChannel = vscode.window.createOutputChannel('代码分块进度');
        try {
            outputChannel.clear();
            outputChannel.appendLine('📊 代码分块处理进度报告');
            outputChannel.appendLine(`⏰ 更新时间: ${new Date().toLocaleString()}`);
            outputChannel.appendLine(`${'='.repeat(60)}\n`);
            // 文件级别进度
            outputChannel.appendLine('📁 文件处理进度:');
            outputChannel.appendLine(`   总文件数: ${fileProgress.totalFiles}`);
            outputChannel.appendLine(`   已完成: ${fileProgress.completedFiles}`);
            outputChannel.appendLine(`   处理中: ${fileProgress.processingFiles}`);
            outputChannel.appendLine(`   等待中: ${fileProgress.pendingFiles}`);
            outputChannel.appendLine(`   失败: ${fileProgress.failedFiles}`);
            outputChannel.appendLine(`   进度: ${fileProgressPercentage.toFixed(2)}%\n`);
            // 代码块级别进度
            outputChannel.appendLine('🔗 代码块处理进度:');
            outputChannel.appendLine(`   总代码块: ${overallProgress.totalChunks}`);
            outputChannel.appendLine(`   已完成: ${overallProgress.completedChunks}`);
            outputChannel.appendLine(`   处理中: ${overallProgress.processingChunks}`);
            outputChannel.appendLine(`   等待中: ${overallProgress.pendingChunks}`);
            outputChannel.appendLine(`   失败: ${overallProgress.failedChunks}`);
            outputChannel.appendLine(`   成功率: ${overallProgress.successRate.toFixed(2)}%\n`);
            // 文件详细进度
            if (fileProgressSummary && fileProgressSummary.length > 0) {
                outputChannel.appendLine('📄 文件详细进度:');
                outputChannel.appendLine(`${'文件名'.padEnd(25)} ${'语言'.padEnd(12)} ${'完成'.padEnd(6)} ${'总计'.padEnd(6)} ${'成功率'.padEnd(8)}`);
                outputChannel.appendLine('-'.repeat(60));
                fileProgressSummary.forEach(fileInfo => {
                    const fileName = fileInfo.file.length > 23 ? fileInfo.file.substring(0, 20) + '...' : fileInfo.file;
                    const language = fileInfo.language || 'unknown';
                    const completed = fileInfo.completed.toString();
                    const total = fileInfo.total.toString();
                    const successRate = fileInfo.successRate.toFixed(1) + '%';
                    outputChannel.appendLine(`${fileName.padEnd(25)} ${language.padEnd(12)} ${completed.padEnd(6)} ${total.padEnd(6)} ${successRate.padEnd(8)}`);
                });
            }
            outputChannel.appendLine(`\n${'='.repeat(60)}`);
            outputChannel.appendLine('💡 提示: 如果处理停滞，可以尝试重新运行代码分块命令');
            // 显示输出面板
            outputChannel.show(true);
            // 显示摘要通知
            const summaryMessage = `处理进度: 文件 ${fileProgress.completedFiles}/${fileProgress.totalFiles} (${fileProgressPercentage.toFixed(1)}%), ` +
                `代码块 ${overallProgress.completedChunks}/${overallProgress.totalChunks} (${overallProgress.successRate.toFixed(1)}%)`;
            vscode.window.showInformationMessage(summaryMessage);
        }
        catch (error) {
            console.error('[CommonViews] 显示进度详情失败:', error);
            vscode.window.showErrorMessage(`显示进度详情失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * 显示简单的信息消息
     */
    static showInfo(message) {
        vscode.window.showInformationMessage(message);
    }
    /**
     * 显示警告消息
     */
    static showWarning(message) {
        vscode.window.showWarningMessage(message);
    }
    /**
     * 显示错误消息
     */
    static showError(message) {
        vscode.window.showErrorMessage(message);
    }
    /**
     * 显示带进度的任务
     */
    static async showProgress(title, task) {
        return await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: title,
            cancellable: false
        }, task);
    }
}
exports.CommonViews = CommonViews;


/***/ }),
/* 7 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IndexCacheService = void 0;
const fs = __importStar(__webpack_require__(5));
const path = __importStar(__webpack_require__(4));
const crypto = __importStar(__webpack_require__(8));
class IndexCacheService {
    context;
    cacheFilePath;
    cache = new Map();
    isInitialized = false;
    constructor(context) {
        this.context = context;
        this.cacheFilePath = path.join(context.globalStorageUri.fsPath, 'indexed-files-cache.json');
    }
    /**
     * 初始化缓存服务
     */
    async initialize() {
        try {
            // 确保全局存储目录存在
            await fs.promises.mkdir(path.dirname(this.cacheFilePath), { recursive: true });
            // 加载现有缓存
            await this.loadCache();
            this.isInitialized = true;
        }
        catch (error) {
            console.error('[IndexCacheService] 初始化失败:', error);
            this.isInitialized = true; // 即使失败也标记为已初始化，避免阻塞
        }
    }
    /**
     * 检查文件是否已经索引过
     */
    async isFileIndexed(filePath, workspacePath, userId, deviceId) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        try {
            // 计算文件哈希
            const fileHash = await this.calculateFileHash(filePath);
            const cacheKey = this.generateCacheKey(filePath, workspacePath, userId, deviceId);
            const cachedRecord = this.cache.get(cacheKey);
            if (!cachedRecord) {
                return false;
            }
            // 检查文件是否被修改过
            if (cachedRecord.fileHash !== fileHash) {
                // 移除过期的缓存记录
                this.cache.delete(cacheKey);
                return false;
            }
            return true;
        }
        catch (error) {
            console.error(`[IndexCacheService] 检查文件索引状态失败: ${filePath}`, error);
            return false; // 出错时默认进行索引
        }
    }
    /**
     * 标记文件为已索引
     */
    async markFileAsIndexed(filePath, workspacePath, userId, deviceId) {
        if (!this.isInitialized) {
            await this.initialize();
        }
        try {
            const fileHash = await this.calculateFileHash(filePath);
            const cacheKey = this.generateCacheKey(filePath, workspacePath, userId, deviceId);
            const record = {
                filePath,
                fileHash,
                indexedAt: Date.now(),
                workspacePath,
                userId,
                deviceId
            };
            this.cache.set(cacheKey, record);
            // 异步保存缓存，不阻塞主流程
            this.saveCache().catch(error => {
                console.error('[IndexCacheService] 保存缓存失败:', error);
            });
        }
        catch (error) {
            console.error(`[IndexCacheService] 标记文件索引失败: ${filePath}`, error);
        }
    }
    /**
     * 批量检查文件索引状态
     */
    async filterUnindexedFiles(files, workspacePath, userId, deviceId) {
        const indexed = [];
        const unindexed = [];
        for (const file of files) {
            const fullPath = path.isAbsolute(file) ? file : path.join(workspacePath, file);
            try {
                const isIndexed = await this.isFileIndexed(fullPath, workspacePath, userId, deviceId);
                if (isIndexed) {
                    indexed.push(file);
                }
                else {
                    unindexed.push(file);
                }
            }
            catch (error) {
                console.error(`[IndexCacheService] 检查文件失败: ${file}`, error);
                unindexed.push(file); // 出错时默认需要索引
            }
        }
        return { indexed, unindexed };
    }
    /**
     * 批量标记文件为已索引
     */
    async markFilesAsIndexed(files, workspacePath, userId, deviceId) {
        for (const file of files) {
            const fullPath = path.isAbsolute(file) ? file : path.join(workspacePath, file);
            await this.markFileAsIndexed(fullPath, workspacePath, userId, deviceId);
        }
    }
    /**
     * 清除指定工作区的缓存
     */
    async clearWorkspaceCache(workspacePath, userId, deviceId) {
        const keysToDelete = [];
        for (const [key, record] of this.cache.entries()) {
            if (record.workspacePath === workspacePath &&
                record.userId === userId &&
                record.deviceId === deviceId) {
                keysToDelete.push(key);
            }
        }
        keysToDelete.forEach(key => this.cache.delete(key));
        await this.saveCache();
    }
    /**
     * 获取缓存统计信息
     */
    getCacheStats() {
        let oldestTime = Number.MAX_SAFE_INTEGER;
        let newestTime = 0;
        for (const record of this.cache.values()) {
            if (record.indexedAt < oldestTime) {
                oldestTime = record.indexedAt;
            }
            if (record.indexedAt > newestTime) {
                newestTime = record.indexedAt;
            }
        }
        const stats = {
            totalFiles: this.cache.size,
            totalSize: this.formatSize(JSON.stringify([...this.cache.values()]).length),
            oldestRecord: oldestTime === Number.MAX_SAFE_INTEGER ? undefined : new Date(oldestTime),
            newestRecord: newestTime === 0 ? undefined : new Date(newestTime)
        };
        return stats;
    }
    /**
     * 生成缓存键
     */
    generateCacheKey(filePath, workspacePath, userId, deviceId) {
        const relativePath = path.relative(workspacePath, filePath);
        const identifier = `${userId}_${deviceId}_${workspacePath}_${relativePath}`;
        return crypto.createHash('md5').update(identifier).digest('hex');
    }
    /**
     * 计算文件哈希
     */
    async calculateFileHash(filePath) {
        try {
            const content = await fs.promises.readFile(filePath);
            return crypto.createHash('md5').update(content).digest('hex');
        }
        catch (error) {
            console.warn(`[IndexCacheService] 计算文件哈希失败: ${filePath}`, error);
            // 如果无法读取文件，使用文件路径和修改时间作为替代
            const stats = await fs.promises.stat(filePath);
            return crypto.createHash('md5').update(`${filePath}_${stats.mtime.getTime()}`).digest('hex');
        }
    }
    /**
     * 加载缓存数据
     */
    async loadCache() {
        try {
            if (!fs.existsSync(this.cacheFilePath)) {
                return;
            }
            const cacheContent = await fs.promises.readFile(this.cacheFilePath, 'utf8');
            const cacheData = JSON.parse(cacheContent);
            // 验证缓存版本兼容性
            if (!cacheData.version || cacheData.version !== '1.0') {
                return;
            }
            // 重建缓存映射
            this.cache.clear();
            for (const record of cacheData.records || []) {
                const key = this.generateCacheKey(record.filePath, record.workspacePath, record.userId, record.deviceId);
                this.cache.set(key, record);
            }
        }
        catch (error) {
            console.error('[IndexCacheService] 加载缓存失败:', error);
            this.cache.clear();
        }
    }
    /**
     * 保存缓存数据
     */
    async saveCache() {
        try {
            const cacheData = {
                version: '1.0',
                records: [...this.cache.values()],
                lastUpdated: Date.now()
            };
            await fs.promises.writeFile(this.cacheFilePath, JSON.stringify(cacheData, null, 2), 'utf8');
        }
        catch (error) {
            console.error('[IndexCacheService] 保存缓存失败:', error);
        }
    }
    /**
     * 格式化文件大小
     */
    formatSize(bytes) {
        const units = ['B', 'KB', 'MB', 'GB'];
        let size = bytes;
        let unitIndex = 0;
        while (size >= 1024 && unitIndex < units.length - 1) {
            size /= 1024;
            unitIndex++;
        }
        return `${size.toFixed(2)} ${units[unitIndex]}`;
    }
}
exports.IndexCacheService = IndexCacheService;


/***/ }),
/* 8 */
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),
/* 9 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const CodeChunker = __webpack_require__(10);
const fs = __webpack_require__(5);
const path = __webpack_require__(4);
const yaml = __webpack_require__(49);

// 全局CodeChunker实例缓存
const chunkerInstances = new Map();

/**
 * 加载默认配置
 */
function loadDefaultConfig() {
    // 🔥 内置多语言项目优化配置，支持Python、C++、CUDA等深度学习项目
    const builtinConfig = {
        scanFileExtensions: [
            // Python files
            '.py', '.pyx', '.pyi', '.pyw',
            // C/C++ files
            '.c', '.cpp', '.cc', '.cxx', '.c++', '.h', '.hpp', '.hh', '.hxx', '.h++',
            // CUDA files
            '.cu', '.cuh',
            // Configuration files
            '.yaml', '.yml', '.json', '.toml', '.ini', '.cfg', '.conf',
            // Build files
            '.cmake', '.txt', '.mk', '.make',
            // Documentation
            '.md', '.rst', '.txt',
            // Shell scripts
            '.sh', '.bash', '.zsh', '.fish',
            // Java files (keep for backward compatibility)
            '.java', '.xml', '.properties',
            // JavaScript/TypeScript
            '.js', '.ts', '.jsx', '.tsx',
            // Other common formats
            '.sql', '.proto', '.proto3'
        ],
        maxWorkers: 1,
        useWorkers: false,
        batchSize: 10,
        linesPerChunk: 20,
        ignoredDirectories: [
            'node_modules', '.git', '.vscode', '.idea', 'target', 'build', 'out', 'bin', 'classes',
            'test', 'tests', 'src/test', 'sql', 'database', 'db', 'flowable-patch', 'patch',
            'lib', 'libs', 'vendor', 'third-party', 'ui', 'frontend', 'static', 'dist',
            'script', 'scripts', 'doc', 'docs', 'logs', 'log', 'temp', 'tmp'
        ],
        ignorePatterns: [
            '**/*.sql', '**/sql/**', '**/test/**', '**/tests/**', '**/target/**', '**/build/**',
            '**/flowable-patch/**', '**/third-party/**', '**/vendor/**', '**/lib/**', '**/libs/**',
            '**/node_modules/**', '**/.git/**', '**/.vscode/**', '**/.idea/**',
            // CUDA和深度学习项目特有忽略
            '**/cubin/**', '**/*.cubin', '**/*.cubin.cpp', '**/*.ptx', '**/*.fatbin',
            '**/models/**', '**/weights/**', '**/data/**', '**/datasets/**',
            '**/*.bin', '**/*.onnx', '**/*.pb', '**/*.pth', '**/*.engine', '**/*.plan',
            '**/__pycache__/**', '**/venv/**', '**/wandb/**', '**/runs/**'
        ]
    };
    
    // 🔥 尝试加载外部配置文件，但如果失败则使用内置配置
    const defaultConfigPath = path.join(__dirname, 'config', 'default.yaml');
    
    try {
        if (fs.existsSync(defaultConfigPath)) {
            const defaultConfigContent = fs.readFileSync(defaultConfigPath, 'utf8');
            const externalConfig = yaml.parse(defaultConfigContent);
            return externalConfig;
        } else {
            return builtinConfig;
        }
    } catch (error) {
        console.error('[CodeChunker] ❌ 加载外部配置失败，使用内置配置:', error);
        return builtinConfig;
    }
}

/**
 * 获取或创建CodeChunker实例
 */
function getChunkerInstance(userId, deviceId, workspacePath, token) {
    const key = `${userId}_${deviceId}_${workspacePath}`;
    
    if (!chunkerInstances.has(key)) {
        // 🔥 加载默认配置（包含白名单和优化设置）
        const defaultConfig = loadDefaultConfig();
        
        // 合并配置：默认配置 + 运行时配置
        const config = {
            ...defaultConfig, // 🔥 首先应用default.yaml配置
            workspacePath,
            userId,
            deviceId,
            token,
            vectorManager: {
                enabled: true,
                logLevel: 'info',
                
                cache: {
                    size: defaultConfig.vectorCache?.maxSize || 200,
                    uploadThreshold: 10,
                    memoryThreshold: defaultConfig.performance?.maxMemoryUsage || 0.6,
                    persistPath: "./vector-cache",
                    cleanupInterval: 1800000
                },
                
                security: {
                    enabled: false,
                    keyPath: "./keys/vector.key"
                },
                
                embedding: {
                    timeout: 30000,
                    batchSize: defaultConfig.batchSize || 10,
                    maxRetries: 3
                },
                
                database: {
                    type: 'tencent_cloud',
                    connection: {
                        type: 'tencent',
                        host: 'http://nj-vdb-dz5mmt48.sql.tencentcdb.com',
                        port: 8100,
                        database: 'vectorservice-test',
                        username: 'root',
                        apiKey: '4xVMtNrcgYd3FQ35A3YkWuFTcvn63t0hkBkDWfKS',
                        timeout: 30000
                    },
                    collections: {
                        vectorDimension: 768,
                        metricType: 'COSINE',
                        indexType: 'HNSW'
                    },
                    query: {
                        defaultDatabase: 'vectorservice-test'
                    },
                    batchSize: defaultConfig.batchSize || 10
                }
            }
        };
        
        const chunkerInstance = new CodeChunker(config);
        chunkerInstances.set(key, chunkerInstance);
        
        return chunkerInstance;
    }
    
    return chunkerInstances.get(key);
}

/**
 * 统一签名的入口函数 - 使用缓存实例
 */
async function processWorkspace(userId, deviceId, workspacePath, token, ignorePatterns) {
    // 使用缓存的实例，确保与进度查询使用同一个实例
    const chunker = getChunkerInstance(userId, deviceId, workspacePath, token);
    
    // 执行处理
    const result = await chunker.processWorkspace(userId, deviceId, workspacePath, token, ignorePatterns);
    
    return result;
}

module.exports = {
    processWorkspace,
    getChunkerInstance,
    chunkerInstances,
    CodeChunker
}; 

/***/ }),
/* 10 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const yaml = __webpack_require__(49);
const config = __webpack_require__(123);
const FileScanner = __webpack_require__(125);
const ParserSelector = __webpack_require__(137);
const Dispatcher = __webpack_require__(144);
const Sender = __webpack_require__(147);
const ProgressTracker = __webpack_require__(220);
const MerkleTree = __webpack_require__(237);
const VectorManager = __webpack_require__(221);
const PerformanceAnalyzer = __webpack_require__(238);

class CodeChunker {
    constructor(userConfig) {
        this.config = this._loadConfig(userConfig);
        this.progressTracker = new ProgressTracker();
        this.fileScanner = new FileScanner(this.config);
        this.parserSelector = new ParserSelector(this.config);
        this.dispatcher = new Dispatcher(this.config);
        this.merkleTree = new MerkleTree();
        
        // 初始化性能分析器
        this.performanceAnalyzer = new PerformanceAnalyzer();
        
        // 初始化 VectorManager（只有在明确启用时才初始化）
        if (this.config.vectorManager?.enabled === true) {
            this.vectorManager = new VectorManager(this.config.vectorManager);
            this.vectorManager.initialize().catch(error => {
                this.error('Failed to initialize VectorManager:', error);
            });
        } else {
            this.log('VectorManager is disabled, skipping initialization.');
        }
        
        // 初始化Sender，传入VectorManager和性能分析器
        this.sender = new Sender(this.config, this.progressTracker, this.vectorManager);
        
        this.version = '0.1.0';
    }

    _loadConfig(userConfig) {
        // 加载默认配置
        const defaultConfigPath = path.join(__dirname, '..', 'config', 'default.yaml');
        let defaultConfig = {};
        
        try {
            if (fs.existsSync(defaultConfigPath)) {
                const defaultConfigContent = fs.readFileSync(defaultConfigPath, 'utf8');
                defaultConfig = yaml.parse(defaultConfigContent);
            }
        } catch (error) {
            console.warn('Error loading default config:', error);
        }

        // 合并用户配置
        return {
            ...defaultConfig,
            ...userConfig
        };
    }

    log(message) {
        console.log(message);
    }

    error(message) {
        console.error(message);
    }

    warn(message) {
        console.warn(message);
    }

    async processWorkspace(userId, deviceId, workspacePath, token, ignorePatterns = []) {
        const startTime = Date.now();
        
        try {
            // 开始性能分析
            this.performanceAnalyzer.startAnalysis(workspacePath, userId, deviceId);
            
            this.log(`Starting Code Chunker v${this.version} for workspace: ${workspacePath}`);
            
            // 更新配置
            const updatedConfig = {
                ...this.config,
                workspacePath,
                ignorePatterns: Array.isArray(ignorePatterns) ? ignorePatterns : [],
                userId,
                deviceId,
                token
            };
            
            // 重新初始化组件
            this.progressTracker = new ProgressTracker();
            this.config = { ...updatedConfig, progressTracker: this.progressTracker };
            
            this.fileScanner = new FileScanner(this.config, this.performanceAnalyzer);
            this.parserSelector = new ParserSelector(this.config, this.performanceAnalyzer);
            this.dispatcher = new Dispatcher(this.config, this.performanceAnalyzer);
            this.merkleTree = new MerkleTree();
            
            // 重新初始化Sender，传入现有的VectorManager和性能分析器
            this.sender = new Sender(this.config, this.progressTracker, this.vectorManager, this.performanceAnalyzer);
            
            // 如果 VectorManager 已存在且启用，则更新配置；否则初始化
            if (this.config.vectorManager?.enabled === true) {
                if (!this.vectorManager) {
                    this.vectorManager = new VectorManager(this.config.vectorManager);
                    await this.vectorManager.initialize();
                }
                // 不需要重新初始化，VectorManager可以重用
            }

           
            // return;
            this.log('Scanning workspace...');
            this.performanceAnalyzer.startFileScanning();
            const { fileList, fileContents, merkleTree: scanMerkleTree, fileHashes, scanStats } = await this.fileScanner.scanWorkspace(workspacePath);
            this.performanceAnalyzer.endFileScanning(fileList.length, scanStats ? scanStats.skippedFiles : 0);
            this.log(`Found ${fileList.length} files to process.`);
            
            // 新增：注册文件到进度跟踪器
            this.progressTracker.registerFiles(fileList);
            this.log(`Registered ${fileList.length} files for progress tracking.`);

            // 构建 Merkle 树 - 优化：使用fileScanner中已计算的哈希值
            let rootHash, tree;
            if (scanMerkleTree && scanMerkleTree.rootHash) {
                // 如果fileScanner已经构建了增强的Merkle树，直接使用
                rootHash = scanMerkleTree.rootHash;
                tree = scanMerkleTree.tree;
                this.merkleTree.leaves = scanMerkleTree.leaves || [];
                this.merkleTree.tree = tree || [];
            } else {
                // 从已计算的哈希构建Merkle树（避免重复哈希计算）
                const hashArray = fileList.map(filePath => fileHashes[filePath]);
                const result = this.merkleTree.buildTree(hashArray);
                rootHash = result.rootHash;
                tree = result.tree;
            }
            this.log(`Generated Merkle tree with root hash: ${rootHash}`);

            this.log('Processing files concurrently...');
            this.performanceAnalyzer.startFileParsing(fileList.length);
            const fileObjects = fileList.map((f, index) => ({ 
                path: f,
                merkleProof: this.merkleTree.getProof(index)
            }));
            const chunks = await this.dispatcher.processFilesConcurrently(fileObjects, this.parserSelector);
            
            // 获取真实的Worker统计信息
            const workerStats = this.dispatcher.getWorkerStats();
            const successFiles = chunks.length > 0 ? fileList.length : 0;
            const failedFiles = fileList.length - successFiles;
            const syncCount = workerStats.useWorkers ? 0 : fileList.length;
            const workerCount = workerStats.useWorkers ? fileList.length : 0;
            
            this.performanceAnalyzer.endFileParsing(
                successFiles, 
                failedFiles, 
                workerStats.workerFailures, 
                syncCount, 
                workerCount
            );
            this.log(`Generated ${chunks.length} chunks`);
            
            // 记录分块生成信息
            const chunkSizes = chunks.map(chunk => chunk.content ? chunk.content.length : 0);
            this.performanceAnalyzer.recordChunkGeneration(chunks.length, chunkSizes);
            
            // ============ 集合清理和重新创建 - 强制执行 ============
            this.log('开始清理和重新创建集合（强制执行）');
            this.performanceAnalyzer.startVectorDBOperations();
            await this._cleanAndRecreateCollection(userId, deviceId, workspacePath);
            this.log('集合清理和重新创建完成');
            
            this.log('Sending chunks to embedding service...');
            this.performanceAnalyzer.startEmbeddingGeneration();
            await this.sender.sendChunks(chunks, rootHash);
             
            // 数据已直接发送到向量数据库，无需额外持久化

            // 更新文件处理状态为完成
            if (this.progressTracker) {
                // 将所有文件标记为已完成
                for (const filePath of fileList) {
                    this.progressTracker.updateFileStatus(filePath, 'completed');
                }
                
                const finalProgress = this.progressTracker.getOverallProgress();
                const fileProgress = this.progressTracker.getFileProgress();
                
                this.log(`File Processing Summary: ${fileProgress.completedFiles}/${fileProgress.totalFiles} files completed (${this.progressTracker.getFileProgressPercentage().toFixed(2)}%)`);
                this.log(`Chunk Processing Summary: ${finalProgress.completedChunks}/${finalProgress.totalChunks} chunks completed (${finalProgress.successRate.toFixed(2)}%)`);
                
                if (finalProgress.successRate < 100) {
                    this.warn("Some chunks could not be sent");
                }
                
                // 记录内存使用情况
                this.performanceAnalyzer.recordMemoryUsage('completion');
                
                // 完成性能分析并生成报告
                this.performanceAnalyzer.endVectorDBOperations(chunks.length, Math.ceil(chunks.length / 10)); // 假设每批10个
                const performanceReport = await this.performanceAnalyzer.endAnalysis();
                
                this.log(`\n🎉 ============== 项目处理完成 ==============`);
                this.log(`📊 性能测速报告已自动生成:`);
                this.log(`   📁 报告文件夹: ${this.performanceAnalyzer.reportFolder}`);
                this.log(`   📄 JSON报告: ${this.performanceAnalyzer.reportPath}`);
                this.log(`   📄 MD报告: ${this.performanceAnalyzer.reportPath.replace('.json', '.md')}`);
                
                if (performanceReport) {
                    const totalTime = (performanceReport.summary.totalDuration / 1000).toFixed(2);
                    const score = this.performanceAnalyzer._calculatePerformanceScore(performanceReport);
                    
                    this.log(`\n📈 性能概览:`);
                    this.log(`   ⏱️  总处理时间: ${totalTime}秒`);
                    this.log(`   📁 处理文件数: ${performanceReport.summary.processedFiles}/${performanceReport.summary.totalFiles}`);
                    this.log(`   🧩 生成代码块: ${performanceReport.summary.totalChunks}`);
                    this.log(`   🌐 Embedding请求: ${performanceReport.summary.totalEmbeddingRequests}`);
                    this.log(`   📊 插入向量数: ${performanceReport.summary.insertedVectors}`);
                    this.log(`   🎯 性能评分: ${score}/100 分`);
                    
                    if (performanceReport.performance.bottlenecks.length > 0) {
                        this.log(`\n🚨 发现 ${performanceReport.performance.bottlenecks.length} 个性能瓶颈:`);
                        performanceReport.performance.bottlenecks.forEach((bottleneck, index) => {
                            const icon = bottleneck.impact === 'high' ? '🔴' : bottleneck.impact === 'medium' ? '🟡' : '🟢';
                            this.log(`   ${index + 1}. ${icon} ${bottleneck.phase}: ${bottleneck.description}`);
                        });
                    } else {
                        this.log(`\n✅ 未检测到明显性能瓶颈，运行良好！`);
                    }
                    
                    if (performanceReport.performance.recommendations.length > 0) {
                        this.log(`\n💡 性能优化建议:`);
                        performanceReport.performance.recommendations.slice(0, 3).forEach((rec, index) => {
                            const icon = rec.priority === 'high' ? '🔴' : rec.priority === 'medium' ? '🟡' : '🟢';
                            this.log(`   ${index + 1}. ${icon} ${rec.category}: ${rec.suggestion}`);
                        });
                    }
                }
                
                this.log(`\n📋 请查看详细的性能测速报告以了解更多信息。`);
                this.log(`===============================================\n`);
            }

            const endTime = Date.now();
            this.log(`Code Chunker completed in ${((endTime - startTime) / 1000).toFixed(2)} seconds`);

            return true;
        } catch (error) {
            this.error('❌ Error in processWorkspace:', error);
            this.error('❌ Error details:', {
                name: error.name,
                message: error.message,
                stack: error.stack
            });
            
            // 向上抛出错误而不是返回false，这样TypeScript层可以看到具体错误
            throw error;
        }
    }

    // 添加搜索方法
    async search(query, options = {}) {
        if (!this.vectorManager) {
            throw new Error('VectorManager is not enabled');
        }

        try {
            const searchResults = await this.vectorManager.search(query, options.topK || 10, {
                userId: this.config.userId,
                deviceId: this.config.deviceId,
                workspacePath: this.config.workspacePath,
                ...options
            });

            // 过滤掉包含"unknown"的结果
            const filteredResults = this._filterUnknownResults(searchResults);
            
            // 记录过滤信息
            if (searchResults.length !== filteredResults.length) {
                this.log(`搜索结果过滤: 原始${searchResults.length}条 -> 过滤后${filteredResults.length}条 (移除了${searchResults.length - filteredResults.length}条包含"unknown"的结果)`);
            }

            return filteredResults;
        } catch (error) {
            this.error('Error searching vectors:', error);
            throw error;
        }
    }

    /**
     * 过滤包含"unknown"的搜索结果
     * @param {Array} results - 原始搜索结果
     * @returns {Array} 过滤后的结果
     */
    _filterUnknownResults(results) {
        if (!Array.isArray(results)) {
            return results;
        }

        return results.filter(result => {
            // 检查各个可能包含"unknown"的字段
            const fieldsToCheck = [
                result.filePath,
                result.content, 
                result.chunkId,
                result.metadata?.userId,
                result.metadata?.deviceId,
                result.metadata?.workspacePath,
                result.metadata?.vectorModel
            ];

            // 检查是否有任何字段包含"unknown"（不区分大小写）
            const hasUnknown = fieldsToCheck.some(field => {
                if (typeof field === 'string') {
                    return field.toLowerCase().includes('unknown');
                }
                return false;
            });

            // 额外检查：如果filePath是"unknown"或以"unknown"开头，也过滤掉
            if (result.filePath && 
                (result.filePath.toLowerCase() === 'unknown' || 
                 result.filePath.toLowerCase().startsWith('unknown/'))) {
                return false;
            }

            // 额外检查：如果content为空或只有空白字符，也过滤掉
            if (!result.content || result.content.trim().length === 0) {
                return false;
            }

            return !hasUnknown;
        });
    }

    /**
     * 获取文件处理进度百分比
     * @returns {number} 0-100之间的浮点数
     */
    getFileProcessingProgress() {
        if (!this.progressTracker) {
            return 0;
        }
        return this.progressTracker.getFileProgressPercentage();
    }

    /**
     * 获取详细的文件处理进度信息
     * @returns {Object} 包含详细进度信息的对象
     */
    getFileProcessingDetails() {
        if (!this.progressTracker) {
            return {
                totalFiles: 0,
                completedFiles: 0,
                processingFiles: 0,
                failedFiles: 0,
                pendingFiles: 0,
                progressPercentage: 0
            };
        }
        return this.progressTracker.getFileProgress();
    }

    // 添加关闭方法
    async shutdown() {
        try {
            if (this.vectorManager) {
                await this.vectorManager.shutdown();
            }
            if (this.sender) {
                await this.sender.shutdown();
            }
        } catch (error) {
            this.error('Error during shutdown:', error);
        }
    }

    /**
     * 清理并重新创建集合
     * 确保每次处理工作空间时都有一个干净的向量数据库集合
     */
    async _cleanAndRecreateCollection(userId, deviceId, workspacePath) {
        // 强制执行模式：如果VectorManager不存在，尝试创建一个
        if (!this.vectorManager) {
            this.log('VectorManager不存在，尝试强制初始化...');
            try {
                // 确保有基础配置
                if (!this.config.vectorManager) {
                    this.config.vectorManager = { enabled: true };
                }
                this.vectorManager = new VectorManager(this.config.vectorManager);
                await this.vectorManager.initialize();
                this.log('VectorManager强制初始化成功');
            } catch (error) {
                this.error('VectorManager强制初始化失败:', error);
                this.warn('跳过集合清理操作');
                return;
            }
        }
        
        if (!this.vectorManager.vectorDB) {
            this.warn('VectorDB not available for collection cleanup');
            return;
        }



        this.log('========== 开始清理和重新创建集合 ==========');
        
        // 生成集合标识符（与VectorManager保持一致）
        const crypto = __webpack_require__(8);
const { createCollectionName } = __webpack_require__(229);
        const workspaceHash = crypto
            .createHash('sha256')
            .update(workspacePath)
            .digest('hex')
            .substring(0, 16); // 取前16位
        // 使用统一的collection名称生成工具
        const collectionName = createCollectionName(userId, deviceId, workspacePath);
        const databaseName = this.config.vectorManager?.database?.query?.defaultDatabase || 'vectorservice-test';
        
        this.log(`集合标识: ${collectionName}`);
        this.log(`数据库名: ${databaseName}`);

        // 步骤1：删除现有集合（如果存在）
        this.log(`步骤1: 删除现有集合 ${collectionName}`);
        try {
            const deleteResult = await this.vectorManager.vectorDB.implementation.dropCollection(databaseName, collectionName);
            this.log('✅ 集合删除成功:', deleteResult);
        } catch (error) {
            // 如果集合不存在，这是正常的
            if (error.message.includes('not exist') || 
                error.message.includes('找不到') || 
                error.message.includes('does not exist') ||
                error.code === 'COLLECTION_NOT_FOUND' || 
                error.status === 404 ||
                error.response?.status === 404) {
                this.log('✅ 集合不存在，无需删除（这是正常的）');
            } else {
                this.warn('⚠️ 删除集合时出现错误:', {
                    message: error.message,
                    code: error.code,
                    status: error.status || error.response?.status
                });
                // 继续执行，不中断处理
            }
        }
        
        // 步骤2：等待确保删除操作完成
        this.log('步骤2: 等待删除操作完成...');
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        // 步骤3：创建新的干净集合
        this.log(`步骤3: 创建新集合 ${collectionName}`);
        try {
            const createResult = await this.vectorManager.vectorDB.implementation.createCollection(databaseName, collectionName, {
                description: `工作空间集合 - ${collectionName} - ${new Date().toISOString()}`,
                replicaNum: 0,  // 腾讯云要求必须为0
                shardNum: 1,
                indexes: [
                    // 主键索引
                    {
                        fieldName: "id",
                        fieldType: "string",
                        indexType: "primaryKey"
                    },
                    // 向量索引
                    {
                        fieldName: "vector",
                        fieldType: "vector",
                        indexType: "HNSW",
                        dimension: this.config.vectorManager?.database?.collections?.vectorDimension || 768,
                        metricType: this.config.vectorManager?.database?.collections?.metricType || "COSINE",
                        params: {
                            M: 16,
                            efConstruction: 200
                        }
                    },
                    // 元数据字段索引（用于过滤）
                    {
                        fieldName: "user_id",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "device_id",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "workspace_path",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "file_path",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "start_line",
                        fieldType: "uint64",
                        indexType: "filter"
                    },
                    {
                        fieldName: "end_line",
                        fieldType: "uint64",
                        indexType: "filter"
                    },
                    {
                        fieldName: "code",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "vector_model",
                        fieldType: "string",
                        indexType: "filter"
                    }
                ]
            });
            this.log('✅ 集合创建成功:', createResult);
        } catch (error) {
            this.error('❌ 创建集合失败:', {
                message: error.message,
                code: error.code,
                status: error.status,
                response: error.response?.data
            });
            throw error;
        }
        
        // 步骤4：验证集合已创建
        this.log('步骤4: 验证集合状态');
        try {
            const response = await this.vectorManager.vectorDB.implementation.listCollections(databaseName);
            const collections = response.data?.collections || [];
            
            this.log('验证集合列表:', collections.map(col => col.collectionName || col.collection || col.name));
            
            const collectionExists = collections.some(col => 
                col.collectionName === collectionName || 
                col.collection === collectionName ||
                col.name === collectionName
            );
            
            if (collectionExists) {
                this.log('✅ 集合创建验证成功，环境准备完毕');
            } else {
                this.warn('⚠️ 在集合列表中未找到目标集合，但这可能是正常的（延迟）');
            }
        } catch (error) {
            this.error('❌ 验证集合状态失败:', error.message);
            throw error;
        }
        
        this.log('========== 集合清理和重新创建完成 ==========');
    }
}

module.exports = CodeChunker;

/***/ }),
/* 11 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


module.exports = {
  // Export promiseified graceful-fs:
  ...__webpack_require__(12),
  // Export extra methods:
  ...__webpack_require__(22),
  ...__webpack_require__(31),
  ...__webpack_require__(33),
  ...__webpack_require__(39),
  ...__webpack_require__(24),
  ...__webpack_require__(46),
  ...__webpack_require__(44),
  ...__webpack_require__(27),
  ...__webpack_require__(32)
}


/***/ }),
/* 12 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// This is adapted from https://github.com/normalize/mz
// Copyright (c) 2014-2016 Jonathan Ong me@jongleberry.com and Contributors
const u = (__webpack_require__(13).fromCallback)
const fs = __webpack_require__(14)

const api = [
  'access',
  'appendFile',
  'chmod',
  'chown',
  'close',
  'copyFile',
  'cp',
  'fchmod',
  'fchown',
  'fdatasync',
  'fstat',
  'fsync',
  'ftruncate',
  'futimes',
  'glob',
  'lchmod',
  'lchown',
  'lutimes',
  'link',
  'lstat',
  'mkdir',
  'mkdtemp',
  'open',
  'opendir',
  'readdir',
  'readFile',
  'readlink',
  'realpath',
  'rename',
  'rm',
  'rmdir',
  'stat',
  'statfs',
  'symlink',
  'truncate',
  'unlink',
  'utimes',
  'writeFile'
].filter(key => {
  // Some commands are not available on some systems. Ex:
  // fs.cp was added in Node.js v16.7.0
  // fs.statfs was added in Node v19.6.0, v18.15.0
  // fs.glob was added in Node.js v22.0.0
  // fs.lchown is not available on at least some Linux
  return typeof fs[key] === 'function'
})

// Export cloned fs:
Object.assign(exports, fs)

// Universalify async methods:
api.forEach(method => {
  exports[method] = u(fs[method])
})

// We differ from mz/fs in that we still ship the old, broken, fs.exists()
// since we are a drop-in replacement for the native module
exports.exists = function (filename, callback) {
  if (typeof callback === 'function') {
    return fs.exists(filename, callback)
  }
  return new Promise(resolve => {
    return fs.exists(filename, resolve)
  })
}

// fs.read(), fs.write(), fs.readv(), & fs.writev() need special treatment due to multiple callback args

exports.read = function (fd, buffer, offset, length, position, callback) {
  if (typeof callback === 'function') {
    return fs.read(fd, buffer, offset, length, position, callback)
  }
  return new Promise((resolve, reject) => {
    fs.read(fd, buffer, offset, length, position, (err, bytesRead, buffer) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffer })
    })
  })
}

// Function signature can be
// fs.write(fd, buffer[, offset[, length[, position]]], callback)
// OR
// fs.write(fd, string[, position[, encoding]], callback)
// We need to handle both cases, so we use ...args
exports.write = function (fd, buffer, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.write(fd, buffer, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.write(fd, buffer, ...args, (err, bytesWritten, buffer) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffer })
    })
  })
}

// Function signature is
// s.readv(fd, buffers[, position], callback)
// We need to handle the optional arg, so we use ...args
exports.readv = function (fd, buffers, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.readv(fd, buffers, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.readv(fd, buffers, ...args, (err, bytesRead, buffers) => {
      if (err) return reject(err)
      resolve({ bytesRead, buffers })
    })
  })
}

// Function signature is
// s.writev(fd, buffers[, position], callback)
// We need to handle the optional arg, so we use ...args
exports.writev = function (fd, buffers, ...args) {
  if (typeof args[args.length - 1] === 'function') {
    return fs.writev(fd, buffers, ...args)
  }

  return new Promise((resolve, reject) => {
    fs.writev(fd, buffers, ...args, (err, bytesWritten, buffers) => {
      if (err) return reject(err)
      resolve({ bytesWritten, buffers })
    })
  })
}

// fs.realpath.native sometimes not available if fs is monkey-patched
if (typeof fs.realpath.native === 'function') {
  exports.realpath.native = u(fs.realpath.native)
} else {
  process.emitWarning(
    'fs.realpath.native is not a function. Is fs being monkey-patched?',
    'Warning', 'fs-extra-WARN0003'
  )
}


/***/ }),
/* 13 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


exports.fromCallback = function (fn) {
  return Object.defineProperty(function (...args) {
    if (typeof args[args.length - 1] === 'function') fn.apply(this, args)
    else {
      return new Promise((resolve, reject) => {
        args.push((err, res) => (err != null) ? reject(err) : resolve(res))
        fn.apply(this, args)
      })
    }
  }, 'name', { value: fn.name })
}

exports.fromPromise = function (fn) {
  return Object.defineProperty(function (...args) {
    const cb = args[args.length - 1]
    if (typeof cb !== 'function') return fn.apply(this, args)
    else {
      args.pop()
      fn.apply(this, args).then(r => cb(null, r), cb)
    }
  }, 'name', { value: fn.name })
}


/***/ }),
/* 14 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(5)
var polyfills = __webpack_require__(15)
var legacy = __webpack_require__(17)
var clone = __webpack_require__(19)

var util = __webpack_require__(20)

/* istanbul ignore next - node 0.x polyfill */
var gracefulQueue
var previousSymbol

/* istanbul ignore else - node 0.x polyfill */
if (typeof Symbol === 'function' && typeof Symbol.for === 'function') {
  gracefulQueue = Symbol.for('graceful-fs.queue')
  // This is used in testing by future versions
  previousSymbol = Symbol.for('graceful-fs.previous')
} else {
  gracefulQueue = '___graceful-fs.queue'
  previousSymbol = '___graceful-fs.previous'
}

function noop () {}

function publishQueue(context, queue) {
  Object.defineProperty(context, gracefulQueue, {
    get: function() {
      return queue
    }
  })
}

var debug = noop
if (util.debuglog)
  debug = util.debuglog('gfs4')
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ''))
  debug = function() {
    var m = util.format.apply(util, arguments)
    m = 'GFS4: ' + m.split(/\n/).join('\nGFS4: ')
    console.error(m)
  }

// Once time initialization
if (!fs[gracefulQueue]) {
  // This queue can be shared by multiple loaded instances
  var queue = global[gracefulQueue] || []
  publishQueue(fs, queue)

  // Patch fs.close/closeSync to shared queue version, because we need
  // to retry() whenever a close happens *anywhere* in the program.
  // This is essential when multiple graceful-fs instances are
  // in play at the same time.
  fs.close = (function (fs$close) {
    function close (fd, cb) {
      return fs$close.call(fs, fd, function (err) {
        // This function uses the graceful-fs shared queue
        if (!err) {
          resetQueue()
        }

        if (typeof cb === 'function')
          cb.apply(this, arguments)
      })
    }

    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    })
    return close
  })(fs.close)

  fs.closeSync = (function (fs$closeSync) {
    function closeSync (fd) {
      // This function uses the graceful-fs shared queue
      fs$closeSync.apply(fs, arguments)
      resetQueue()
    }

    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    })
    return closeSync
  })(fs.closeSync)

  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || '')) {
    process.on('exit', function() {
      debug(fs[gracefulQueue])
      __webpack_require__(21).equal(fs[gracefulQueue].length, 0)
    })
  }
}

if (!global[gracefulQueue]) {
  publishQueue(global, fs[gracefulQueue]);
}

module.exports = patch(clone(fs))
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs.__patched) {
    module.exports = patch(fs)
    fs.__patched = true;
}

function patch (fs) {
  // Everything that references the open() function needs to be in here
  polyfills(fs)
  fs.gracefulify = patch

  fs.createReadStream = createReadStream
  fs.createWriteStream = createWriteStream
  var fs$readFile = fs.readFile
  fs.readFile = readFile
  function readFile (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$readFile(path, options, cb)

    function go$readFile (path, options, cb, startTime) {
      return fs$readFile(path, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$readFile, [path, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$writeFile = fs.writeFile
  fs.writeFile = writeFile
  function writeFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$writeFile(path, data, options, cb)

    function go$writeFile (path, data, options, cb, startTime) {
      return fs$writeFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$writeFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$appendFile = fs.appendFile
  if (fs$appendFile)
    fs.appendFile = appendFile
  function appendFile (path, data, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    return go$appendFile(path, data, options, cb)

    function go$appendFile (path, data, options, cb, startTime) {
      return fs$appendFile(path, data, options, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$appendFile, [path, data, options, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$copyFile = fs.copyFile
  if (fs$copyFile)
    fs.copyFile = copyFile
  function copyFile (src, dest, flags, cb) {
    if (typeof flags === 'function') {
      cb = flags
      flags = 0
    }
    return go$copyFile(src, dest, flags, cb)

    function go$copyFile (src, dest, flags, cb, startTime) {
      return fs$copyFile(src, dest, flags, function (err) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$copyFile, [src, dest, flags, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  var fs$readdir = fs.readdir
  fs.readdir = readdir
  var noReaddirOptionVersions = /^v[0-5]\./
  function readdir (path, options, cb) {
    if (typeof options === 'function')
      cb = options, options = null

    var go$readdir = noReaddirOptionVersions.test(process.version)
      ? function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }
      : function go$readdir (path, options, cb, startTime) {
        return fs$readdir(path, options, fs$readdirCallback(
          path, options, cb, startTime
        ))
      }

    return go$readdir(path, options, cb)

    function fs$readdirCallback (path, options, cb, startTime) {
      return function (err, files) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([
            go$readdir,
            [path, options, cb],
            err,
            startTime || Date.now(),
            Date.now()
          ])
        else {
          if (files && files.sort)
            files.sort()

          if (typeof cb === 'function')
            cb.call(this, err, files)
        }
      }
    }
  }

  if (process.version.substr(0, 4) === 'v0.8') {
    var legStreams = legacy(fs)
    ReadStream = legStreams.ReadStream
    WriteStream = legStreams.WriteStream
  }

  var fs$ReadStream = fs.ReadStream
  if (fs$ReadStream) {
    ReadStream.prototype = Object.create(fs$ReadStream.prototype)
    ReadStream.prototype.open = ReadStream$open
  }

  var fs$WriteStream = fs.WriteStream
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype)
    WriteStream.prototype.open = WriteStream$open
  }

  Object.defineProperty(fs, 'ReadStream', {
    get: function () {
      return ReadStream
    },
    set: function (val) {
      ReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  Object.defineProperty(fs, 'WriteStream', {
    get: function () {
      return WriteStream
    },
    set: function (val) {
      WriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  // legacy names
  var FileReadStream = ReadStream
  Object.defineProperty(fs, 'FileReadStream', {
    get: function () {
      return FileReadStream
    },
    set: function (val) {
      FileReadStream = val
    },
    enumerable: true,
    configurable: true
  })
  var FileWriteStream = WriteStream
  Object.defineProperty(fs, 'FileWriteStream', {
    get: function () {
      return FileWriteStream
    },
    set: function (val) {
      FileWriteStream = val
    },
    enumerable: true,
    configurable: true
  })

  function ReadStream (path, options) {
    if (this instanceof ReadStream)
      return fs$ReadStream.apply(this, arguments), this
    else
      return ReadStream.apply(Object.create(ReadStream.prototype), arguments)
  }

  function ReadStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy()

        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
        that.read()
      }
    })
  }

  function WriteStream (path, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments)
  }

  function WriteStream$open () {
    var that = this
    open(that.path, that.flags, that.mode, function (err, fd) {
      if (err) {
        that.destroy()
        that.emit('error', err)
      } else {
        that.fd = fd
        that.emit('open', fd)
      }
    })
  }

  function createReadStream (path, options) {
    return new fs.ReadStream(path, options)
  }

  function createWriteStream (path, options) {
    return new fs.WriteStream(path, options)
  }

  var fs$open = fs.open
  fs.open = open
  function open (path, flags, mode, cb) {
    if (typeof mode === 'function')
      cb = mode, mode = null

    return go$open(path, flags, mode, cb)

    function go$open (path, flags, mode, cb, startTime) {
      return fs$open(path, flags, mode, function (err, fd) {
        if (err && (err.code === 'EMFILE' || err.code === 'ENFILE'))
          enqueue([go$open, [path, flags, mode, cb], err, startTime || Date.now(), Date.now()])
        else {
          if (typeof cb === 'function')
            cb.apply(this, arguments)
        }
      })
    }
  }

  return fs
}

function enqueue (elem) {
  debug('ENQUEUE', elem[0].name, elem[1])
  fs[gracefulQueue].push(elem)
  retry()
}

// keep track of the timeout between retry() calls
var retryTimer

// reset the startTime and lastTime to now
// this resets the start of the 60 second overall timeout as well as the
// delay between attempts so that we'll retry these jobs sooner
function resetQueue () {
  var now = Date.now()
  for (var i = 0; i < fs[gracefulQueue].length; ++i) {
    // entries that are only a length of 2 are from an older version, don't
    // bother modifying those since they'll be retried anyway.
    if (fs[gracefulQueue][i].length > 2) {
      fs[gracefulQueue][i][3] = now // startTime
      fs[gracefulQueue][i][4] = now // lastTime
    }
  }
  // call retry to make sure we're actively processing the queue
  retry()
}

function retry () {
  // clear the timer and remove it to help prevent unintended concurrency
  clearTimeout(retryTimer)
  retryTimer = undefined

  if (fs[gracefulQueue].length === 0)
    return

  var elem = fs[gracefulQueue].shift()
  var fn = elem[0]
  var args = elem[1]
  // these items may be unset if they were added by an older graceful-fs
  var err = elem[2]
  var startTime = elem[3]
  var lastTime = elem[4]

  // if we don't have a startTime we have no way of knowing if we've waited
  // long enough, so go ahead and retry this item now
  if (startTime === undefined) {
    debug('RETRY', fn.name, args)
    fn.apply(null, args)
  } else if (Date.now() - startTime >= 60000) {
    // it's been more than 60 seconds total, bail now
    debug('TIMEOUT', fn.name, args)
    var cb = args.pop()
    if (typeof cb === 'function')
      cb.call(null, err)
  } else {
    // the amount of time between the last attempt and right now
    var sinceAttempt = Date.now() - lastTime
    // the amount of time between when we first tried, and when we last tried
    // rounded up to at least 1
    var sinceStart = Math.max(lastTime - startTime, 1)
    // backoff. wait longer than the total time we've been retrying, but only
    // up to a maximum of 100ms
    var desiredDelay = Math.min(sinceStart * 1.2, 100)
    // it's been long enough since the last retry, do it again
    if (sinceAttempt >= desiredDelay) {
      debug('RETRY', fn.name, args)
      fn.apply(null, args.concat([startTime]))
    } else {
      // if we can't do this job yet, push it to the end of the queue
      // and let the next iteration check again
      fs[gracefulQueue].push(elem)
    }
  }

  // schedule our next run if one isn't already scheduled
  if (retryTimer === undefined) {
    retryTimer = setTimeout(retry, 0)
  }
}


/***/ }),
/* 15 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var constants = __webpack_require__(16)

var origCwd = process.cwd
var cwd = null

var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform

process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process)
  return cwd
}
try {
  process.cwd()
} catch (er) {}

// This check is needed until node.js 12 is required
if (typeof process.chdir === 'function') {
  var chdir = process.chdir
  process.chdir = function (d) {
    cwd = null
    chdir.call(process, d)
  }
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir)
}

module.exports = patch

function patch (fs) {
  // (re-)implement some things that are known busted or missing.

  // lchmod, broken prior to 0.6.2
  // back-port the fix here.
  if (constants.hasOwnProperty('O_SYMLINK') &&
      process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs)
  }

  // lutimes implementation, or no-op
  if (!fs.lutimes) {
    patchLutimes(fs)
  }

  // https://github.com/isaacs/node-graceful-fs/issues/4
  // Chown should not fail on einval or eperm if non-root.
  // It should not fail on enosys ever, as this just indicates
  // that a fs doesn't support the intended operation.

  fs.chown = chownFix(fs.chown)
  fs.fchown = chownFix(fs.fchown)
  fs.lchown = chownFix(fs.lchown)

  fs.chmod = chmodFix(fs.chmod)
  fs.fchmod = chmodFix(fs.fchmod)
  fs.lchmod = chmodFix(fs.lchmod)

  fs.chownSync = chownFixSync(fs.chownSync)
  fs.fchownSync = chownFixSync(fs.fchownSync)
  fs.lchownSync = chownFixSync(fs.lchownSync)

  fs.chmodSync = chmodFixSync(fs.chmodSync)
  fs.fchmodSync = chmodFixSync(fs.fchmodSync)
  fs.lchmodSync = chmodFixSync(fs.lchmodSync)

  fs.stat = statFix(fs.stat)
  fs.fstat = statFix(fs.fstat)
  fs.lstat = statFix(fs.lstat)

  fs.statSync = statFixSync(fs.statSync)
  fs.fstatSync = statFixSync(fs.fstatSync)
  fs.lstatSync = statFixSync(fs.lstatSync)

  // if lchmod/lchown do not exist, then make them no-ops
  if (fs.chmod && !fs.lchmod) {
    fs.lchmod = function (path, mode, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchmodSync = function () {}
  }
  if (fs.chown && !fs.lchown) {
    fs.lchown = function (path, uid, gid, cb) {
      if (cb) process.nextTick(cb)
    }
    fs.lchownSync = function () {}
  }

  // on Windows, A/V software can lock the directory, causing this
  // to fail with an EACCES or EPERM if the directory contains newly
  // created files.  Try again on failure, for up to 60 seconds.

  // Set the timeout this long because some Windows Anti-Virus, such as Parity
  // bit9, may lock files for up to a minute, causing npm package install
  // failures. Also, take care to yield the scheduler. Windows scheduling gives
  // CPU to a busy looping process, which can cause the program causing the lock
  // contention to be starved of CPU by node, so the contention doesn't resolve.
  if (platform === "win32") {
    fs.rename = typeof fs.rename !== 'function' ? fs.rename
    : (function (fs$rename) {
      function rename (from, to, cb) {
        var start = Date.now()
        var backoff = 0;
        fs$rename(from, to, function CB (er) {
          if (er
              && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY")
              && Date.now() - start < 60000) {
            setTimeout(function() {
              fs.stat(to, function (stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from, to, CB);
                else
                  cb(er)
              })
            }, backoff)
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb) cb(er)
        })
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename, fs$rename)
      return rename
    })(fs.rename)
  }

  // if read() returns EAGAIN, then just try it again.
  fs.read = typeof fs.read !== 'function' ? fs.read
  : (function (fs$read) {
    function read (fd, buffer, offset, length, position, callback_) {
      var callback
      if (callback_ && typeof callback_ === 'function') {
        var eagCounter = 0
        callback = function (er, _, __) {
          if (er && er.code === 'EAGAIN' && eagCounter < 10) {
            eagCounter ++
            return fs$read.call(fs, fd, buffer, offset, length, position, callback)
          }
          callback_.apply(this, arguments)
        }
      }
      return fs$read.call(fs, fd, buffer, offset, length, position, callback)
    }

    // This ensures `util.promisify` works as it does for native `fs.read`.
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read)
    return read
  })(fs.read)

  fs.readSync = typeof fs.readSync !== 'function' ? fs.readSync
  : (function (fs$readSync) { return function (fd, buffer, offset, length, position) {
    var eagCounter = 0
    while (true) {
      try {
        return fs$readSync.call(fs, fd, buffer, offset, length, position)
      } catch (er) {
        if (er.code === 'EAGAIN' && eagCounter < 10) {
          eagCounter ++
          continue
        }
        throw er
      }
    }
  }})(fs.readSync)

  function patchLchmod (fs) {
    fs.lchmod = function (path, mode, callback) {
      fs.open( path
             , constants.O_WRONLY | constants.O_SYMLINK
             , mode
             , function (err, fd) {
        if (err) {
          if (callback) callback(err)
          return
        }
        // prefer to return the chmod error, if one occurs,
        // but still try to close, and report closing errors if they occur.
        fs.fchmod(fd, mode, function (err) {
          fs.close(fd, function(err2) {
            if (callback) callback(err || err2)
          })
        })
      })
    }

    fs.lchmodSync = function (path, mode) {
      var fd = fs.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode)

      // prefer to return the chmod error, if one occurs,
      // but still try to close, and report closing errors if they occur.
      var threw = true
      var ret
      try {
        ret = fs.fchmodSync(fd, mode)
        threw = false
      } finally {
        if (threw) {
          try {
            fs.closeSync(fd)
          } catch (er) {}
        } else {
          fs.closeSync(fd)
        }
      }
      return ret
    }
  }

  function patchLutimes (fs) {
    if (constants.hasOwnProperty("O_SYMLINK") && fs.futimes) {
      fs.lutimes = function (path, at, mt, cb) {
        fs.open(path, constants.O_SYMLINK, function (er, fd) {
          if (er) {
            if (cb) cb(er)
            return
          }
          fs.futimes(fd, at, mt, function (er) {
            fs.close(fd, function (er2) {
              if (cb) cb(er || er2)
            })
          })
        })
      }

      fs.lutimesSync = function (path, at, mt) {
        var fd = fs.openSync(path, constants.O_SYMLINK)
        var ret
        var threw = true
        try {
          ret = fs.futimesSync(fd, at, mt)
          threw = false
        } finally {
          if (threw) {
            try {
              fs.closeSync(fd)
            } catch (er) {}
          } else {
            fs.closeSync(fd)
          }
        }
        return ret
      }

    } else if (fs.futimes) {
      fs.lutimes = function (_a, _b, _c, cb) { if (cb) process.nextTick(cb) }
      fs.lutimesSync = function () {}
    }
  }

  function chmodFix (orig) {
    if (!orig) return orig
    return function (target, mode, cb) {
      return orig.call(fs, target, mode, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chmodFixSync (orig) {
    if (!orig) return orig
    return function (target, mode) {
      try {
        return orig.call(fs, target, mode)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }


  function chownFix (orig) {
    if (!orig) return orig
    return function (target, uid, gid, cb) {
      return orig.call(fs, target, uid, gid, function (er) {
        if (chownErOk(er)) er = null
        if (cb) cb.apply(this, arguments)
      })
    }
  }

  function chownFixSync (orig) {
    if (!orig) return orig
    return function (target, uid, gid) {
      try {
        return orig.call(fs, target, uid, gid)
      } catch (er) {
        if (!chownErOk(er)) throw er
      }
    }
  }

  function statFix (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options, cb) {
      if (typeof options === 'function') {
        cb = options
        options = null
      }
      function callback (er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 0x100000000
          if (stats.gid < 0) stats.gid += 0x100000000
        }
        if (cb) cb.apply(this, arguments)
      }
      return options ? orig.call(fs, target, options, callback)
        : orig.call(fs, target, callback)
    }
  }

  function statFixSync (orig) {
    if (!orig) return orig
    // Older versions of Node erroneously returned signed integers for
    // uid + gid.
    return function (target, options) {
      var stats = options ? orig.call(fs, target, options)
        : orig.call(fs, target)
      if (stats) {
        if (stats.uid < 0) stats.uid += 0x100000000
        if (stats.gid < 0) stats.gid += 0x100000000
      }
      return stats;
    }
  }

  // ENOSYS means that the fs doesn't support the op. Just ignore
  // that, because it doesn't matter.
  //
  // if there's no getuid, or if getuid() is something other
  // than 0, and the error is EINVAL or EPERM, then just ignore
  // it.
  //
  // This specific case is a silent failure in cp, install, tar,
  // and most other unix tools that manage permissions.
  //
  // When running as root, or if other types of errors are
  // encountered, then it's strict.
  function chownErOk (er) {
    if (!er)
      return true

    if (er.code === "ENOSYS")
      return true

    var nonroot = !process.getuid || process.getuid() !== 0
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true
    }

    return false
  }
}


/***/ }),
/* 16 */
/***/ ((module) => {

"use strict";
module.exports = require("constants");

/***/ }),
/* 17 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(18).Stream)

module.exports = legacy

function legacy (fs) {
  return {
    ReadStream: ReadStream,
    WriteStream: WriteStream
  }

  function ReadStream (path, options) {
    if (!(this instanceof ReadStream)) return new ReadStream(path, options);

    Stream.call(this);

    var self = this;

    this.path = path;
    this.fd = null;
    this.readable = true;
    this.paused = false;

    this.flags = 'r';
    this.mode = 438; /*=0666*/
    this.bufferSize = 64 * 1024;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.encoding) this.setEncoding(this.encoding);

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.end === undefined) {
        this.end = Infinity;
      } else if ('number' !== typeof this.end) {
        throw TypeError('end must be a Number');
      }

      if (this.start > this.end) {
        throw new Error('start must be <= end');
      }

      this.pos = this.start;
    }

    if (this.fd !== null) {
      process.nextTick(function() {
        self._read();
      });
      return;
    }

    fs.open(this.path, this.flags, this.mode, function (err, fd) {
      if (err) {
        self.emit('error', err);
        self.readable = false;
        return;
      }

      self.fd = fd;
      self.emit('open', fd);
      self._read();
    })
  }

  function WriteStream (path, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path, options);

    Stream.call(this);

    this.path = path;
    this.fd = null;
    this.writable = true;

    this.flags = 'w';
    this.encoding = 'binary';
    this.mode = 438; /*=0666*/
    this.bytesWritten = 0;

    options = options || {};

    // Mixin options into this
    var keys = Object.keys(options);
    for (var index = 0, length = keys.length; index < length; index++) {
      var key = keys[index];
      this[key] = options[key];
    }

    if (this.start !== undefined) {
      if ('number' !== typeof this.start) {
        throw TypeError('start must be a Number');
      }
      if (this.start < 0) {
        throw new Error('start must be >= zero');
      }

      this.pos = this.start;
    }

    this.busy = false;
    this._queue = [];

    if (this.fd === null) {
      this._open = fs.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, undefined]);
      this.flush();
    }
  }
}


/***/ }),
/* 18 */
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),
/* 19 */
/***/ ((module) => {

"use strict";


module.exports = clone

var getPrototypeOf = Object.getPrototypeOf || function (obj) {
  return obj.__proto__
}

function clone (obj) {
  if (obj === null || typeof obj !== 'object')
    return obj

  if (obj instanceof Object)
    var copy = { __proto__: getPrototypeOf(obj) }
  else
    var copy = Object.create(null)

  Object.getOwnPropertyNames(obj).forEach(function (key) {
    Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key))
  })

  return copy
}


/***/ }),
/* 20 */
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),
/* 21 */
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),
/* 22 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
module.exports = {
  copy: u(__webpack_require__(23)),
  copySync: __webpack_require__(30)
}


/***/ }),
/* 23 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const { mkdirs } = __webpack_require__(24)
const { pathExists } = __webpack_require__(27)
const { utimesMillis } = __webpack_require__(28)
const stat = __webpack_require__(29)

async function copy (src, dest, opts = {}) {
  if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    process.emitWarning(
      'Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' +
      '\tsee https://github.com/jprichardson/node-fs-extra/issues/269',
      'Warning', 'fs-extra-WARN0001'
    )
  }

  const { srcStat, destStat } = await stat.checkPaths(src, dest, 'copy', opts)

  await stat.checkParentPaths(src, srcStat, dest, 'copy')

  const include = await runFilter(src, dest, opts)

  if (!include) return

  // check if the parent of dest exists, and create it if it doesn't exist
  const destParent = path.dirname(dest)
  const dirExists = await pathExists(destParent)
  if (!dirExists) {
    await mkdirs(destParent)
  }

  await getStatsAndPerformCopy(destStat, src, dest, opts)
}

async function runFilter (src, dest, opts) {
  if (!opts.filter) return true
  return opts.filter(src, dest)
}

async function getStatsAndPerformCopy (destStat, src, dest, opts) {
  const statFn = opts.dereference ? fs.stat : fs.lstat
  const srcStat = await statFn(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)

  if (
    srcStat.isFile() ||
    srcStat.isCharacterDevice() ||
    srcStat.isBlockDevice()
  ) return onFile(srcStat, destStat, src, dest, opts)

  if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)
  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)
  throw new Error(`Unknown file: ${src}`)
}

async function onFile (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts)

  if (opts.overwrite) {
    await fs.unlink(dest)
    return copyFile(srcStat, src, dest, opts)
  }
  if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

async function copyFile (srcStat, src, dest, opts) {
  await fs.copyFile(src, dest)
  if (opts.preserveTimestamps) {
    // Make sure the file is writable before setting the timestamp
    // otherwise open fails with EPERM when invoked with 'r+'
    // (through utimes call)
    if (fileIsNotWritable(srcStat.mode)) {
      await makeFileWritable(dest, srcStat.mode)
    }

    // Set timestamps and mode correspondingly

    // Note that The initial srcStat.atime cannot be trusted
    // because it is modified by the read(2) system call
    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
    const updatedSrcStat = await fs.stat(src)
    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
  }

  return fs.chmod(dest, srcStat.mode)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode) {
  return fs.chmod(dest, srcMode | 0o200)
}

async function onDir (srcStat, destStat, src, dest, opts) {
  // the dest directory might not exist, create it
  if (!destStat) {
    await fs.mkdir(dest)
  }

  const promises = []

  // loop through the files in the current directory to copy everything
  for await (const item of await fs.opendir(src)) {
    const srcItem = path.join(src, item.name)
    const destItem = path.join(dest, item.name)

    promises.push(
      runFilter(srcItem, destItem, opts).then(include => {
        if (include) {
          // only copy the item if it matches the filter function
          return stat.checkPaths(srcItem, destItem, 'copy', opts).then(({ destStat }) => {
            // If the item is a copyable file, `getStatsAndPerformCopy` will copy it
            // If the item is a directory, `getStatsAndPerformCopy` will call `onDir` recursively
            return getStatsAndPerformCopy(destStat, srcItem, destItem, opts)
          })
        }
      })
    )
  }

  await Promise.all(promises)

  if (!destStat) {
    await fs.chmod(dest, srcStat.mode)
  }
}

async function onLink (destStat, src, dest, opts) {
  let resolvedSrc = await fs.readlink(src)
  if (opts.dereference) {
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
  }
  if (!destStat) {
    return fs.symlink(resolvedSrc, dest)
  }

  let resolvedDest = null
  try {
    resolvedDest = await fs.readlink(dest)
  } catch (e) {
    // dest exists and is a regular file or directory,
    // Windows may throw UNKNOWN error. If dest already exists,
    // fs throws error anyway, so no need to guard against it here.
    if (e.code === 'EINVAL' || e.code === 'UNKNOWN') return fs.symlink(resolvedSrc, dest)
    throw e
  }
  if (opts.dereference) {
    resolvedDest = path.resolve(process.cwd(), resolvedDest)
  }
  if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
  }

  // do not copy if src is a subdir of dest since unlinking
  // dest in this case would result in removing src contents
  // and therefore a broken symlink would be created.
  if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
  }

  // copy the link
  await fs.unlink(dest)
  return fs.symlink(resolvedSrc, dest)
}

module.exports = copy


/***/ }),
/* 24 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = (__webpack_require__(13).fromPromise)
const { makeDir: _makeDir, makeDirSync } = __webpack_require__(25)
const makeDir = u(_makeDir)

module.exports = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
}


/***/ }),
/* 25 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const fs = __webpack_require__(12)
const { checkPath } = __webpack_require__(26)

const getMode = options => {
  const defaults = { mode: 0o777 }
  if (typeof options === 'number') return options
  return ({ ...defaults, ...options }).mode
}

module.exports.makeDir = async (dir, options) => {
  checkPath(dir)

  return fs.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  })
}

module.exports.makeDirSync = (dir, options) => {
  checkPath(dir)

  return fs.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  })
}


/***/ }),
/* 26 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Adapted from https://github.com/sindresorhus/make-dir
// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (sindresorhus.com)
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
// The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

const path = __webpack_require__(4)

// https://github.com/nodejs/node/issues/8987
// https://github.com/libuv/libuv/pull/1088
module.exports.checkPath = function checkPath (pth) {
  if (process.platform === 'win32') {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ''))

    if (pathHasInvalidWinCharacters) {
      const error = new Error(`Path contains invalid characters: ${pth}`)
      error.code = 'EINVAL'
      throw error
    }
  }
}


/***/ }),
/* 27 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const u = (__webpack_require__(13).fromPromise)
const fs = __webpack_require__(12)

function pathExists (path) {
  return fs.access(path).then(() => true).catch(() => false)
}

module.exports = {
  pathExists: u(pathExists),
  pathExistsSync: fs.existsSync
}


/***/ }),
/* 28 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const u = (__webpack_require__(13).fromPromise)

async function utimesMillis (path, atime, mtime) {
  // if (!HAS_MILLIS_RES) return fs.utimes(path, atime, mtime, callback)
  const fd = await fs.open(path, 'r+')

  let closeErr = null

  try {
    await fs.futimes(fd, atime, mtime)
  } finally {
    try {
      await fs.close(fd)
    } catch (e) {
      closeErr = e
    }
  }

  if (closeErr) {
    throw closeErr
  }
}

function utimesMillisSync (path, atime, mtime) {
  const fd = fs.openSync(path, 'r+')
  fs.futimesSync(fd, atime, mtime)
  return fs.closeSync(fd)
}

module.exports = {
  utimesMillis: u(utimesMillis),
  utimesMillisSync
}


/***/ }),
/* 29 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const u = (__webpack_require__(13).fromPromise)

function getStats (src, dest, opts) {
  const statFunc = opts.dereference
    ? (file) => fs.stat(file, { bigint: true })
    : (file) => fs.lstat(file, { bigint: true })
  return Promise.all([
    statFunc(src),
    statFunc(dest).catch(err => {
      if (err.code === 'ENOENT') return null
      throw err
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }))
}

function getStatsSync (src, dest, opts) {
  let destStat
  const statFunc = opts.dereference
    ? (file) => fs.statSync(file, { bigint: true })
    : (file) => fs.lstatSync(file, { bigint: true })
  const srcStat = statFunc(src)
  try {
    destStat = statFunc(dest)
  } catch (err) {
    if (err.code === 'ENOENT') return { srcStat, destStat: null }
    throw err
  }
  return { srcStat, destStat }
}

async function checkPaths (src, dest, funcName, opts) {
  const { srcStat, destStat } = await getStats(src, dest, opts)
  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      const srcBaseName = path.basename(src)
      const destBaseName = path.basename(dest)
      if (funcName === 'move' &&
        srcBaseName !== destBaseName &&
        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true }
      }
      throw new Error('Source and destination must not be the same.')
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }

  return { srcStat, destStat }
}

function checkPathsSync (src, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src, dest, opts)

  if (destStat) {
    if (areIdentical(srcStat, destStat)) {
      const srcBaseName = path.basename(src)
      const destBaseName = path.basename(dest)
      if (funcName === 'move' &&
        srcBaseName !== destBaseName &&
        srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true }
      }
      throw new Error('Source and destination must not be the same.')
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`)
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`)
    }
  }

  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return { srcStat, destStat }
}

// recursively check if dest parent is a subdirectory of src.
// It works for all file types including symlinks since it
// checks the src and dest inodes. It starts from the deepest
// parent and stops once it reaches the src parent or the root path.
async function checkParentPaths (src, srcStat, dest, funcName) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return

  let destStat
  try {
    destStat = await fs.stat(destParent, { bigint: true })
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }

  if (areIdentical(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  }

  return checkParentPaths(src, srcStat, destParent, funcName)
}

function checkParentPathsSync (src, srcStat, dest, funcName) {
  const srcParent = path.resolve(path.dirname(src))
  const destParent = path.resolve(path.dirname(dest))
  if (destParent === srcParent || destParent === path.parse(destParent).root) return
  let destStat
  try {
    destStat = fs.statSync(destParent, { bigint: true })
  } catch (err) {
    if (err.code === 'ENOENT') return
    throw err
  }
  if (areIdentical(srcStat, destStat)) {
    throw new Error(errMsg(src, dest, funcName))
  }
  return checkParentPathsSync(src, srcStat, destParent, funcName)
}

function areIdentical (srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev
}

// return true if dest is a subdir of src, otherwise false.
// It only checks the path strings.
function isSrcSubdir (src, dest) {
  const srcArr = path.resolve(src).split(path.sep).filter(i => i)
  const destArr = path.resolve(dest).split(path.sep).filter(i => i)
  return srcArr.every((cur, i) => destArr[i] === cur)
}

function errMsg (src, dest, funcName) {
  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`
}

module.exports = {
  // checkPaths
  checkPaths: u(checkPaths),
  checkPathsSync,
  // checkParent
  checkParentPaths: u(checkParentPaths),
  checkParentPathsSync,
  // Misc
  isSrcSubdir,
  areIdentical
}


/***/ }),
/* 30 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(14)
const path = __webpack_require__(4)
const mkdirsSync = (__webpack_require__(24).mkdirsSync)
const utimesMillisSync = (__webpack_require__(28).utimesMillisSync)
const stat = __webpack_require__(29)

function copySync (src, dest, opts) {
  if (typeof opts === 'function') {
    opts = { filter: opts }
  }

  opts = opts || {}
  opts.clobber = 'clobber' in opts ? !!opts.clobber : true // default to true for now
  opts.overwrite = 'overwrite' in opts ? !!opts.overwrite : opts.clobber // overwrite falls back to clobber

  // Warn about using preserveTimestamps on 32-bit node
  if (opts.preserveTimestamps && process.arch === 'ia32') {
    process.emitWarning(
      'Using the preserveTimestamps option in 32-bit node is not recommended;\n\n' +
      '\tsee https://github.com/jprichardson/node-fs-extra/issues/269',
      'Warning', 'fs-extra-WARN0002'
    )
  }

  const { srcStat, destStat } = stat.checkPathsSync(src, dest, 'copy', opts)
  stat.checkParentPathsSync(src, srcStat, dest, 'copy')
  if (opts.filter && !opts.filter(src, dest)) return
  const destParent = path.dirname(dest)
  if (!fs.existsSync(destParent)) mkdirsSync(destParent)
  return getStats(destStat, src, dest, opts)
}

function getStats (destStat, src, dest, opts) {
  const statSync = opts.dereference ? fs.statSync : fs.lstatSync
  const srcStat = statSync(src)

  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src, dest, opts)
  else if (srcStat.isFile() ||
           srcStat.isCharacterDevice() ||
           srcStat.isBlockDevice()) return onFile(srcStat, destStat, src, dest, opts)
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src, dest, opts)
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src}`)
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src}`)
  throw new Error(`Unknown file: ${src}`)
}

function onFile (srcStat, destStat, src, dest, opts) {
  if (!destStat) return copyFile(srcStat, src, dest, opts)
  return mayCopyFile(srcStat, src, dest, opts)
}

function mayCopyFile (srcStat, src, dest, opts) {
  if (opts.overwrite) {
    fs.unlinkSync(dest)
    return copyFile(srcStat, src, dest, opts)
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`)
  }
}

function copyFile (srcStat, src, dest, opts) {
  fs.copyFileSync(src, dest)
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src, dest)
  return setDestMode(dest, srcStat.mode)
}

function handleTimestamps (srcMode, src, dest) {
  // Make sure the file is writable before setting the timestamp
  // otherwise open fails with EPERM when invoked with 'r+'
  // (through utimes call)
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode)
  return setDestTimestamps(src, dest)
}

function fileIsNotWritable (srcMode) {
  return (srcMode & 0o200) === 0
}

function makeFileWritable (dest, srcMode) {
  return setDestMode(dest, srcMode | 0o200)
}

function setDestMode (dest, srcMode) {
  return fs.chmodSync(dest, srcMode)
}

function setDestTimestamps (src, dest) {
  // The initial srcStat.atime cannot be trusted
  // because it is modified by the read(2) system call
  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)
  const updatedSrcStat = fs.statSync(src)
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime)
}

function onDir (srcStat, destStat, src, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src, dest, opts)
  return copyDir(src, dest, opts)
}

function mkDirAndCopy (srcMode, src, dest, opts) {
  fs.mkdirSync(dest)
  copyDir(src, dest, opts)
  return setDestMode(dest, srcMode)
}

function copyDir (src, dest, opts) {
  const dir = fs.opendirSync(src)

  try {
    let dirent

    while ((dirent = dir.readSync()) !== null) {
      copyDirItem(dirent.name, src, dest, opts)
    }
  } finally {
    dir.closeSync()
  }
}

function copyDirItem (item, src, dest, opts) {
  const srcItem = path.join(src, item)
  const destItem = path.join(dest, item)
  if (opts.filter && !opts.filter(srcItem, destItem)) return
  const { destStat } = stat.checkPathsSync(srcItem, destItem, 'copy', opts)
  return getStats(destStat, srcItem, destItem, opts)
}

function onLink (destStat, src, dest, opts) {
  let resolvedSrc = fs.readlinkSync(src)
  if (opts.dereference) {
    resolvedSrc = path.resolve(process.cwd(), resolvedSrc)
  }

  if (!destStat) {
    return fs.symlinkSync(resolvedSrc, dest)
  } else {
    let resolvedDest
    try {
      resolvedDest = fs.readlinkSync(dest)
    } catch (err) {
      // dest exists and is a regular file or directory,
      // Windows may throw UNKNOWN error. If dest already exists,
      // fs throws error anyway, so no need to guard against it here.
      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') return fs.symlinkSync(resolvedSrc, dest)
      throw err
    }
    if (opts.dereference) {
      resolvedDest = path.resolve(process.cwd(), resolvedDest)
    }
    if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`)
    }

    // prevent copy if src is a subdir of dest since unlinking
    // dest in this case would result in removing src contents
    // and therefore a broken symlink would be created.
    if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`)
    }
    return copyLink(resolvedSrc, dest)
  }
}

function copyLink (resolvedSrc, dest) {
  fs.unlinkSync(dest)
  return fs.symlinkSync(resolvedSrc, dest)
}

module.exports = copySync


/***/ }),
/* 31 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const mkdir = __webpack_require__(24)
const remove = __webpack_require__(32)

const emptyDir = u(async function emptyDir (dir) {
  let items
  try {
    items = await fs.readdir(dir)
  } catch {
    return mkdir.mkdirs(dir)
  }

  return Promise.all(items.map(item => remove.remove(path.join(dir, item))))
})

function emptyDirSync (dir) {
  let items
  try {
    items = fs.readdirSync(dir)
  } catch {
    return mkdir.mkdirsSync(dir)
  }

  items.forEach(item => {
    item = path.join(dir, item)
    remove.removeSync(item)
  })
}

module.exports = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
}


/***/ }),
/* 32 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(14)
const u = (__webpack_require__(13).fromCallback)

function remove (path, callback) {
  fs.rm(path, { recursive: true, force: true }, callback)
}

function removeSync (path) {
  fs.rmSync(path, { recursive: true, force: true })
}

module.exports = {
  remove: u(remove),
  removeSync
}


/***/ }),
/* 33 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { createFile, createFileSync } = __webpack_require__(34)
const { createLink, createLinkSync } = __webpack_require__(35)
const { createSymlink, createSymlinkSync } = __webpack_require__(36)

module.exports = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
}


/***/ }),
/* 34 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const path = __webpack_require__(4)
const fs = __webpack_require__(12)
const mkdir = __webpack_require__(24)

async function createFile (file) {
  let stats
  try {
    stats = await fs.stat(file)
  } catch { }
  if (stats && stats.isFile()) return

  const dir = path.dirname(file)

  let dirStats = null
  try {
    dirStats = await fs.stat(dir)
  } catch (err) {
    // if the directory doesn't exist, make it
    if (err.code === 'ENOENT') {
      await mkdir.mkdirs(dir)
      await fs.writeFile(file, '')
      return
    } else {
      throw err
    }
  }

  if (dirStats.isDirectory()) {
    await fs.writeFile(file, '')
  } else {
    // parent is not a directory
    // This is just to cause an internal ENOTDIR error to be thrown
    await fs.readdir(dir)
  }
}

function createFileSync (file) {
  let stats
  try {
    stats = fs.statSync(file)
  } catch { }
  if (stats && stats.isFile()) return

  const dir = path.dirname(file)
  try {
    if (!fs.statSync(dir).isDirectory()) {
      // parent is not a directory
      // This is just to cause an internal ENOTDIR error to be thrown
      fs.readdirSync(dir)
    }
  } catch (err) {
    // If the stat call above failed because the directory doesn't exist, create it
    if (err && err.code === 'ENOENT') mkdir.mkdirsSync(dir)
    else throw err
  }

  fs.writeFileSync(file, '')
}

module.exports = {
  createFile: u(createFile),
  createFileSync
}


/***/ }),
/* 35 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const path = __webpack_require__(4)
const fs = __webpack_require__(12)
const mkdir = __webpack_require__(24)
const { pathExists } = __webpack_require__(27)
const { areIdentical } = __webpack_require__(29)

async function createLink (srcpath, dstpath) {
  let dstStat
  try {
    dstStat = await fs.lstat(dstpath)
  } catch {
    // ignore error
  }

  let srcStat
  try {
    srcStat = await fs.lstat(srcpath)
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink')
    throw err
  }

  if (dstStat && areIdentical(srcStat, dstStat)) return

  const dir = path.dirname(dstpath)

  const dirExists = await pathExists(dir)

  if (!dirExists) {
    await mkdir.mkdirs(dir)
  }

  await fs.link(srcpath, dstpath)
}

function createLinkSync (srcpath, dstpath) {
  let dstStat
  try {
    dstStat = fs.lstatSync(dstpath)
  } catch {}

  try {
    const srcStat = fs.lstatSync(srcpath)
    if (dstStat && areIdentical(srcStat, dstStat)) return
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureLink')
    throw err
  }

  const dir = path.dirname(dstpath)
  const dirExists = fs.existsSync(dir)
  if (dirExists) return fs.linkSync(srcpath, dstpath)
  mkdir.mkdirsSync(dir)

  return fs.linkSync(srcpath, dstpath)
}

module.exports = {
  createLink: u(createLink),
  createLinkSync
}


/***/ }),
/* 36 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const path = __webpack_require__(4)
const fs = __webpack_require__(12)

const { mkdirs, mkdirsSync } = __webpack_require__(24)

const { symlinkPaths, symlinkPathsSync } = __webpack_require__(37)
const { symlinkType, symlinkTypeSync } = __webpack_require__(38)

const { pathExists } = __webpack_require__(27)

const { areIdentical } = __webpack_require__(29)

async function createSymlink (srcpath, dstpath, type) {
  let stats
  try {
    stats = await fs.lstat(dstpath)
  } catch { }

  if (stats && stats.isSymbolicLink()) {
    const [srcStat, dstStat] = await Promise.all([
      fs.stat(srcpath),
      fs.stat(dstpath)
    ])

    if (areIdentical(srcStat, dstStat)) return
  }

  const relative = await symlinkPaths(srcpath, dstpath)
  srcpath = relative.toDst
  const toType = await symlinkType(relative.toCwd, type)
  const dir = path.dirname(dstpath)

  if (!(await pathExists(dir))) {
    await mkdirs(dir)
  }

  return fs.symlink(srcpath, dstpath, toType)
}

function createSymlinkSync (srcpath, dstpath, type) {
  let stats
  try {
    stats = fs.lstatSync(dstpath)
  } catch { }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs.statSync(srcpath)
    const dstStat = fs.statSync(dstpath)
    if (areIdentical(srcStat, dstStat)) return
  }

  const relative = symlinkPathsSync(srcpath, dstpath)
  srcpath = relative.toDst
  type = symlinkTypeSync(relative.toCwd, type)
  const dir = path.dirname(dstpath)
  const exists = fs.existsSync(dir)
  if (exists) return fs.symlinkSync(srcpath, dstpath, type)
  mkdirsSync(dir)
  return fs.symlinkSync(srcpath, dstpath, type)
}

module.exports = {
  createSymlink: u(createSymlink),
  createSymlinkSync
}


/***/ }),
/* 37 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const path = __webpack_require__(4)
const fs = __webpack_require__(12)
const { pathExists } = __webpack_require__(27)

const u = (__webpack_require__(13).fromPromise)

/**
 * Function that returns two types of paths, one relative to symlink, and one
 * relative to the current working directory. Checks if path is absolute or
 * relative. If the path is relative, this function checks if the path is
 * relative to symlink or relative to current working directory. This is an
 * initiative to find a smarter `srcpath` to supply when building symlinks.
 * This allows you to determine which path to use out of one of three possible
 * types of source paths. The first is an absolute path. This is detected by
 * `path.isAbsolute()`. When an absolute path is provided, it is checked to
 * see if it exists. If it does it's used, if not an error is returned
 * (callback)/ thrown (sync). The other two options for `srcpath` are a
 * relative url. By default Node's `fs.symlink` works by creating a symlink
 * using `dstpath` and expects the `srcpath` to be relative to the newly
 * created symlink. If you provide a `srcpath` that does not exist on the file
 * system it results in a broken symlink. To minimize this, the function
 * checks to see if the 'relative to symlink' source file exists, and if it
 * does it will use it. If it does not, it checks if there's a file that
 * exists that is relative to the current working directory, if does its used.
 * This preserves the expectations of the original fs.symlink spec and adds
 * the ability to pass in `relative to current working direcotry` paths.
 */

async function symlinkPaths (srcpath, dstpath) {
  if (path.isAbsolute(srcpath)) {
    try {
      await fs.lstat(srcpath)
    } catch (err) {
      err.message = err.message.replace('lstat', 'ensureSymlink')
      throw err
    }

    return {
      toCwd: srcpath,
      toDst: srcpath
    }
  }

  const dstdir = path.dirname(dstpath)
  const relativeToDst = path.join(dstdir, srcpath)

  const exists = await pathExists(relativeToDst)
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    }
  }

  try {
    await fs.lstat(srcpath)
  } catch (err) {
    err.message = err.message.replace('lstat', 'ensureSymlink')
    throw err
  }

  return {
    toCwd: srcpath,
    toDst: path.relative(dstdir, srcpath)
  }
}

function symlinkPathsSync (srcpath, dstpath) {
  if (path.isAbsolute(srcpath)) {
    const exists = fs.existsSync(srcpath)
    if (!exists) throw new Error('absolute srcpath does not exist')
    return {
      toCwd: srcpath,
      toDst: srcpath
    }
  }

  const dstdir = path.dirname(dstpath)
  const relativeToDst = path.join(dstdir, srcpath)
  const exists = fs.existsSync(relativeToDst)
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    }
  }

  const srcExists = fs.existsSync(srcpath)
  if (!srcExists) throw new Error('relative srcpath does not exist')
  return {
    toCwd: srcpath,
    toDst: path.relative(dstdir, srcpath)
  }
}

module.exports = {
  symlinkPaths: u(symlinkPaths),
  symlinkPathsSync
}


/***/ }),
/* 38 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const u = (__webpack_require__(13).fromPromise)

async function symlinkType (srcpath, type) {
  if (type) return type

  let stats
  try {
    stats = await fs.lstat(srcpath)
  } catch {
    return 'file'
  }

  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

function symlinkTypeSync (srcpath, type) {
  if (type) return type

  let stats
  try {
    stats = fs.lstatSync(srcpath)
  } catch {
    return 'file'
  }
  return (stats && stats.isDirectory()) ? 'dir' : 'file'
}

module.exports = {
  symlinkType: u(symlinkType),
  symlinkTypeSync
}


/***/ }),
/* 39 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const jsonFile = __webpack_require__(40)

jsonFile.outputJson = u(__webpack_require__(43))
jsonFile.outputJsonSync = __webpack_require__(45)
// aliases
jsonFile.outputJSON = jsonFile.outputJson
jsonFile.outputJSONSync = jsonFile.outputJsonSync
jsonFile.writeJSON = jsonFile.writeJson
jsonFile.writeJSONSync = jsonFile.writeJsonSync
jsonFile.readJSON = jsonFile.readJson
jsonFile.readJSONSync = jsonFile.readJsonSync

module.exports = jsonFile


/***/ }),
/* 40 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const jsonFile = __webpack_require__(41)

module.exports = {
  // jsonfile exports
  readJson: jsonFile.readFile,
  readJsonSync: jsonFile.readFileSync,
  writeJson: jsonFile.writeFile,
  writeJsonSync: jsonFile.writeFileSync
}


/***/ }),
/* 41 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

let _fs
try {
  _fs = __webpack_require__(14)
} catch (_) {
  _fs = __webpack_require__(5)
}
const universalify = __webpack_require__(13)
const { stringify, stripBom } = __webpack_require__(42)

async function _readFile (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options }
  }

  const fs = options.fs || _fs

  const shouldThrow = 'throws' in options ? options.throws : true

  let data = await universalify.fromCallback(fs.readFile)(file, options)

  data = stripBom(data)

  let obj
  try {
    obj = JSON.parse(data, options ? options.reviver : null)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`
      throw err
    } else {
      return null
    }
  }

  return obj
}

const readFile = universalify.fromPromise(_readFile)

function readFileSync (file, options = {}) {
  if (typeof options === 'string') {
    options = { encoding: options }
  }

  const fs = options.fs || _fs

  const shouldThrow = 'throws' in options ? options.throws : true

  try {
    let content = fs.readFileSync(file, options)
    content = stripBom(content)
    return JSON.parse(content, options.reviver)
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file}: ${err.message}`
      throw err
    } else {
      return null
    }
  }
}

async function _writeFile (file, obj, options = {}) {
  const fs = options.fs || _fs

  const str = stringify(obj, options)

  await universalify.fromCallback(fs.writeFile)(file, str, options)
}

const writeFile = universalify.fromPromise(_writeFile)

function writeFileSync (file, obj, options = {}) {
  const fs = options.fs || _fs

  const str = stringify(obj, options)
  // not sure if fs.writeFileSync returns anything, but just in case
  return fs.writeFileSync(file, str, options)
}

const jsonfile = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
}

module.exports = jsonfile


/***/ }),
/* 42 */
/***/ ((module) => {

function stringify (obj, { EOL = '\n', finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : ''
  const str = JSON.stringify(obj, replacer, spaces)

  return str.replace(/\n/g, EOL) + EOF
}

function stripBom (content) {
  // we do this because JSON.parse would convert it to a utf8 string if encoding wasn't specified
  if (Buffer.isBuffer(content)) content = content.toString('utf8')
  return content.replace(/^\uFEFF/, '')
}

module.exports = { stringify, stripBom }


/***/ }),
/* 43 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { stringify } = __webpack_require__(42)
const { outputFile } = __webpack_require__(44)

async function outputJson (file, data, options = {}) {
  const str = stringify(data, options)

  await outputFile(file, str, options)
}

module.exports = outputJson


/***/ }),
/* 44 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const mkdir = __webpack_require__(24)
const pathExists = (__webpack_require__(27).pathExists)

async function outputFile (file, data, encoding = 'utf-8') {
  const dir = path.dirname(file)

  if (!(await pathExists(dir))) {
    await mkdir.mkdirs(dir)
  }

  return fs.writeFile(file, data, encoding)
}

function outputFileSync (file, ...args) {
  const dir = path.dirname(file)
  if (!fs.existsSync(dir)) {
    mkdir.mkdirsSync(dir)
  }

  fs.writeFileSync(file, ...args)
}

module.exports = {
  outputFile: u(outputFile),
  outputFileSync
}


/***/ }),
/* 45 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const { stringify } = __webpack_require__(42)
const { outputFileSync } = __webpack_require__(44)

function outputJsonSync (file, data, options) {
  const str = stringify(data, options)

  outputFileSync(file, str, options)
}

module.exports = outputJsonSync


/***/ }),
/* 46 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const u = (__webpack_require__(13).fromPromise)
module.exports = {
  move: u(__webpack_require__(47)),
  moveSync: __webpack_require__(48)
}


/***/ }),
/* 47 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(12)
const path = __webpack_require__(4)
const { copy } = __webpack_require__(22)
const { remove } = __webpack_require__(32)
const { mkdirp } = __webpack_require__(24)
const { pathExists } = __webpack_require__(27)
const stat = __webpack_require__(29)

async function move (src, dest, opts = {}) {
  const overwrite = opts.overwrite || opts.clobber || false

  const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, 'move', opts)

  await stat.checkParentPaths(src, srcStat, dest, 'move')

  // If the parent of dest is not root, make sure it exists before proceeding
  const destParent = path.dirname(dest)
  const parsedParentPath = path.parse(destParent)
  if (parsedParentPath.root !== destParent) {
    await mkdirp(destParent)
  }

  return doRename(src, dest, overwrite, isChangingCase)
}

async function doRename (src, dest, overwrite, isChangingCase) {
  if (!isChangingCase) {
    if (overwrite) {
      await remove(dest)
    } else if (await pathExists(dest)) {
      throw new Error('dest already exists.')
    }
  }

  try {
    // Try w/ rename first, and try copy + remove if EXDEV
    await fs.rename(src, dest)
  } catch (err) {
    if (err.code !== 'EXDEV') {
      throw err
    }
    await moveAcrossDevice(src, dest, overwrite)
  }
}

async function moveAcrossDevice (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  }

  await copy(src, dest, opts)
  return remove(src)
}

module.exports = move


/***/ }),
/* 48 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const fs = __webpack_require__(14)
const path = __webpack_require__(4)
const copySync = (__webpack_require__(22).copySync)
const removeSync = (__webpack_require__(32).removeSync)
const mkdirpSync = (__webpack_require__(24).mkdirpSync)
const stat = __webpack_require__(29)

function moveSync (src, dest, opts) {
  opts = opts || {}
  const overwrite = opts.overwrite || opts.clobber || false

  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, 'move', opts)
  stat.checkParentPathsSync(src, srcStat, dest, 'move')
  if (!isParentRoot(dest)) mkdirpSync(path.dirname(dest))
  return doRename(src, dest, overwrite, isChangingCase)
}

function isParentRoot (dest) {
  const parent = path.dirname(dest)
  const parsedPath = path.parse(parent)
  return parsedPath.root === parent
}

function doRename (src, dest, overwrite, isChangingCase) {
  if (isChangingCase) return rename(src, dest, overwrite)
  if (overwrite) {
    removeSync(dest)
    return rename(src, dest, overwrite)
  }
  if (fs.existsSync(dest)) throw new Error('dest already exists.')
  return rename(src, dest, overwrite)
}

function rename (src, dest, overwrite) {
  try {
    fs.renameSync(src, dest)
  } catch (err) {
    if (err.code !== 'EXDEV') throw err
    return moveAcrossDevice(src, dest, overwrite)
  }
}

function moveAcrossDevice (src, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  }
  copySync(src, dest, opts)
  return removeSync(src)
}

module.exports = moveSync


/***/ }),
/* 49 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(50);
var Document = __webpack_require__(55);
var Schema = __webpack_require__(73);
var errors = __webpack_require__(99);
var Alias = __webpack_require__(56);
var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var Scalar = __webpack_require__(63);
var YAMLMap = __webpack_require__(75);
var YAMLSeq = __webpack_require__(78);
var cst = __webpack_require__(115);
var lexer = __webpack_require__(119);
var lineCounter = __webpack_require__(120);
var parser = __webpack_require__(121);
var publicApi = __webpack_require__(122);
var visit = __webpack_require__(54);



exports.Composer = composer.Composer;
exports.Document = Document.Document;
exports.Schema = Schema.Schema;
exports.YAMLError = errors.YAMLError;
exports.YAMLParseError = errors.YAMLParseError;
exports.YAMLWarning = errors.YAMLWarning;
exports.Alias = Alias.Alias;
exports.isAlias = identity.isAlias;
exports.isCollection = identity.isCollection;
exports.isDocument = identity.isDocument;
exports.isMap = identity.isMap;
exports.isNode = identity.isNode;
exports.isPair = identity.isPair;
exports.isScalar = identity.isScalar;
exports.isSeq = identity.isSeq;
exports.Pair = Pair.Pair;
exports.Scalar = Scalar.Scalar;
exports.YAMLMap = YAMLMap.YAMLMap;
exports.YAMLSeq = YAMLSeq.YAMLSeq;
exports.CST = cst;
exports.Lexer = lexer.Lexer;
exports.LineCounter = lineCounter.LineCounter;
exports.Parser = parser.Parser;
exports.parse = publicApi.parse;
exports.parseAllDocuments = publicApi.parseAllDocuments;
exports.parseDocument = publicApi.parseDocument;
exports.stringify = publicApi.stringify;
exports.visit = visit.visit;
exports.visitAsync = visit.visitAsync;


/***/ }),
/* 50 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var node_process = __webpack_require__(51);
var directives = __webpack_require__(52);
var Document = __webpack_require__(55);
var errors = __webpack_require__(99);
var identity = __webpack_require__(53);
var composeDoc = __webpack_require__(100);
var resolveEnd = __webpack_require__(110);

function getErrorPos(src) {
    if (typeof src === 'number')
        return [src, src + 1];
    if (Array.isArray(src))
        return src.length === 2 ? src : [src[0], src[1]];
    const { offset, source } = src;
    return [offset, offset + (typeof source === 'string' ? source.length : 1)];
}
function parsePrelude(prelude) {
    let comment = '';
    let atComment = false;
    let afterEmptyLine = false;
    for (let i = 0; i < prelude.length; ++i) {
        const source = prelude[i];
        switch (source[0]) {
            case '#':
                comment +=
                    (comment === '' ? '' : afterEmptyLine ? '\n\n' : '\n') +
                        (source.substring(1) || ' ');
                atComment = true;
                afterEmptyLine = false;
                break;
            case '%':
                if (prelude[i + 1]?.[0] !== '#')
                    i += 1;
                atComment = false;
                break;
            default:
                // This may be wrong after doc-end, but in that case it doesn't matter
                if (!atComment)
                    afterEmptyLine = true;
                atComment = false;
        }
    }
    return { comment, afterEmptyLine };
}
/**
 * Compose a stream of CST nodes into a stream of YAML Documents.
 *
 * ```ts
 * import { Composer, Parser } from 'yaml'
 *
 * const src: string = ...
 * const tokens = new Parser().parse(src)
 * const docs = new Composer().compose(tokens)
 * ```
 */
class Composer {
    constructor(options = {}) {
        this.doc = null;
        this.atDirectives = false;
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
        this.onError = (source, code, message, warning) => {
            const pos = getErrorPos(source);
            if (warning)
                this.warnings.push(new errors.YAMLWarning(pos, code, message));
            else
                this.errors.push(new errors.YAMLParseError(pos, code, message));
        };
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        this.directives = new directives.Directives({ version: options.version || '1.2' });
        this.options = options;
    }
    decorate(doc, afterDoc) {
        const { comment, afterEmptyLine } = parsePrelude(this.prelude);
        //console.log({ dc: doc.comment, prelude, comment })
        if (comment) {
            const dc = doc.contents;
            if (afterDoc) {
                doc.comment = doc.comment ? `${doc.comment}\n${comment}` : comment;
            }
            else if (afterEmptyLine || doc.directives.docStart || !dc) {
                doc.commentBefore = comment;
            }
            else if (identity.isCollection(dc) && !dc.flow && dc.items.length > 0) {
                let it = dc.items[0];
                if (identity.isPair(it))
                    it = it.key;
                const cb = it.commentBefore;
                it.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
            else {
                const cb = dc.commentBefore;
                dc.commentBefore = cb ? `${comment}\n${cb}` : comment;
            }
        }
        if (afterDoc) {
            Array.prototype.push.apply(doc.errors, this.errors);
            Array.prototype.push.apply(doc.warnings, this.warnings);
        }
        else {
            doc.errors = this.errors;
            doc.warnings = this.warnings;
        }
        this.prelude = [];
        this.errors = [];
        this.warnings = [];
    }
    /**
     * Current stream status information.
     *
     * Mostly useful at the end of input for an empty stream.
     */
    streamInfo() {
        return {
            comment: parsePrelude(this.prelude).comment,
            directives: this.directives,
            errors: this.errors,
            warnings: this.warnings
        };
    }
    /**
     * Compose tokens into documents.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *compose(tokens, forceDoc = false, endOffset = -1) {
        for (const token of tokens)
            yield* this.next(token);
        yield* this.end(forceDoc, endOffset);
    }
    /** Advance the composer by one CST token. */
    *next(token) {
        if (node_process.env.LOG_STREAM)
            console.dir(token, { depth: null });
        switch (token.type) {
            case 'directive':
                this.directives.add(token.source, (offset, message, warning) => {
                    const pos = getErrorPos(token);
                    pos[0] += offset;
                    this.onError(pos, 'BAD_DIRECTIVE', message, warning);
                });
                this.prelude.push(token.source);
                this.atDirectives = true;
                break;
            case 'document': {
                const doc = composeDoc.composeDoc(this.options, this.directives, token, this.onError);
                if (this.atDirectives && !doc.directives.docStart)
                    this.onError(token, 'MISSING_CHAR', 'Missing directives-end/doc-start indicator line');
                this.decorate(doc, false);
                if (this.doc)
                    yield this.doc;
                this.doc = doc;
                this.atDirectives = false;
                break;
            }
            case 'byte-order-mark':
            case 'space':
                break;
            case 'comment':
            case 'newline':
                this.prelude.push(token.source);
                break;
            case 'error': {
                const msg = token.source
                    ? `${token.message}: ${JSON.stringify(token.source)}`
                    : token.message;
                const error = new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg);
                if (this.atDirectives || !this.doc)
                    this.errors.push(error);
                else
                    this.doc.errors.push(error);
                break;
            }
            case 'doc-end': {
                if (!this.doc) {
                    const msg = 'Unexpected doc-end without preceding document';
                    this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', msg));
                    break;
                }
                this.doc.directives.docEnd = true;
                const end = resolveEnd.resolveEnd(token.end, token.offset + token.source.length, this.doc.options.strict, this.onError);
                this.decorate(this.doc, true);
                if (end.comment) {
                    const dc = this.doc.comment;
                    this.doc.comment = dc ? `${dc}\n${end.comment}` : end.comment;
                }
                this.doc.range[2] = end.offset;
                break;
            }
            default:
                this.errors.push(new errors.YAMLParseError(getErrorPos(token), 'UNEXPECTED_TOKEN', `Unsupported token ${token.type}`));
        }
    }
    /**
     * Call at end of input to yield any remaining document.
     *
     * @param forceDoc - If the stream contains no document, still emit a final document including any comments and directives that would be applied to a subsequent document.
     * @param endOffset - Should be set if `forceDoc` is also set, to set the document range end and to indicate errors correctly.
     */
    *end(forceDoc = false, endOffset = -1) {
        if (this.doc) {
            this.decorate(this.doc, true);
            yield this.doc;
            this.doc = null;
        }
        else if (forceDoc) {
            const opts = Object.assign({ _directives: this.directives }, this.options);
            const doc = new Document.Document(undefined, opts);
            if (this.atDirectives)
                this.onError(endOffset, 'MISSING_CHAR', 'Missing directives-end indicator line');
            doc.range = [0, endOffset, endOffset];
            this.decorate(doc, false);
            yield doc;
        }
    }
}

exports.Composer = Composer;


/***/ }),
/* 51 */
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),
/* 52 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var visit = __webpack_require__(54);

const escapeChars = {
    '!': '%21',
    ',': '%2C',
    '[': '%5B',
    ']': '%5D',
    '{': '%7B',
    '}': '%7D'
};
const escapeTagName = (tn) => tn.replace(/[!,[\]{}]/g, ch => escapeChars[ch]);
class Directives {
    constructor(yaml, tags) {
        /**
         * The directives-end/doc-start marker `---`. If `null`, a marker may still be
         * included in the document's stringified representation.
         */
        this.docStart = null;
        /** The doc-end marker `...`.  */
        this.docEnd = false;
        this.yaml = Object.assign({}, Directives.defaultYaml, yaml);
        this.tags = Object.assign({}, Directives.defaultTags, tags);
    }
    clone() {
        const copy = new Directives(this.yaml, this.tags);
        copy.docStart = this.docStart;
        return copy;
    }
    /**
     * During parsing, get a Directives instance for the current document and
     * update the stream state according to the current version's spec.
     */
    atDocument() {
        const res = new Directives(this.yaml, this.tags);
        switch (this.yaml.version) {
            case '1.1':
                this.atNextDocument = true;
                break;
            case '1.2':
                this.atNextDocument = false;
                this.yaml = {
                    explicit: Directives.defaultYaml.explicit,
                    version: '1.2'
                };
                this.tags = Object.assign({}, Directives.defaultTags);
                break;
        }
        return res;
    }
    /**
     * @param onError - May be called even if the action was successful
     * @returns `true` on success
     */
    add(line, onError) {
        if (this.atNextDocument) {
            this.yaml = { explicit: Directives.defaultYaml.explicit, version: '1.1' };
            this.tags = Object.assign({}, Directives.defaultTags);
            this.atNextDocument = false;
        }
        const parts = line.trim().split(/[ \t]+/);
        const name = parts.shift();
        switch (name) {
            case '%TAG': {
                if (parts.length !== 2) {
                    onError(0, '%TAG directive should contain exactly two parts');
                    if (parts.length < 2)
                        return false;
                }
                const [handle, prefix] = parts;
                this.tags[handle] = prefix;
                return true;
            }
            case '%YAML': {
                this.yaml.explicit = true;
                if (parts.length !== 1) {
                    onError(0, '%YAML directive should contain exactly one part');
                    return false;
                }
                const [version] = parts;
                if (version === '1.1' || version === '1.2') {
                    this.yaml.version = version;
                    return true;
                }
                else {
                    const isValid = /^\d+\.\d+$/.test(version);
                    onError(6, `Unsupported YAML version ${version}`, isValid);
                    return false;
                }
            }
            default:
                onError(0, `Unknown directive ${name}`, true);
                return false;
        }
    }
    /**
     * Resolves a tag, matching handles to those defined in %TAG directives.
     *
     * @returns Resolved tag, which may also be the non-specific tag `'!'` or a
     *   `'!local'` tag, or `null` if unresolvable.
     */
    tagName(source, onError) {
        if (source === '!')
            return '!'; // non-specific tag
        if (source[0] !== '!') {
            onError(`Not a valid tag: ${source}`);
            return null;
        }
        if (source[1] === '<') {
            const verbatim = source.slice(2, -1);
            if (verbatim === '!' || verbatim === '!!') {
                onError(`Verbatim tags aren't resolved, so ${source} is invalid.`);
                return null;
            }
            if (source[source.length - 1] !== '>')
                onError('Verbatim tags must end with a >');
            return verbatim;
        }
        const [, handle, suffix] = source.match(/^(.*!)([^!]*)$/s);
        if (!suffix)
            onError(`The ${source} tag has no suffix`);
        const prefix = this.tags[handle];
        if (prefix) {
            try {
                return prefix + decodeURIComponent(suffix);
            }
            catch (error) {
                onError(String(error));
                return null;
            }
        }
        if (handle === '!')
            return source; // local tag
        onError(`Could not resolve tag: ${source}`);
        return null;
    }
    /**
     * Given a fully resolved tag, returns its printable string form,
     * taking into account current tag prefixes and defaults.
     */
    tagString(tag) {
        for (const [handle, prefix] of Object.entries(this.tags)) {
            if (tag.startsWith(prefix))
                return handle + escapeTagName(tag.substring(prefix.length));
        }
        return tag[0] === '!' ? tag : `!<${tag}>`;
    }
    toString(doc) {
        const lines = this.yaml.explicit
            ? [`%YAML ${this.yaml.version || '1.2'}`]
            : [];
        const tagEntries = Object.entries(this.tags);
        let tagNames;
        if (doc && tagEntries.length > 0 && identity.isNode(doc.contents)) {
            const tags = {};
            visit.visit(doc.contents, (_key, node) => {
                if (identity.isNode(node) && node.tag)
                    tags[node.tag] = true;
            });
            tagNames = Object.keys(tags);
        }
        else
            tagNames = [];
        for (const [handle, prefix] of tagEntries) {
            if (handle === '!!' && prefix === 'tag:yaml.org,2002:')
                continue;
            if (!doc || tagNames.some(tn => tn.startsWith(prefix)))
                lines.push(`%TAG ${handle} ${prefix}`);
        }
        return lines.join('\n');
    }
}
Directives.defaultYaml = { explicit: false, version: '1.2' };
Directives.defaultTags = { '!!': 'tag:yaml.org,2002:' };

exports.Directives = Directives;


/***/ }),
/* 53 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const ALIAS = Symbol.for('yaml.alias');
const DOC = Symbol.for('yaml.document');
const MAP = Symbol.for('yaml.map');
const PAIR = Symbol.for('yaml.pair');
const SCALAR = Symbol.for('yaml.scalar');
const SEQ = Symbol.for('yaml.seq');
const NODE_TYPE = Symbol.for('yaml.node.type');
const isAlias = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === ALIAS;
const isDocument = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === DOC;
const isMap = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === MAP;
const isPair = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === PAIR;
const isScalar = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SCALAR;
const isSeq = (node) => !!node && typeof node === 'object' && node[NODE_TYPE] === SEQ;
function isCollection(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case MAP:
            case SEQ:
                return true;
        }
    return false;
}
function isNode(node) {
    if (node && typeof node === 'object')
        switch (node[NODE_TYPE]) {
            case ALIAS:
            case MAP:
            case SCALAR:
            case SEQ:
                return true;
        }
    return false;
}
const hasAnchor = (node) => (isScalar(node) || isCollection(node)) && !!node.anchor;

exports.ALIAS = ALIAS;
exports.DOC = DOC;
exports.MAP = MAP;
exports.NODE_TYPE = NODE_TYPE;
exports.PAIR = PAIR;
exports.SCALAR = SCALAR;
exports.SEQ = SEQ;
exports.hasAnchor = hasAnchor;
exports.isAlias = isAlias;
exports.isCollection = isCollection;
exports.isDocument = isDocument;
exports.isMap = isMap;
exports.isNode = isNode;
exports.isPair = isPair;
exports.isScalar = isScalar;
exports.isSeq = isSeq;


/***/ }),
/* 54 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);

const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove node');
/**
 * Apply a visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
function visit(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
        const cd = visit_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        visit_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current node */
visit.SKIP = SKIP;
/** Remove the current node */
visit.REMOVE = REMOVE;
function visit_(key, node, visitor, path) {
    const ctrl = callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visit_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = visit_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = visit_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = visit_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
/**
 * Apply an async visitor to an AST node or document.
 *
 * Walks through the tree (depth-first) starting from `node`, calling a
 * `visitor` function with three arguments:
 *   - `key`: For sequence values and map `Pair`, the node's index in the
 *     collection. Within a `Pair`, `'key'` or `'value'`, correspondingly.
 *     `null` for the root node.
 *   - `node`: The current node.
 *   - `path`: The ancestry of the current node.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `Promise`: Must resolve to one of the following values
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this node, continue with next
 *     sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current node, then continue with the next one
 *   - `Node`: Replace the current node, then continue by visiting it
 *   - `number`: While iterating the items of a sequence or map, set the index
 *     of the next step. This is useful especially if the index of the current
 *     node has changed.
 *
 * If `visitor` is a single function, it will be called with all values
 * encountered in the tree, including e.g. `null` values. Alternatively,
 * separate visitor functions may be defined for each `Map`, `Pair`, `Seq`,
 * `Alias` and `Scalar` node. To define the same visitor function for more than
 * one node type, use the `Collection` (map and seq), `Value` (map, seq & scalar)
 * and `Node` (alias, map, seq & scalar) targets. Of all these, only the most
 * specific defined one will be used for each node.
 */
async function visitAsync(node, visitor) {
    const visitor_ = initVisitor(visitor);
    if (identity.isDocument(node)) {
        const cd = await visitAsync_(null, node.contents, visitor_, Object.freeze([node]));
        if (cd === REMOVE)
            node.contents = null;
    }
    else
        await visitAsync_(null, node, visitor_, Object.freeze([]));
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visitAsync.BREAK = BREAK;
/** Do not visit the children of the current node */
visitAsync.SKIP = SKIP;
/** Remove the current node */
visitAsync.REMOVE = REMOVE;
async function visitAsync_(key, node, visitor, path) {
    const ctrl = await callVisitor(key, node, visitor, path);
    if (identity.isNode(ctrl) || identity.isPair(ctrl)) {
        replaceNode(key, path, ctrl);
        return visitAsync_(key, ctrl, visitor, path);
    }
    if (typeof ctrl !== 'symbol') {
        if (identity.isCollection(node)) {
            path = Object.freeze(path.concat(node));
            for (let i = 0; i < node.items.length; ++i) {
                const ci = await visitAsync_(i, node.items[i], visitor, path);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    node.items.splice(i, 1);
                    i -= 1;
                }
            }
        }
        else if (identity.isPair(node)) {
            path = Object.freeze(path.concat(node));
            const ck = await visitAsync_('key', node.key, visitor, path);
            if (ck === BREAK)
                return BREAK;
            else if (ck === REMOVE)
                node.key = null;
            const cv = await visitAsync_('value', node.value, visitor, path);
            if (cv === BREAK)
                return BREAK;
            else if (cv === REMOVE)
                node.value = null;
        }
    }
    return ctrl;
}
function initVisitor(visitor) {
    if (typeof visitor === 'object' &&
        (visitor.Collection || visitor.Node || visitor.Value)) {
        return Object.assign({
            Alias: visitor.Node,
            Map: visitor.Node,
            Scalar: visitor.Node,
            Seq: visitor.Node
        }, visitor.Value && {
            Map: visitor.Value,
            Scalar: visitor.Value,
            Seq: visitor.Value
        }, visitor.Collection && {
            Map: visitor.Collection,
            Seq: visitor.Collection
        }, visitor);
    }
    return visitor;
}
function callVisitor(key, node, visitor, path) {
    if (typeof visitor === 'function')
        return visitor(key, node, path);
    if (identity.isMap(node))
        return visitor.Map?.(key, node, path);
    if (identity.isSeq(node))
        return visitor.Seq?.(key, node, path);
    if (identity.isPair(node))
        return visitor.Pair?.(key, node, path);
    if (identity.isScalar(node))
        return visitor.Scalar?.(key, node, path);
    if (identity.isAlias(node))
        return visitor.Alias?.(key, node, path);
    return undefined;
}
function replaceNode(key, path, node) {
    const parent = path[path.length - 1];
    if (identity.isCollection(parent)) {
        parent.items[key] = node;
    }
    else if (identity.isPair(parent)) {
        if (key === 'key')
            parent.key = node;
        else
            parent.value = node;
    }
    else if (identity.isDocument(parent)) {
        parent.contents = node;
    }
    else {
        const pt = identity.isAlias(parent) ? 'alias' : 'scalar';
        throw new Error(`Cannot replace node with ${pt} parent`);
    }
}

exports.visit = visit;
exports.visitAsync = visitAsync;


/***/ }),
/* 55 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(56);
var Collection = __webpack_require__(61);
var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var toJS = __webpack_require__(60);
var Schema = __webpack_require__(73);
var stringifyDocument = __webpack_require__(98);
var anchors = __webpack_require__(57);
var applyReviver = __webpack_require__(59);
var createNode = __webpack_require__(62);
var directives = __webpack_require__(52);

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            stringKeys: false,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new directives.Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [identity.NODE_TYPE]: { value: identity.DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = identity.isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchors.anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? anchors.findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias.Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = anchors.createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode.createNode(value, tag, ctx);
        if (flow && identity.isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair.Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (Collection.isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return identity.isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (Collection.isEmptyPath(path))
            return !keepScalar && identity.isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return identity.isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return identity.isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (Collection.isEmptyPath(path))
            return this.contents !== undefined;
        return identity.isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    set(key, value) {
        if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = Collection.collectionFromPath(this.schema, [key], value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.set(key, value);
        }
    }
    /**
     * Sets a value in this document. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        if (Collection.isEmptyPath(path)) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = value;
        }
        else if (this.contents == null) {
            // @ts-expect-error We can't really know that this matches Contents.
            this.contents = Collection.collectionFromPath(this.schema, Array.from(path), value);
        }
        else if (assertCollection(this.contents)) {
            this.contents.setIn(path, value);
        }
    }
    /**
     * Change the YAML version and schema used by the document.
     * A `null` version disables support for directives, explicit tags, anchors, and aliases.
     * It also requires the `schema` option to be given as a `Schema` instance value.
     *
     * Overrides all previously set schema options.
     */
    setSchema(version, options = {}) {
        if (typeof version === 'number')
            version = String(version);
        let opt;
        switch (version) {
            case '1.1':
                if (this.directives)
                    this.directives.yaml.version = '1.1';
                else
                    this.directives = new directives.Directives({ version: '1.1' });
                opt = { resolveKnownTags: false, schema: 'yaml-1.1' };
                break;
            case '1.2':
            case 'next':
                if (this.directives)
                    this.directives.yaml.version = version;
                else
                    this.directives = new directives.Directives({ version });
                opt = { resolveKnownTags: true, schema: 'core' };
                break;
            case null:
                if (this.directives)
                    delete this.directives;
                opt = null;
                break;
            default: {
                const sv = JSON.stringify(version);
                throw new Error(`Expected '1.1', '1.2' or null as first argument, but found: ${sv}`);
            }
        }
        // Not using `instanceof Schema` to allow for duck typing
        if (options.schema instanceof Object)
            this.schema = options.schema;
        else if (opt)
            this.schema = new Schema.Schema(Object.assign(opt, options));
        else
            throw new Error(`With a null YAML version, the { schema: Schema } option is required`);
    }
    // json & jsonArg are only used from toJSON()
    toJS({ json, jsonArg, mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        const ctx = {
            anchors: new Map(),
            doc: this,
            keep: !json,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS.toJS(this.contents, jsonArg ?? '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
    /**
     * A JSON representation of the document `contents`.
     *
     * @param jsonArg Used by `JSON.stringify` to indicate the array index or
     *   property name.
     */
    toJSON(jsonArg, onAnchor) {
        return this.toJS({ json: true, jsonArg, mapAsMap: false, onAnchor });
    }
    /** A YAML representation of the document. */
    toString(options = {}) {
        if (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument.stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (identity.isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

exports.Document = Document;


/***/ }),
/* 56 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(57);
var visit = __webpack_require__(54);
var identity = __webpack_require__(53);
var Node = __webpack_require__(58);
var toJS = __webpack_require__(60);

class Alias extends Node.NodeBase {
    constructor(source) {
        super(identity.ALIAS);
        this.source = source;
        Object.defineProperty(this, 'tag', {
            set() {
                throw new Error('Alias nodes cannot have tags');
            }
        });
    }
    /**
     * Resolve the value of this alias within `doc`, finding the last
     * instance of the `source` anchor before this node.
     */
    resolve(doc, ctx) {
        let nodes;
        if (ctx?.aliasResolveCache) {
            nodes = ctx.aliasResolveCache;
        }
        else {
            nodes = [];
            visit.visit(doc, {
                Node: (_key, node) => {
                    if (identity.isAlias(node) || identity.hasAnchor(node))
                        nodes.push(node);
                }
            });
            if (ctx)
                ctx.aliasResolveCache = nodes;
        }
        let found = undefined;
        for (const node of nodes) {
            if (node === this)
                break;
            if (node.anchor === this.source)
                found = node;
        }
        return found;
    }
    toJSON(_arg, ctx) {
        if (!ctx)
            return { source: this.source };
        const { anchors, doc, maxAliasCount } = ctx;
        const source = this.resolve(doc, ctx);
        if (!source) {
            const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
            throw new ReferenceError(msg);
        }
        let data = anchors.get(source);
        if (!data) {
            // Resolve anchors for Node.prototype.toJS()
            toJS.toJS(source, null, ctx);
            data = anchors.get(source);
        }
        /* istanbul ignore if */
        if (!data || data.res === undefined) {
            const msg = 'This should not happen: Alias anchor was not resolved?';
            throw new ReferenceError(msg);
        }
        if (maxAliasCount >= 0) {
            data.count += 1;
            if (data.aliasCount === 0)
                data.aliasCount = getAliasCount(doc, source, anchors);
            if (data.count * data.aliasCount > maxAliasCount) {
                const msg = 'Excessive alias count indicates a resource exhaustion attack';
                throw new ReferenceError(msg);
            }
        }
        return data.res;
    }
    toString(ctx, _onComment, _onChompKeep) {
        const src = `*${this.source}`;
        if (ctx) {
            anchors.anchorIsValid(this.source);
            if (ctx.options.verifyAliasOrder && !ctx.anchors.has(this.source)) {
                const msg = `Unresolved alias (the anchor must be set before the alias): ${this.source}`;
                throw new Error(msg);
            }
            if (ctx.implicitKey)
                return `${src} `;
        }
        return src;
    }
}
function getAliasCount(doc, node, anchors) {
    if (identity.isAlias(node)) {
        const source = node.resolve(doc);
        const anchor = anchors && source && anchors.get(source);
        return anchor ? anchor.count * anchor.aliasCount : 0;
    }
    else if (identity.isCollection(node)) {
        let count = 0;
        for (const item of node.items) {
            const c = getAliasCount(doc, item, anchors);
            if (c > count)
                count = c;
        }
        return count;
    }
    else if (identity.isPair(node)) {
        const kc = getAliasCount(doc, node.key, anchors);
        const vc = getAliasCount(doc, node.value, anchors);
        return Math.max(kc, vc);
    }
    return 1;
}

exports.Alias = Alias;


/***/ }),
/* 57 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var visit = __webpack_require__(54);

/**
 * Verify that the input string is a valid anchor.
 *
 * Will throw on errors.
 */
function anchorIsValid(anchor) {
    if (/[\x00-\x19\s,[\]{}]/.test(anchor)) {
        const sa = JSON.stringify(anchor);
        const msg = `Anchor must not contain whitespace or control characters: ${sa}`;
        throw new Error(msg);
    }
    return true;
}
function anchorNames(root) {
    const anchors = new Set();
    visit.visit(root, {
        Value(_key, node) {
            if (node.anchor)
                anchors.add(node.anchor);
        }
    });
    return anchors;
}
/** Find a new anchor name with the given `prefix` and a one-indexed suffix. */
function findNewAnchor(prefix, exclude) {
    for (let i = 1; true; ++i) {
        const name = `${prefix}${i}`;
        if (!exclude.has(name))
            return name;
    }
}
function createNodeAnchors(doc, prefix) {
    const aliasObjects = [];
    const sourceObjects = new Map();
    let prevAnchors = null;
    return {
        onAnchor: (source) => {
            aliasObjects.push(source);
            prevAnchors ?? (prevAnchors = anchorNames(doc));
            const anchor = findNewAnchor(prefix, prevAnchors);
            prevAnchors.add(anchor);
            return anchor;
        },
        /**
         * With circular references, the source node is only resolved after all
         * of its child nodes are. This is why anchors are set only after all of
         * the nodes have been created.
         */
        setAnchors: () => {
            for (const source of aliasObjects) {
                const ref = sourceObjects.get(source);
                if (typeof ref === 'object' &&
                    ref.anchor &&
                    (identity.isScalar(ref.node) || identity.isCollection(ref.node))) {
                    ref.node.anchor = ref.anchor;
                }
                else {
                    const error = new Error('Failed to resolve repeated object (this should not happen)');
                    error.source = source;
                    throw error;
                }
            }
        },
        sourceObjects
    };
}

exports.anchorIsValid = anchorIsValid;
exports.anchorNames = anchorNames;
exports.createNodeAnchors = createNodeAnchors;
exports.findNewAnchor = findNewAnchor;


/***/ }),
/* 58 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var applyReviver = __webpack_require__(59);
var identity = __webpack_require__(53);
var toJS = __webpack_require__(60);

class NodeBase {
    constructor(type) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: type });
    }
    /** Create a copy of this node.  */
    clone() {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** A plain JavaScript representation of this node. */
    toJS(doc, { mapAsMap, maxAliasCount, onAnchor, reviver } = {}) {
        if (!identity.isDocument(doc))
            throw new TypeError('A document argument is required');
        const ctx = {
            anchors: new Map(),
            doc,
            keep: true,
            mapAsMap: mapAsMap === true,
            mapKeyWarned: false,
            maxAliasCount: typeof maxAliasCount === 'number' ? maxAliasCount : 100
        };
        const res = toJS.toJS(this, '', ctx);
        if (typeof onAnchor === 'function')
            for (const { count, res } of ctx.anchors.values())
                onAnchor(res, count);
        return typeof reviver === 'function'
            ? applyReviver.applyReviver(reviver, { '': res }, '', res)
            : res;
    }
}

exports.NodeBase = NodeBase;


/***/ }),
/* 59 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Applies the JSON.parse reviver algorithm as defined in the ECMA-262 spec,
 * in section 24.5.1.1 "Runtime Semantics: InternalizeJSONProperty" of the
 * 2021 edition: https://tc39.es/ecma262/#sec-json.parse
 *
 * Includes extensions for handling Map and Set objects.
 */
function applyReviver(reviver, obj, key, val) {
    if (val && typeof val === 'object') {
        if (Array.isArray(val)) {
            for (let i = 0, len = val.length; i < len; ++i) {
                const v0 = val[i];
                const v1 = applyReviver(reviver, val, String(i), v0);
                // eslint-disable-next-line @typescript-eslint/no-array-delete
                if (v1 === undefined)
                    delete val[i];
                else if (v1 !== v0)
                    val[i] = v1;
            }
        }
        else if (val instanceof Map) {
            for (const k of Array.from(val.keys())) {
                const v0 = val.get(k);
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    val.delete(k);
                else if (v1 !== v0)
                    val.set(k, v1);
            }
        }
        else if (val instanceof Set) {
            for (const v0 of Array.from(val)) {
                const v1 = applyReviver(reviver, val, v0, v0);
                if (v1 === undefined)
                    val.delete(v0);
                else if (v1 !== v0) {
                    val.delete(v0);
                    val.add(v1);
                }
            }
        }
        else {
            for (const [k, v0] of Object.entries(val)) {
                const v1 = applyReviver(reviver, val, k, v0);
                if (v1 === undefined)
                    delete val[k];
                else if (v1 !== v0)
                    val[k] = v1;
            }
        }
    }
    return reviver.call(obj, key, val);
}

exports.applyReviver = applyReviver;


/***/ }),
/* 60 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);

/**
 * Recursively convert any node or its contents to native JavaScript
 *
 * @param value - The input value
 * @param arg - If `value` defines a `toJSON()` method, use this
 *   as its first argument
 * @param ctx - Conversion context, originally set in Document#toJS(). If
 *   `{ keep: true }` is not set, output should be suitable for JSON
 *   stringification.
 */
function toJS(value, arg, ctx) {
    // eslint-disable-next-line @typescript-eslint/no-unsafe-return
    if (Array.isArray(value))
        return value.map((v, i) => toJS(v, String(i), ctx));
    if (value && typeof value.toJSON === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-unsafe-call
        if (!ctx || !identity.hasAnchor(value))
            return value.toJSON(arg, ctx);
        const data = { aliasCount: 0, count: 1, res: undefined };
        ctx.anchors.set(value, data);
        ctx.onCreate = res => {
            data.res = res;
            delete ctx.onCreate;
        };
        const res = value.toJSON(arg, ctx);
        if (ctx.onCreate)
            ctx.onCreate(res);
        return res;
    }
    if (typeof value === 'bigint' && !ctx?.keep)
        return Number(value);
    return value;
}

exports.toJS = toJS;


/***/ }),
/* 61 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(62);
var identity = __webpack_require__(53);
var Node = __webpack_require__(58);

function collectionFromPath(schema, path, value) {
    let v = value;
    for (let i = path.length - 1; i >= 0; --i) {
        const k = path[i];
        if (typeof k === 'number' && Number.isInteger(k) && k >= 0) {
            const a = [];
            a[k] = v;
            v = a;
        }
        else {
            v = new Map([[k, v]]);
        }
    }
    return createNode.createNode(v, undefined, {
        aliasDuplicateObjects: false,
        keepUndefined: false,
        onAnchor: () => {
            throw new Error('This should not happen, please report a bug.');
        },
        schema,
        sourceObjects: new Map()
    });
}
// Type guard is intentionally a little wrong so as to be more useful,
// as it does not cover untypable empty non-string iterables (e.g. []).
const isEmptyPath = (path) => path == null ||
    (typeof path === 'object' && !!path[Symbol.iterator]().next().done);
class Collection extends Node.NodeBase {
    constructor(type, schema) {
        super(type);
        Object.defineProperty(this, 'schema', {
            value: schema,
            configurable: true,
            enumerable: false,
            writable: true
        });
    }
    /**
     * Create a copy of this collection.
     *
     * @param schema - If defined, overwrites the original's schema
     */
    clone(schema) {
        const copy = Object.create(Object.getPrototypeOf(this), Object.getOwnPropertyDescriptors(this));
        if (schema)
            copy.schema = schema;
        copy.items = copy.items.map(it => identity.isNode(it) || identity.isPair(it) ? it.clone(schema) : it);
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /**
     * Adds a value to the collection. For `!!map` and `!!omap` the value must
     * be a Pair instance or a `{ key, value }` object, which may not have a key
     * that already exists in the map.
     */
    addIn(path, value) {
        if (isEmptyPath(path))
            this.add(value);
        else {
            const [key, ...rest] = path;
            const node = this.get(key, true);
            if (identity.isCollection(node))
                node.addIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
    /**
     * Removes a value from the collection.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.delete(key);
        const node = this.get(key, true);
        if (identity.isCollection(node))
            return node.deleteIn(rest);
        else
            throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        const [key, ...rest] = path;
        const node = this.get(key, true);
        if (rest.length === 0)
            return !keepScalar && identity.isScalar(node) ? node.value : node;
        else
            return identity.isCollection(node) ? node.getIn(rest, keepScalar) : undefined;
    }
    hasAllNullValues(allowScalar) {
        return this.items.every(node => {
            if (!identity.isPair(node))
                return false;
            const n = node.value;
            return (n == null ||
                (allowScalar &&
                    identity.isScalar(n) &&
                    n.value == null &&
                    !n.commentBefore &&
                    !n.comment &&
                    !n.tag));
        });
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     */
    hasIn(path) {
        const [key, ...rest] = path;
        if (rest.length === 0)
            return this.has(key);
        const node = this.get(key, true);
        return identity.isCollection(node) ? node.hasIn(rest) : false;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     */
    setIn(path, value) {
        const [key, ...rest] = path;
        if (rest.length === 0) {
            this.set(key, value);
        }
        else {
            const node = this.get(key, true);
            if (identity.isCollection(node))
                node.setIn(rest, value);
            else if (node === undefined && this.schema)
                this.set(key, collectionFromPath(this.schema, rest, value));
            else
                throw new Error(`Expected YAML collection at ${key}. Remaining path: ${rest}`);
        }
    }
}

exports.Collection = Collection;
exports.collectionFromPath = collectionFromPath;
exports.isEmptyPath = isEmptyPath;


/***/ }),
/* 62 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(56);
var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);

const defaultTagPrefix = 'tag:yaml.org,2002:';
function findTagObject(value, tagName, tags) {
    if (tagName) {
        const match = tags.filter(t => t.tag === tagName);
        const tagObj = match.find(t => !t.format) ?? match[0];
        if (!tagObj)
            throw new Error(`Tag ${tagName} not found`);
        return tagObj;
    }
    return tags.find(t => t.identify?.(value) && !t.format);
}
function createNode(value, tagName, ctx) {
    if (identity.isDocument(value))
        value = value.contents;
    if (identity.isNode(value))
        return value;
    if (identity.isPair(value)) {
        const map = ctx.schema[identity.MAP].createNode?.(ctx.schema, null, ctx);
        map.items.push(value);
        return map;
    }
    if (value instanceof String ||
        value instanceof Number ||
        value instanceof Boolean ||
        (typeof BigInt !== 'undefined' && value instanceof BigInt) // not supported everywhere
    ) {
        // https://tc39.es/ecma262/#sec-serializejsonproperty
        value = value.valueOf();
    }
    const { aliasDuplicateObjects, onAnchor, onTagObj, schema, sourceObjects } = ctx;
    // Detect duplicate references to the same object & use Alias nodes for all
    // after first. The `ref` wrapper allows for circular references to resolve.
    let ref = undefined;
    if (aliasDuplicateObjects && value && typeof value === 'object') {
        ref = sourceObjects.get(value);
        if (ref) {
            ref.anchor ?? (ref.anchor = onAnchor(value));
            return new Alias.Alias(ref.anchor);
        }
        else {
            ref = { anchor: null, node: null };
            sourceObjects.set(value, ref);
        }
    }
    if (tagName?.startsWith('!!'))
        tagName = defaultTagPrefix + tagName.slice(2);
    let tagObj = findTagObject(value, tagName, schema.tags);
    if (!tagObj) {
        if (value && typeof value.toJSON === 'function') {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-call
            value = value.toJSON();
        }
        if (!value || typeof value !== 'object') {
            const node = new Scalar.Scalar(value);
            if (ref)
                ref.node = node;
            return node;
        }
        tagObj =
            value instanceof Map
                ? schema[identity.MAP]
                : Symbol.iterator in Object(value)
                    ? schema[identity.SEQ]
                    : schema[identity.MAP];
    }
    if (onTagObj) {
        onTagObj(tagObj);
        delete ctx.onTagObj;
    }
    const node = tagObj?.createNode
        ? tagObj.createNode(ctx.schema, value, ctx)
        : typeof tagObj?.nodeClass?.from === 'function'
            ? tagObj.nodeClass.from(ctx.schema, value, ctx)
            : new Scalar.Scalar(value);
    if (tagName)
        node.tag = tagName;
    else if (!tagObj.default)
        node.tag = tagObj.tag;
    if (ref)
        ref.node = node;
    return node;
}

exports.createNode = createNode;


/***/ }),
/* 63 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Node = __webpack_require__(58);
var toJS = __webpack_require__(60);

const isScalarValue = (value) => !value || (typeof value !== 'function' && typeof value !== 'object');
class Scalar extends Node.NodeBase {
    constructor(value) {
        super(identity.SCALAR);
        this.value = value;
    }
    toJSON(arg, ctx) {
        return ctx?.keep ? this.value : toJS.toJS(this.value, arg, ctx);
    }
    toString() {
        return String(this.value);
    }
}
Scalar.BLOCK_FOLDED = 'BLOCK_FOLDED';
Scalar.BLOCK_LITERAL = 'BLOCK_LITERAL';
Scalar.PLAIN = 'PLAIN';
Scalar.QUOTE_DOUBLE = 'QUOTE_DOUBLE';
Scalar.QUOTE_SINGLE = 'QUOTE_SINGLE';

exports.Scalar = Scalar;
exports.isScalarValue = isScalarValue;


/***/ }),
/* 64 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(62);
var stringifyPair = __webpack_require__(65);
var addPairToJSMap = __webpack_require__(70);
var identity = __webpack_require__(53);

function createPair(key, value, ctx) {
    const k = createNode.createNode(key, undefined, ctx);
    const v = createNode.createNode(value, undefined, ctx);
    return new Pair(k, v);
}
class Pair {
    constructor(key, value = null) {
        Object.defineProperty(this, identity.NODE_TYPE, { value: identity.PAIR });
        this.key = key;
        this.value = value;
    }
    clone(schema) {
        let { key, value } = this;
        if (identity.isNode(key))
            key = key.clone(schema);
        if (identity.isNode(value))
            value = value.clone(schema);
        return new Pair(key, value);
    }
    toJSON(_, ctx) {
        const pair = ctx?.mapAsMap ? new Map() : {};
        return addPairToJSMap.addPairToJSMap(ctx, pair, this);
    }
    toString(ctx, onComment, onChompKeep) {
        return ctx?.doc
            ? stringifyPair.stringifyPair(this, ctx, onComment, onChompKeep)
            : JSON.stringify(this);
    }
}

exports.Pair = Pair;
exports.createPair = createPair;


/***/ }),
/* 65 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);
var stringify = __webpack_require__(66);
var stringifyComment = __webpack_require__(67);

function stringifyPair({ key, value }, ctx, onComment, onChompKeep) {
    const { allNullValues, doc, indent, indentStep, options: { commentString, indentSeq, simpleKeys } } = ctx;
    let keyComment = (identity.isNode(key) && key.comment) || null;
    if (simpleKeys) {
        if (keyComment) {
            throw new Error('With simple keys, key nodes cannot have comments');
        }
        if (identity.isCollection(key) || (!identity.isNode(key) && typeof key === 'object')) {
            const msg = 'With simple keys, collection cannot be used as a key value';
            throw new Error(msg);
        }
    }
    let explicitKey = !simpleKeys &&
        (!key ||
            (keyComment && value == null && !ctx.inFlow) ||
            identity.isCollection(key) ||
            (identity.isScalar(key)
                ? key.type === Scalar.Scalar.BLOCK_FOLDED || key.type === Scalar.Scalar.BLOCK_LITERAL
                : typeof key === 'object'));
    ctx = Object.assign({}, ctx, {
        allNullValues: false,
        implicitKey: !explicitKey && (simpleKeys || !allNullValues),
        indent: indent + indentStep
    });
    let keyCommentDone = false;
    let chompKeep = false;
    let str = stringify.stringify(key, ctx, () => (keyCommentDone = true), () => (chompKeep = true));
    if (!explicitKey && !ctx.inFlow && str.length > 1024) {
        if (simpleKeys)
            throw new Error('With simple keys, single line scalar must not span more than 1024 characters');
        explicitKey = true;
    }
    if (ctx.inFlow) {
        if (allNullValues || value == null) {
            if (keyCommentDone && onComment)
                onComment();
            return str === '' ? '?' : explicitKey ? `? ${str}` : str;
        }
    }
    else if ((allNullValues && !simpleKeys) || (value == null && explicitKey)) {
        str = `? ${str}`;
        if (keyComment && !keyCommentDone) {
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        }
        else if (chompKeep && onChompKeep)
            onChompKeep();
        return str;
    }
    if (keyCommentDone)
        keyComment = null;
    if (explicitKey) {
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
        str = `? ${str}\n${indent}:`;
    }
    else {
        str = `${str}:`;
        if (keyComment)
            str += stringifyComment.lineComment(str, ctx.indent, commentString(keyComment));
    }
    let vsb, vcb, valueComment;
    if (identity.isNode(value)) {
        vsb = !!value.spaceBefore;
        vcb = value.commentBefore;
        valueComment = value.comment;
    }
    else {
        vsb = false;
        vcb = null;
        valueComment = null;
        if (value && typeof value === 'object')
            value = doc.createNode(value);
    }
    ctx.implicitKey = false;
    if (!explicitKey && !keyComment && identity.isScalar(value))
        ctx.indentAtStart = str.length + 1;
    chompKeep = false;
    if (!indentSeq &&
        indentStep.length >= 2 &&
        !ctx.inFlow &&
        !explicitKey &&
        identity.isSeq(value) &&
        !value.flow &&
        !value.tag &&
        !value.anchor) {
        // If indentSeq === false, consider '- ' as part of indentation where possible
        ctx.indent = ctx.indent.substring(2);
    }
    let valueCommentDone = false;
    const valueStr = stringify.stringify(value, ctx, () => (valueCommentDone = true), () => (chompKeep = true));
    let ws = ' ';
    if (keyComment || vsb || vcb) {
        ws = vsb ? '\n' : '';
        if (vcb) {
            const cs = commentString(vcb);
            ws += `\n${stringifyComment.indentComment(cs, ctx.indent)}`;
        }
        if (valueStr === '' && !ctx.inFlow) {
            if (ws === '\n')
                ws = '\n\n';
        }
        else {
            ws += `\n${ctx.indent}`;
        }
    }
    else if (!explicitKey && identity.isCollection(value)) {
        const vs0 = valueStr[0];
        const nl0 = valueStr.indexOf('\n');
        const hasNewline = nl0 !== -1;
        const flow = ctx.inFlow ?? value.flow ?? value.items.length === 0;
        if (hasNewline || !flow) {
            let hasPropsLine = false;
            if (hasNewline && (vs0 === '&' || vs0 === '!')) {
                let sp0 = valueStr.indexOf(' ');
                if (vs0 === '&' &&
                    sp0 !== -1 &&
                    sp0 < nl0 &&
                    valueStr[sp0 + 1] === '!') {
                    sp0 = valueStr.indexOf(' ', sp0 + 1);
                }
                if (sp0 === -1 || nl0 < sp0)
                    hasPropsLine = true;
            }
            if (!hasPropsLine)
                ws = `\n${ctx.indent}`;
        }
    }
    else if (valueStr === '' || valueStr[0] === '\n') {
        ws = '';
    }
    str += ws + valueStr;
    if (ctx.inFlow) {
        if (valueCommentDone && onComment)
            onComment();
    }
    else if (valueComment && !valueCommentDone) {
        str += stringifyComment.lineComment(str, ctx.indent, commentString(valueComment));
    }
    else if (chompKeep && onChompKeep) {
        onChompKeep();
    }
    return str;
}

exports.stringifyPair = stringifyPair;


/***/ }),
/* 66 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var anchors = __webpack_require__(57);
var identity = __webpack_require__(53);
var stringifyComment = __webpack_require__(67);
var stringifyString = __webpack_require__(68);

function createStringifyContext(doc, options) {
    const opt = Object.assign({
        blockQuote: true,
        commentString: stringifyComment.stringifyComment,
        defaultKeyType: null,
        defaultStringType: 'PLAIN',
        directives: null,
        doubleQuotedAsJSON: false,
        doubleQuotedMinMultiLineLength: 40,
        falseStr: 'false',
        flowCollectionPadding: true,
        indentSeq: true,
        lineWidth: 80,
        minContentWidth: 20,
        nullStr: 'null',
        simpleKeys: false,
        singleQuote: null,
        trueStr: 'true',
        verifyAliasOrder: true
    }, doc.schema.toStringOptions, options);
    let inFlow;
    switch (opt.collectionStyle) {
        case 'block':
            inFlow = false;
            break;
        case 'flow':
            inFlow = true;
            break;
        default:
            inFlow = null;
    }
    return {
        anchors: new Set(),
        doc,
        flowCollectionPadding: opt.flowCollectionPadding ? ' ' : '',
        indent: '',
        indentStep: typeof opt.indent === 'number' ? ' '.repeat(opt.indent) : '  ',
        inFlow,
        options: opt
    };
}
function getTagObject(tags, item) {
    if (item.tag) {
        const match = tags.filter(t => t.tag === item.tag);
        if (match.length > 0)
            return match.find(t => t.format === item.format) ?? match[0];
    }
    let tagObj = undefined;
    let obj;
    if (identity.isScalar(item)) {
        obj = item.value;
        let match = tags.filter(t => t.identify?.(obj));
        if (match.length > 1) {
            const testMatch = match.filter(t => t.test);
            if (testMatch.length > 0)
                match = testMatch;
        }
        tagObj =
            match.find(t => t.format === item.format) ?? match.find(t => !t.format);
    }
    else {
        obj = item;
        tagObj = tags.find(t => t.nodeClass && obj instanceof t.nodeClass);
    }
    if (!tagObj) {
        const name = obj?.constructor?.name ?? (obj === null ? 'null' : typeof obj);
        throw new Error(`Tag not resolved for ${name} value`);
    }
    return tagObj;
}
// needs to be called before value stringifier to allow for circular anchor refs
function stringifyProps(node, tagObj, { anchors: anchors$1, doc }) {
    if (!doc.directives)
        return '';
    const props = [];
    const anchor = (identity.isScalar(node) || identity.isCollection(node)) && node.anchor;
    if (anchor && anchors.anchorIsValid(anchor)) {
        anchors$1.add(anchor);
        props.push(`&${anchor}`);
    }
    const tag = node.tag ?? (tagObj.default ? null : tagObj.tag);
    if (tag)
        props.push(doc.directives.tagString(tag));
    return props.join(' ');
}
function stringify(item, ctx, onComment, onChompKeep) {
    if (identity.isPair(item))
        return item.toString(ctx, onComment, onChompKeep);
    if (identity.isAlias(item)) {
        if (ctx.doc.directives)
            return item.toString(ctx);
        if (ctx.resolvedAliases?.has(item)) {
            throw new TypeError(`Cannot stringify circular structure without alias nodes`);
        }
        else {
            if (ctx.resolvedAliases)
                ctx.resolvedAliases.add(item);
            else
                ctx.resolvedAliases = new Set([item]);
            item = item.resolve(ctx.doc);
        }
    }
    let tagObj = undefined;
    const node = identity.isNode(item)
        ? item
        : ctx.doc.createNode(item, { onTagObj: o => (tagObj = o) });
    tagObj ?? (tagObj = getTagObject(ctx.doc.schema.tags, node));
    const props = stringifyProps(node, tagObj, ctx);
    if (props.length > 0)
        ctx.indentAtStart = (ctx.indentAtStart ?? 0) + props.length + 1;
    const str = typeof tagObj.stringify === 'function'
        ? tagObj.stringify(node, ctx, onComment, onChompKeep)
        : identity.isScalar(node)
            ? stringifyString.stringifyString(node, ctx, onComment, onChompKeep)
            : node.toString(ctx, onComment, onChompKeep);
    if (!props)
        return str;
    return identity.isScalar(node) || str[0] === '{' || str[0] === '['
        ? `${props} ${str}`
        : `${props}\n${ctx.indent}${str}`;
}

exports.createStringifyContext = createStringifyContext;
exports.stringify = stringify;


/***/ }),
/* 67 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringifies a comment.
 *
 * Empty comment lines are left empty,
 * lines consisting of a single space are replaced by `#`,
 * and all other lines are prefixed with a `#`.
 */
const stringifyComment = (str) => str.replace(/^(?!$)(?: $)?/gm, '#');
function indentComment(comment, indent) {
    if (/^\n+$/.test(comment))
        return comment.substring(1);
    return indent ? comment.replace(/^(?! *$)/gm, indent) : comment;
}
const lineComment = (str, indent, comment) => str.endsWith('\n')
    ? indentComment(comment, indent)
    : comment.includes('\n')
        ? '\n' + indentComment(comment, indent)
        : (str.endsWith(' ') ? '' : ' ') + comment;

exports.indentComment = indentComment;
exports.lineComment = lineComment;
exports.stringifyComment = stringifyComment;


/***/ }),
/* 68 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var foldFlowLines = __webpack_require__(69);

const getFoldOptions = (ctx, isBlock) => ({
    indentAtStart: isBlock ? ctx.indent.length : ctx.indentAtStart,
    lineWidth: ctx.options.lineWidth,
    minContentWidth: ctx.options.minContentWidth
});
// Also checks for lines starting with %, as parsing the output as YAML 1.1 will
// presume that's starting a new document.
const containsDocumentMarker = (str) => /^(%|---|\.\.\.)/m.test(str);
function lineLengthOverLimit(str, lineWidth, indentLength) {
    if (!lineWidth || lineWidth < 0)
        return false;
    const limit = lineWidth - indentLength;
    const strLen = str.length;
    if (strLen <= limit)
        return false;
    for (let i = 0, start = 0; i < strLen; ++i) {
        if (str[i] === '\n') {
            if (i - start > limit)
                return true;
            start = i + 1;
            if (strLen - start <= limit)
                return false;
        }
    }
    return true;
}
function doubleQuotedString(value, ctx) {
    const json = JSON.stringify(value);
    if (ctx.options.doubleQuotedAsJSON)
        return json;
    const { implicitKey } = ctx;
    const minMultiLineLength = ctx.options.doubleQuotedMinMultiLineLength;
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    let str = '';
    let start = 0;
    for (let i = 0, ch = json[i]; ch; ch = json[++i]) {
        if (ch === ' ' && json[i + 1] === '\\' && json[i + 2] === 'n') {
            // space before newline needs to be escaped to not be folded
            str += json.slice(start, i) + '\\ ';
            i += 1;
            start = i;
            ch = '\\';
        }
        if (ch === '\\')
            switch (json[i + 1]) {
                case 'u':
                    {
                        str += json.slice(start, i);
                        const code = json.substr(i + 2, 4);
                        switch (code) {
                            case '0000':
                                str += '\\0';
                                break;
                            case '0007':
                                str += '\\a';
                                break;
                            case '000b':
                                str += '\\v';
                                break;
                            case '001b':
                                str += '\\e';
                                break;
                            case '0085':
                                str += '\\N';
                                break;
                            case '00a0':
                                str += '\\_';
                                break;
                            case '2028':
                                str += '\\L';
                                break;
                            case '2029':
                                str += '\\P';
                                break;
                            default:
                                if (code.substr(0, 2) === '00')
                                    str += '\\x' + code.substr(2);
                                else
                                    str += json.substr(i, 6);
                        }
                        i += 5;
                        start = i + 1;
                    }
                    break;
                case 'n':
                    if (implicitKey ||
                        json[i + 2] === '"' ||
                        json.length < minMultiLineLength) {
                        i += 1;
                    }
                    else {
                        // folding will eat first newline
                        str += json.slice(start, i) + '\n\n';
                        while (json[i + 2] === '\\' &&
                            json[i + 3] === 'n' &&
                            json[i + 4] !== '"') {
                            str += '\n';
                            i += 2;
                        }
                        str += indent;
                        // space after newline needs to be escaped to not be folded
                        if (json[i + 2] === ' ')
                            str += '\\';
                        i += 1;
                        start = i + 1;
                    }
                    break;
                default:
                    i += 1;
            }
    }
    str = start ? str + json.slice(start) : json;
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_QUOTED, getFoldOptions(ctx, false));
}
function singleQuotedString(value, ctx) {
    if (ctx.options.singleQuote === false ||
        (ctx.implicitKey && value.includes('\n')) ||
        /[ \t]\n|\n[ \t]/.test(value) // single quoted string can't have leading or trailing whitespace around newline
    )
        return doubleQuotedString(value, ctx);
    const indent = ctx.indent || (containsDocumentMarker(value) ? '  ' : '');
    const res = "'" + value.replace(/'/g, "''").replace(/\n+/g, `$&\n${indent}`) + "'";
    return ctx.implicitKey
        ? res
        : foldFlowLines.foldFlowLines(res, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
}
function quotedString(value, ctx) {
    const { singleQuote } = ctx.options;
    let qs;
    if (singleQuote === false)
        qs = doubleQuotedString;
    else {
        const hasDouble = value.includes('"');
        const hasSingle = value.includes("'");
        if (hasDouble && !hasSingle)
            qs = singleQuotedString;
        else if (hasSingle && !hasDouble)
            qs = doubleQuotedString;
        else
            qs = singleQuote ? singleQuotedString : doubleQuotedString;
    }
    return qs(value, ctx);
}
// The negative lookbehind avoids a polynomial search,
// but isn't supported yet on Safari: https://caniuse.com/js-regexp-lookbehind
let blockEndNewlines;
try {
    blockEndNewlines = new RegExp('(^|(?<!\n))\n+(?!\n|$)', 'g');
}
catch {
    blockEndNewlines = /\n+(?!\n|$)/g;
}
function blockString({ comment, type, value }, ctx, onComment, onChompKeep) {
    const { blockQuote, commentString, lineWidth } = ctx.options;
    // 1. Block can't end in whitespace unless the last line is non-empty.
    // 2. Strings consisting of only whitespace are best rendered explicitly.
    if (!blockQuote || /\n[\t ]+$/.test(value) || /^\s*$/.test(value)) {
        return quotedString(value, ctx);
    }
    const indent = ctx.indent ||
        (ctx.forceBlockIndent || containsDocumentMarker(value) ? '  ' : '');
    const literal = blockQuote === 'literal'
        ? true
        : blockQuote === 'folded' || type === Scalar.Scalar.BLOCK_FOLDED
            ? false
            : type === Scalar.Scalar.BLOCK_LITERAL
                ? true
                : !lineLengthOverLimit(value, lineWidth, indent.length);
    if (!value)
        return literal ? '|\n' : '>\n';
    // determine chomping from whitespace at value end
    let chomp;
    let endStart;
    for (endStart = value.length; endStart > 0; --endStart) {
        const ch = value[endStart - 1];
        if (ch !== '\n' && ch !== '\t' && ch !== ' ')
            break;
    }
    let end = value.substring(endStart);
    const endNlPos = end.indexOf('\n');
    if (endNlPos === -1) {
        chomp = '-'; // strip
    }
    else if (value === end || endNlPos !== end.length - 1) {
        chomp = '+'; // keep
        if (onChompKeep)
            onChompKeep();
    }
    else {
        chomp = ''; // clip
    }
    if (end) {
        value = value.slice(0, -end.length);
        if (end[end.length - 1] === '\n')
            end = end.slice(0, -1);
        end = end.replace(blockEndNewlines, `$&${indent}`);
    }
    // determine indent indicator from whitespace at value start
    let startWithSpace = false;
    let startEnd;
    let startNlPos = -1;
    for (startEnd = 0; startEnd < value.length; ++startEnd) {
        const ch = value[startEnd];
        if (ch === ' ')
            startWithSpace = true;
        else if (ch === '\n')
            startNlPos = startEnd;
        else
            break;
    }
    let start = value.substring(0, startNlPos < startEnd ? startNlPos + 1 : startEnd);
    if (start) {
        value = value.substring(start.length);
        start = start.replace(/\n+/g, `$&${indent}`);
    }
    const indentSize = indent ? '2' : '1'; // root is at -1
    // Leading | or > is added later
    let header = (startWithSpace ? indentSize : '') + chomp;
    if (comment) {
        header += ' ' + commentString(comment.replace(/ ?[\r\n]+/g, ' '));
        if (onComment)
            onComment();
    }
    if (!literal) {
        const foldedValue = value
            .replace(/\n+/g, '\n$&')
            .replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g, '$1$2') // more-indented lines aren't folded
            //                ^ more-ind. ^ empty     ^ capture next empty lines only at end of indent
            .replace(/\n+/g, `$&${indent}`);
        let literalFallback = false;
        const foldOptions = getFoldOptions(ctx, true);
        if (blockQuote !== 'folded' && type !== Scalar.Scalar.BLOCK_FOLDED) {
            foldOptions.onOverflow = () => {
                literalFallback = true;
            };
        }
        const body = foldFlowLines.foldFlowLines(`${start}${foldedValue}${end}`, indent, foldFlowLines.FOLD_BLOCK, foldOptions);
        if (!literalFallback)
            return `>${header}\n${indent}${body}`;
    }
    value = value.replace(/\n+/g, `$&${indent}`);
    return `|${header}\n${indent}${start}${value}${end}`;
}
function plainString(item, ctx, onComment, onChompKeep) {
    const { type, value } = item;
    const { actualString, implicitKey, indent, indentStep, inFlow } = ctx;
    if ((implicitKey && value.includes('\n')) ||
        (inFlow && /[[\]{},]/.test(value))) {
        return quotedString(value, ctx);
    }
    if (/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(value)) {
        // not allowed:
        // - '-' or '?'
        // - start with an indicator character (except [?:-]) or /[?-] /
        // - '\n ', ': ' or ' \n' anywhere
        // - '#' not preceded by a non-space char
        // - end with ' ' or ':'
        return implicitKey || inFlow || !value.includes('\n')
            ? quotedString(value, ctx)
            : blockString(item, ctx, onComment, onChompKeep);
    }
    if (!implicitKey &&
        !inFlow &&
        type !== Scalar.Scalar.PLAIN &&
        value.includes('\n')) {
        // Where allowed & type not set explicitly, prefer block style for multiline strings
        return blockString(item, ctx, onComment, onChompKeep);
    }
    if (containsDocumentMarker(value)) {
        if (indent === '') {
            ctx.forceBlockIndent = true;
            return blockString(item, ctx, onComment, onChompKeep);
        }
        else if (implicitKey && indent === indentStep) {
            return quotedString(value, ctx);
        }
    }
    const str = value.replace(/\n+/g, `$&\n${indent}`);
    // Verify that output will be parsed as a string, as e.g. plain numbers and
    // booleans get parsed with those types in v1.2 (e.g. '42', 'true' & '0.9e-3'),
    // and others in v1.1.
    if (actualString) {
        const test = (tag) => tag.default && tag.tag !== 'tag:yaml.org,2002:str' && tag.test?.test(str);
        const { compat, tags } = ctx.doc.schema;
        if (tags.some(test) || compat?.some(test))
            return quotedString(value, ctx);
    }
    return implicitKey
        ? str
        : foldFlowLines.foldFlowLines(str, indent, foldFlowLines.FOLD_FLOW, getFoldOptions(ctx, false));
}
function stringifyString(item, ctx, onComment, onChompKeep) {
    const { implicitKey, inFlow } = ctx;
    const ss = typeof item.value === 'string'
        ? item
        : Object.assign({}, item, { value: String(item.value) });
    let { type } = item;
    if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
        // force double quotes on control characters & unpaired surrogates
        if (/[\x00-\x08\x0b-\x1f\x7f-\x9f\u{D800}-\u{DFFF}]/u.test(ss.value))
            type = Scalar.Scalar.QUOTE_DOUBLE;
    }
    const _stringify = (_type) => {
        switch (_type) {
            case Scalar.Scalar.BLOCK_FOLDED:
            case Scalar.Scalar.BLOCK_LITERAL:
                return implicitKey || inFlow
                    ? quotedString(ss.value, ctx) // blocks are not valid inside flow containers
                    : blockString(ss, ctx, onComment, onChompKeep);
            case Scalar.Scalar.QUOTE_DOUBLE:
                return doubleQuotedString(ss.value, ctx);
            case Scalar.Scalar.QUOTE_SINGLE:
                return singleQuotedString(ss.value, ctx);
            case Scalar.Scalar.PLAIN:
                return plainString(ss, ctx, onComment, onChompKeep);
            default:
                return null;
        }
    };
    let res = _stringify(type);
    if (res === null) {
        const { defaultKeyType, defaultStringType } = ctx.options;
        const t = (implicitKey && defaultKeyType) || defaultStringType;
        res = _stringify(t);
        if (res === null)
            throw new Error(`Unsupported default string type ${t}`);
    }
    return res;
}

exports.stringifyString = stringifyString;


/***/ }),
/* 69 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const FOLD_FLOW = 'flow';
const FOLD_BLOCK = 'block';
const FOLD_QUOTED = 'quoted';
/**
 * Tries to keep input at up to `lineWidth` characters, splitting only on spaces
 * not followed by newlines or spaces unless `mode` is `'quoted'`. Lines are
 * terminated with `\n` and started with `indent`.
 */
function foldFlowLines(text, indent, mode = 'flow', { indentAtStart, lineWidth = 80, minContentWidth = 20, onFold, onOverflow } = {}) {
    if (!lineWidth || lineWidth < 0)
        return text;
    if (lineWidth < minContentWidth)
        minContentWidth = 0;
    const endStep = Math.max(1 + minContentWidth, 1 + lineWidth - indent.length);
    if (text.length <= endStep)
        return text;
    const folds = [];
    const escapedFolds = {};
    let end = lineWidth - indent.length;
    if (typeof indentAtStart === 'number') {
        if (indentAtStart > lineWidth - Math.max(2, minContentWidth))
            folds.push(0);
        else
            end = lineWidth - indentAtStart;
    }
    let split = undefined;
    let prev = undefined;
    let overflow = false;
    let i = -1;
    let escStart = -1;
    let escEnd = -1;
    if (mode === FOLD_BLOCK) {
        i = consumeMoreIndentedLines(text, i, indent.length);
        if (i !== -1)
            end = i + endStep;
    }
    for (let ch; (ch = text[(i += 1)]);) {
        if (mode === FOLD_QUOTED && ch === '\\') {
            escStart = i;
            switch (text[i + 1]) {
                case 'x':
                    i += 3;
                    break;
                case 'u':
                    i += 5;
                    break;
                case 'U':
                    i += 9;
                    break;
                default:
                    i += 1;
            }
            escEnd = i;
        }
        if (ch === '\n') {
            if (mode === FOLD_BLOCK)
                i = consumeMoreIndentedLines(text, i, indent.length);
            end = i + indent.length + endStep;
            split = undefined;
        }
        else {
            if (ch === ' ' &&
                prev &&
                prev !== ' ' &&
                prev !== '\n' &&
                prev !== '\t') {
                // space surrounded by non-space can be replaced with newline + indent
                const next = text[i + 1];
                if (next && next !== ' ' && next !== '\n' && next !== '\t')
                    split = i;
            }
            if (i >= end) {
                if (split) {
                    folds.push(split);
                    end = split + endStep;
                    split = undefined;
                }
                else if (mode === FOLD_QUOTED) {
                    // white-space collected at end may stretch past lineWidth
                    while (prev === ' ' || prev === '\t') {
                        prev = ch;
                        ch = text[(i += 1)];
                        overflow = true;
                    }
                    // Account for newline escape, but don't break preceding escape
                    const j = i > escEnd + 1 ? i - 2 : escStart - 1;
                    // Bail out if lineWidth & minContentWidth are shorter than an escape string
                    if (escapedFolds[j])
                        return text;
                    folds.push(j);
                    escapedFolds[j] = true;
                    end = j + endStep;
                    split = undefined;
                }
                else {
                    overflow = true;
                }
            }
        }
        prev = ch;
    }
    if (overflow && onOverflow)
        onOverflow();
    if (folds.length === 0)
        return text;
    if (onFold)
        onFold();
    let res = text.slice(0, folds[0]);
    for (let i = 0; i < folds.length; ++i) {
        const fold = folds[i];
        const end = folds[i + 1] || text.length;
        if (fold === 0)
            res = `\n${indent}${text.slice(0, end)}`;
        else {
            if (mode === FOLD_QUOTED && escapedFolds[fold])
                res += `${text[fold]}\\`;
            res += `\n${indent}${text.slice(fold + 1, end)}`;
        }
    }
    return res;
}
/**
 * Presumes `i + 1` is at the start of a line
 * @returns index of last newline in more-indented block
 */
function consumeMoreIndentedLines(text, i, indent) {
    let end = i;
    let start = i + 1;
    let ch = text[start];
    while (ch === ' ' || ch === '\t') {
        if (i < start + indent) {
            ch = text[++i];
        }
        else {
            do {
                ch = text[++i];
            } while (ch && ch !== '\n');
            end = i;
            start = i + 1;
            ch = text[start];
        }
    }
    return end;
}

exports.FOLD_BLOCK = FOLD_BLOCK;
exports.FOLD_FLOW = FOLD_FLOW;
exports.FOLD_QUOTED = FOLD_QUOTED;
exports.foldFlowLines = foldFlowLines;


/***/ }),
/* 70 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var log = __webpack_require__(71);
var merge = __webpack_require__(72);
var stringify = __webpack_require__(66);
var identity = __webpack_require__(53);
var toJS = __webpack_require__(60);

function addPairToJSMap(ctx, map, { key, value }) {
    if (identity.isNode(key) && key.addToJSMap)
        key.addToJSMap(ctx, map, value);
    // TODO: Should drop this special case for bare << handling
    else if (merge.isMergeKey(ctx, key))
        merge.addMergeToJSMap(ctx, map, value);
    else {
        const jsKey = toJS.toJS(key, '', ctx);
        if (map instanceof Map) {
            map.set(jsKey, toJS.toJS(value, jsKey, ctx));
        }
        else if (map instanceof Set) {
            map.add(jsKey);
        }
        else {
            const stringKey = stringifyKey(key, jsKey, ctx);
            const jsValue = toJS.toJS(value, stringKey, ctx);
            if (stringKey in map)
                Object.defineProperty(map, stringKey, {
                    value: jsValue,
                    writable: true,
                    enumerable: true,
                    configurable: true
                });
            else
                map[stringKey] = jsValue;
        }
    }
    return map;
}
function stringifyKey(key, jsKey, ctx) {
    if (jsKey === null)
        return '';
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    if (typeof jsKey !== 'object')
        return String(jsKey);
    if (identity.isNode(key) && ctx?.doc) {
        const strCtx = stringify.createStringifyContext(ctx.doc, {});
        strCtx.anchors = new Set();
        for (const node of ctx.anchors.keys())
            strCtx.anchors.add(node.anchor);
        strCtx.inFlow = true;
        strCtx.inStringifyKey = true;
        const strKey = key.toString(strCtx);
        if (!ctx.mapKeyWarned) {
            let jsonStr = JSON.stringify(strKey);
            if (jsonStr.length > 40)
                jsonStr = jsonStr.substring(0, 36) + '..."';
            log.warn(ctx.doc.options.logLevel, `Keys with collection values will be stringified due to JS Object restrictions: ${jsonStr}. Set mapAsMap: true to use object keys.`);
            ctx.mapKeyWarned = true;
        }
        return strKey;
    }
    return JSON.stringify(jsKey);
}

exports.addPairToJSMap = addPairToJSMap;


/***/ }),
/* 71 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var node_process = __webpack_require__(51);

function debug(logLevel, ...messages) {
    if (logLevel === 'debug')
        console.log(...messages);
}
function warn(logLevel, warning) {
    if (logLevel === 'debug' || logLevel === 'warn') {
        if (typeof node_process.emitWarning === 'function')
            node_process.emitWarning(warning);
        else
            console.warn(warning);
    }
}

exports.debug = debug;
exports.warn = warn;


/***/ }),
/* 72 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);

// If the value associated with a merge key is a single mapping node, each of
// its key/value pairs is inserted into the current mapping, unless the key
// already exists in it. If the value associated with the merge key is a
// sequence, then this sequence is expected to contain mapping nodes and each
// of these nodes is merged in turn according to its order in the sequence.
// Keys in mapping nodes earlier in the sequence override keys specified in
// later mapping nodes. -- http://yaml.org/type/merge.html
const MERGE_KEY = '<<';
const merge = {
    identify: value => value === MERGE_KEY ||
        (typeof value === 'symbol' && value.description === MERGE_KEY),
    default: 'key',
    tag: 'tag:yaml.org,2002:merge',
    test: /^<<$/,
    resolve: () => Object.assign(new Scalar.Scalar(Symbol(MERGE_KEY)), {
        addToJSMap: addMergeToJSMap
    }),
    stringify: () => MERGE_KEY
};
const isMergeKey = (ctx, key) => (merge.identify(key) ||
    (identity.isScalar(key) &&
        (!key.type || key.type === Scalar.Scalar.PLAIN) &&
        merge.identify(key.value))) &&
    ctx?.doc.schema.tags.some(tag => tag.tag === merge.tag && tag.default);
function addMergeToJSMap(ctx, map, value) {
    value = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (identity.isSeq(value))
        for (const it of value.items)
            mergeValue(ctx, map, it);
    else if (Array.isArray(value))
        for (const it of value)
            mergeValue(ctx, map, it);
    else
        mergeValue(ctx, map, value);
}
function mergeValue(ctx, map, value) {
    const source = ctx && identity.isAlias(value) ? value.resolve(ctx.doc) : value;
    if (!identity.isMap(source))
        throw new Error('Merge sources must be maps or map aliases');
    const srcMap = source.toJSON(null, ctx, Map);
    for (const [key, value] of srcMap) {
        if (map instanceof Map) {
            if (!map.has(key))
                map.set(key, value);
        }
        else if (map instanceof Set) {
            map.add(key);
        }
        else if (!Object.prototype.hasOwnProperty.call(map, key)) {
            Object.defineProperty(map, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true
            });
        }
    }
    return map;
}

exports.addMergeToJSMap = addMergeToJSMap;
exports.isMergeKey = isMergeKey;
exports.merge = merge;


/***/ }),
/* 73 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var map = __webpack_require__(74);
var seq = __webpack_require__(77);
var string = __webpack_require__(79);
var tags = __webpack_require__(80);

const sortMapEntriesByKey = (a, b) => a.key < b.key ? -1 : a.key > b.key ? 1 : 0;
class Schema {
    constructor({ compat, customTags, merge, resolveKnownTags, schema, sortMapEntries, toStringDefaults }) {
        this.compat = Array.isArray(compat)
            ? tags.getTags(compat, 'compat')
            : compat
                ? tags.getTags(null, compat)
                : null;
        this.name = (typeof schema === 'string' && schema) || 'core';
        this.knownTags = resolveKnownTags ? tags.coreKnownTags : {};
        this.tags = tags.getTags(customTags, this.name, merge);
        this.toStringOptions = toStringDefaults ?? null;
        Object.defineProperty(this, identity.MAP, { value: map.map });
        Object.defineProperty(this, identity.SCALAR, { value: string.string });
        Object.defineProperty(this, identity.SEQ, { value: seq.seq });
        // Used by createMap()
        this.sortMapEntries =
            typeof sortMapEntries === 'function'
                ? sortMapEntries
                : sortMapEntries === true
                    ? sortMapEntriesByKey
                    : null;
    }
    clone() {
        const copy = Object.create(Schema.prototype, Object.getOwnPropertyDescriptors(this));
        copy.tags = this.tags.slice();
        return copy;
    }
}

exports.Schema = Schema;


/***/ }),
/* 74 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var YAMLMap = __webpack_require__(75);

const map = {
    collection: 'map',
    default: true,
    nodeClass: YAMLMap.YAMLMap,
    tag: 'tag:yaml.org,2002:map',
    resolve(map, onError) {
        if (!identity.isMap(map))
            onError('Expected a mapping for this tag');
        return map;
    },
    createNode: (schema, obj, ctx) => YAMLMap.YAMLMap.from(schema, obj, ctx)
};

exports.map = map;


/***/ }),
/* 75 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyCollection = __webpack_require__(76);
var addPairToJSMap = __webpack_require__(70);
var Collection = __webpack_require__(61);
var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var Scalar = __webpack_require__(63);

function findPair(items, key) {
    const k = identity.isScalar(key) ? key.value : key;
    for (const it of items) {
        if (identity.isPair(it)) {
            if (it.key === key || it.key === k)
                return it;
            if (identity.isScalar(it.key) && it.key.value === k)
                return it;
        }
    }
    return undefined;
}
class YAMLMap extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:map';
    }
    constructor(schema) {
        super(identity.MAP, schema);
        this.items = [];
    }
    /**
     * A generic collection parsing method that can be extended
     * to other node classes that inherit from YAMLMap
     */
    static from(schema, obj, ctx) {
        const { keepUndefined, replacer } = ctx;
        const map = new this(schema);
        const add = (key, value) => {
            if (typeof replacer === 'function')
                value = replacer.call(obj, key, value);
            else if (Array.isArray(replacer) && !replacer.includes(key))
                return;
            if (value !== undefined || keepUndefined)
                map.items.push(Pair.createPair(key, value, ctx));
        };
        if (obj instanceof Map) {
            for (const [key, value] of obj)
                add(key, value);
        }
        else if (obj && typeof obj === 'object') {
            for (const key of Object.keys(obj))
                add(key, obj[key]);
        }
        if (typeof schema.sortMapEntries === 'function') {
            map.items.sort(schema.sortMapEntries);
        }
        return map;
    }
    /**
     * Adds a value to the collection.
     *
     * @param overwrite - If not set `true`, using a key that is already in the
     *   collection will throw. Otherwise, overwrites the previous value.
     */
    add(pair, overwrite) {
        let _pair;
        if (identity.isPair(pair))
            _pair = pair;
        else if (!pair || typeof pair !== 'object' || !('key' in pair)) {
            // In TypeScript, this never happens.
            _pair = new Pair.Pair(pair, pair?.value);
        }
        else
            _pair = new Pair.Pair(pair.key, pair.value);
        const prev = findPair(this.items, _pair.key);
        const sortEntries = this.schema?.sortMapEntries;
        if (prev) {
            if (!overwrite)
                throw new Error(`Key ${_pair.key} already set`);
            // For scalars, keep the old node & its comments and anchors
            if (identity.isScalar(prev.value) && Scalar.isScalarValue(_pair.value))
                prev.value.value = _pair.value;
            else
                prev.value = _pair.value;
        }
        else if (sortEntries) {
            const i = this.items.findIndex(item => sortEntries(_pair, item) < 0);
            if (i === -1)
                this.items.push(_pair);
            else
                this.items.splice(i, 0, _pair);
        }
        else {
            this.items.push(_pair);
        }
    }
    delete(key) {
        const it = findPair(this.items, key);
        if (!it)
            return false;
        const del = this.items.splice(this.items.indexOf(it), 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const it = findPair(this.items, key);
        const node = it?.value;
        return (!keepScalar && identity.isScalar(node) ? node.value : node) ?? undefined;
    }
    has(key) {
        return !!findPair(this.items, key);
    }
    set(key, value) {
        this.add(new Pair.Pair(key, value), true);
    }
    /**
     * @param ctx - Conversion context, originally set in Document#toJS()
     * @param {Class} Type - If set, forces the returned collection type
     * @returns Instance of Type, Map, or Object
     */
    toJSON(_, ctx, Type) {
        const map = Type ? new Type() : ctx?.mapAsMap ? new Map() : {};
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const item of this.items)
            addPairToJSMap.addPairToJSMap(ctx, map, item);
        return map;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        for (const item of this.items) {
            if (!identity.isPair(item))
                throw new Error(`Map items must all be pairs; found ${JSON.stringify(item)} instead`);
        }
        if (!ctx.allNullValues && this.hasAllNullValues(false))
            ctx = Object.assign({}, ctx, { allNullValues: true });
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '',
            flowChars: { start: '{', end: '}' },
            itemIndent: ctx.indent || '',
            onChompKeep,
            onComment
        });
    }
}

exports.YAMLMap = YAMLMap;
exports.findPair = findPair;


/***/ }),
/* 76 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var stringify = __webpack_require__(66);
var stringifyComment = __webpack_require__(67);

function stringifyCollection(collection, ctx, options) {
    const flow = ctx.inFlow ?? collection.flow;
    const stringify = flow ? stringifyFlowCollection : stringifyBlockCollection;
    return stringify(collection, ctx, options);
}
function stringifyBlockCollection({ comment, items }, ctx, { blockItemPrefix, flowChars, itemIndent, onChompKeep, onComment }) {
    const { indent, options: { commentString } } = ctx;
    const itemCtx = Object.assign({}, ctx, { indent: itemIndent, type: null });
    let chompKeep = false; // flag for the preceding node's status
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (!chompKeep && item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, chompKeep);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (!chompKeep && ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, chompKeep);
            }
        }
        chompKeep = false;
        let str = stringify.stringify(item, itemCtx, () => (comment = null), () => (chompKeep = true));
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (chompKeep && comment)
            chompKeep = false;
        lines.push(blockItemPrefix + str);
    }
    let str;
    if (lines.length === 0) {
        str = flowChars.start + flowChars.end;
    }
    else {
        str = lines[0];
        for (let i = 1; i < lines.length; ++i) {
            const line = lines[i];
            str += line ? `\n${indent}${line}` : '\n';
        }
    }
    if (comment) {
        str += '\n' + stringifyComment.indentComment(commentString(comment), indent);
        if (onComment)
            onComment();
    }
    else if (chompKeep && onChompKeep)
        onChompKeep();
    return str;
}
function stringifyFlowCollection({ items }, ctx, { flowChars, itemIndent }) {
    const { indent, indentStep, flowCollectionPadding: fcPadding, options: { commentString } } = ctx;
    itemIndent += indentStep;
    const itemCtx = Object.assign({}, ctx, {
        indent: itemIndent,
        inFlow: true,
        type: null
    });
    let reqNewline = false;
    let linesAtValue = 0;
    const lines = [];
    for (let i = 0; i < items.length; ++i) {
        const item = items[i];
        let comment = null;
        if (identity.isNode(item)) {
            if (item.spaceBefore)
                lines.push('');
            addCommentBefore(ctx, lines, item.commentBefore, false);
            if (item.comment)
                comment = item.comment;
        }
        else if (identity.isPair(item)) {
            const ik = identity.isNode(item.key) ? item.key : null;
            if (ik) {
                if (ik.spaceBefore)
                    lines.push('');
                addCommentBefore(ctx, lines, ik.commentBefore, false);
                if (ik.comment)
                    reqNewline = true;
            }
            const iv = identity.isNode(item.value) ? item.value : null;
            if (iv) {
                if (iv.comment)
                    comment = iv.comment;
                if (iv.commentBefore)
                    reqNewline = true;
            }
            else if (item.value == null && ik?.comment) {
                comment = ik.comment;
            }
        }
        if (comment)
            reqNewline = true;
        let str = stringify.stringify(item, itemCtx, () => (comment = null));
        if (i < items.length - 1)
            str += ',';
        if (comment)
            str += stringifyComment.lineComment(str, itemIndent, commentString(comment));
        if (!reqNewline && (lines.length > linesAtValue || str.includes('\n')))
            reqNewline = true;
        lines.push(str);
        linesAtValue = lines.length;
    }
    const { start, end } = flowChars;
    if (lines.length === 0) {
        return start + end;
    }
    else {
        if (!reqNewline) {
            const len = lines.reduce((sum, line) => sum + line.length + 2, 2);
            reqNewline = ctx.options.lineWidth > 0 && len > ctx.options.lineWidth;
        }
        if (reqNewline) {
            let str = start;
            for (const line of lines)
                str += line ? `\n${indentStep}${indent}${line}` : '\n';
            return `${str}\n${indent}${end}`;
        }
        else {
            return `${start}${fcPadding}${lines.join(' ')}${fcPadding}${end}`;
        }
    }
}
function addCommentBefore({ indent, options: { commentString } }, lines, comment, chompKeep) {
    if (comment && chompKeep)
        comment = comment.replace(/^\n+/, '');
    if (comment) {
        const ic = stringifyComment.indentComment(commentString(comment), indent);
        lines.push(ic.trimStart()); // Avoid double indent on first line
    }
}

exports.stringifyCollection = stringifyCollection;


/***/ }),
/* 77 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var YAMLSeq = __webpack_require__(78);

const seq = {
    collection: 'seq',
    default: true,
    nodeClass: YAMLSeq.YAMLSeq,
    tag: 'tag:yaml.org,2002:seq',
    resolve(seq, onError) {
        if (!identity.isSeq(seq))
            onError('Expected a sequence for this tag');
        return seq;
    },
    createNode: (schema, obj, ctx) => YAMLSeq.YAMLSeq.from(schema, obj, ctx)
};

exports.seq = seq;


/***/ }),
/* 78 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var createNode = __webpack_require__(62);
var stringifyCollection = __webpack_require__(76);
var Collection = __webpack_require__(61);
var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);
var toJS = __webpack_require__(60);

class YAMLSeq extends Collection.Collection {
    static get tagName() {
        return 'tag:yaml.org,2002:seq';
    }
    constructor(schema) {
        super(identity.SEQ, schema);
        this.items = [];
    }
    add(value) {
        this.items.push(value);
    }
    /**
     * Removes a value from the collection.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     *
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return false;
        const del = this.items.splice(idx, 1);
        return del.length > 0;
    }
    get(key, keepScalar) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            return undefined;
        const it = this.items[idx];
        return !keepScalar && identity.isScalar(it) ? it.value : it;
    }
    /**
     * Checks if the collection includes a value with the key `key`.
     *
     * `key` must contain a representation of an integer for this to succeed.
     * It may be wrapped in a `Scalar`.
     */
    has(key) {
        const idx = asItemIndex(key);
        return typeof idx === 'number' && idx < this.items.length;
    }
    /**
     * Sets a value in this collection. For `!!set`, `value` needs to be a
     * boolean to add/remove the item from the set.
     *
     * If `key` does not contain a representation of an integer, this will throw.
     * It may be wrapped in a `Scalar`.
     */
    set(key, value) {
        const idx = asItemIndex(key);
        if (typeof idx !== 'number')
            throw new Error(`Expected a valid index, not ${key}.`);
        const prev = this.items[idx];
        if (identity.isScalar(prev) && Scalar.isScalarValue(value))
            prev.value = value;
        else
            this.items[idx] = value;
    }
    toJSON(_, ctx) {
        const seq = [];
        if (ctx?.onCreate)
            ctx.onCreate(seq);
        let i = 0;
        for (const item of this.items)
            seq.push(toJS.toJS(item, String(i++), ctx));
        return seq;
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        return stringifyCollection.stringifyCollection(this, ctx, {
            blockItemPrefix: '- ',
            flowChars: { start: '[', end: ']' },
            itemIndent: (ctx.indent || '') + '  ',
            onChompKeep,
            onComment
        });
    }
    static from(schema, obj, ctx) {
        const { replacer } = ctx;
        const seq = new this(schema);
        if (obj && Symbol.iterator in Object(obj)) {
            let i = 0;
            for (let it of obj) {
                if (typeof replacer === 'function') {
                    const key = obj instanceof Set ? it : String(i++);
                    it = replacer.call(obj, key, it);
                }
                seq.items.push(createNode.createNode(it, undefined, ctx));
            }
        }
        return seq;
    }
}
function asItemIndex(key) {
    let idx = identity.isScalar(key) ? key.value : key;
    if (idx && typeof idx === 'string')
        idx = Number(idx);
    return typeof idx === 'number' && Number.isInteger(idx) && idx >= 0
        ? idx
        : null;
}

exports.YAMLSeq = YAMLSeq;


/***/ }),
/* 79 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyString = __webpack_require__(68);

const string = {
    identify: value => typeof value === 'string',
    default: true,
    tag: 'tag:yaml.org,2002:str',
    resolve: str => str,
    stringify(item, ctx, onComment, onChompKeep) {
        ctx = Object.assign({ actualString: true }, ctx);
        return stringifyString.stringifyString(item, ctx, onComment, onChompKeep);
    }
};

exports.string = string;


/***/ }),
/* 80 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(74);
var _null = __webpack_require__(81);
var seq = __webpack_require__(77);
var string = __webpack_require__(79);
var bool = __webpack_require__(82);
var float = __webpack_require__(83);
var int = __webpack_require__(85);
var schema = __webpack_require__(86);
var schema$1 = __webpack_require__(87);
var binary = __webpack_require__(88);
var merge = __webpack_require__(72);
var omap = __webpack_require__(90);
var pairs = __webpack_require__(91);
var schema$2 = __webpack_require__(92);
var set = __webpack_require__(96);
var timestamp = __webpack_require__(97);

const schemas = new Map([
    ['core', schema.schema],
    ['failsafe', [map.map, seq.seq, string.string]],
    ['json', schema$1.schema],
    ['yaml11', schema$2.schema],
    ['yaml-1.1', schema$2.schema]
]);
const tagsByName = {
    binary: binary.binary,
    bool: bool.boolTag,
    float: float.float,
    floatExp: float.floatExp,
    floatNaN: float.floatNaN,
    floatTime: timestamp.floatTime,
    int: int.int,
    intHex: int.intHex,
    intOct: int.intOct,
    intTime: timestamp.intTime,
    map: map.map,
    merge: merge.merge,
    null: _null.nullTag,
    omap: omap.omap,
    pairs: pairs.pairs,
    seq: seq.seq,
    set: set.set,
    timestamp: timestamp.timestamp
};
const coreKnownTags = {
    'tag:yaml.org,2002:binary': binary.binary,
    'tag:yaml.org,2002:merge': merge.merge,
    'tag:yaml.org,2002:omap': omap.omap,
    'tag:yaml.org,2002:pairs': pairs.pairs,
    'tag:yaml.org,2002:set': set.set,
    'tag:yaml.org,2002:timestamp': timestamp.timestamp
};
function getTags(customTags, schemaName, addMergeTag) {
    const schemaTags = schemas.get(schemaName);
    if (schemaTags && !customTags) {
        return addMergeTag && !schemaTags.includes(merge.merge)
            ? schemaTags.concat(merge.merge)
            : schemaTags.slice();
    }
    let tags = schemaTags;
    if (!tags) {
        if (Array.isArray(customTags))
            tags = [];
        else {
            const keys = Array.from(schemas.keys())
                .filter(key => key !== 'yaml11')
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown schema "${schemaName}"; use one of ${keys} or define customTags array`);
        }
    }
    if (Array.isArray(customTags)) {
        for (const tag of customTags)
            tags = tags.concat(tag);
    }
    else if (typeof customTags === 'function') {
        tags = customTags(tags.slice());
    }
    if (addMergeTag)
        tags = tags.concat(merge.merge);
    return tags.reduce((tags, tag) => {
        const tagObj = typeof tag === 'string' ? tagsByName[tag] : tag;
        if (!tagObj) {
            const tagName = JSON.stringify(tag);
            const keys = Object.keys(tagsByName)
                .map(key => JSON.stringify(key))
                .join(', ');
            throw new Error(`Unknown custom tag ${tagName}; use one of ${keys}`);
        }
        if (!tags.includes(tagObj))
            tags.push(tagObj);
        return tags;
    }, []);
}

exports.coreKnownTags = coreKnownTags;
exports.getTags = getTags;


/***/ }),
/* 81 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);

const nullTag = {
    identify: value => value == null,
    createNode: () => new Scalar.Scalar(null),
    default: true,
    tag: 'tag:yaml.org,2002:null',
    test: /^(?:~|[Nn]ull|NULL)?$/,
    resolve: () => new Scalar.Scalar(null),
    stringify: ({ source }, ctx) => typeof source === 'string' && nullTag.test.test(source)
        ? source
        : ctx.options.nullStr
};

exports.nullTag = nullTag;


/***/ }),
/* 82 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);

const boolTag = {
    identify: value => typeof value === 'boolean',
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,
    resolve: str => new Scalar.Scalar(str[0] === 't' || str[0] === 'T'),
    stringify({ source, value }, ctx) {
        if (source && boolTag.test.test(source)) {
            const sv = source[0] === 't' || source[0] === 'T';
            if (value === sv)
                return source;
        }
        return value ? ctx.options.trueStr : ctx.options.falseStr;
    }
};

exports.boolTag = boolTag;


/***/ }),
/* 83 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var stringifyNumber = __webpack_require__(84);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: str => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)[eE][-+]?[0-9]+$/,
    resolve: str => parseFloat(str),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:\.[0-9]+|[0-9]+\.[0-9]*)$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str));
        const dot = str.indexOf('.');
        if (dot !== -1 && str[str.length - 1] === '0')
            node.minFractionDigits = str.length - dot - 1;
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),
/* 84 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function stringifyNumber({ format, minFractionDigits, tag, value }) {
    if (typeof value === 'bigint')
        return String(value);
    const num = typeof value === 'number' ? value : Number(value);
    if (!isFinite(num))
        return isNaN(num) ? '.nan' : num < 0 ? '-.inf' : '.inf';
    let n = JSON.stringify(value);
    if (!format &&
        minFractionDigits &&
        (!tag || tag === 'tag:yaml.org,2002:float') &&
        /^\d/.test(n)) {
        let i = n.indexOf('.');
        if (i < 0) {
            i = n.length;
            n += '.';
        }
        let d = minFractionDigits - (n.length - i - 1);
        while (d-- > 0)
            n += '0';
    }
    return n;
}

exports.stringifyNumber = stringifyNumber;


/***/ }),
/* 85 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(84);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
const intResolve = (str, offset, radix, { intAsBigInt }) => (intAsBigInt ? BigInt(str) : parseInt(str.substring(offset), radix));
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value) && value >= 0)
        return prefix + value.toString(radix);
    return stringifyNumber.stringifyNumber(node);
}
const intOct = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^0o[0-7]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 8, opt),
    stringify: node => intStringify(node, 8, '0o')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: value => intIdentify(value) && value >= 0,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^0x[0-9a-fA-F]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),
/* 86 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(74);
var _null = __webpack_require__(81);
var seq = __webpack_require__(77);
var string = __webpack_require__(79);
var bool = __webpack_require__(82);
var float = __webpack_require__(83);
var int = __webpack_require__(85);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.boolTag,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float
];

exports.schema = schema;


/***/ }),
/* 87 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var map = __webpack_require__(74);
var seq = __webpack_require__(77);

function intIdentify(value) {
    return typeof value === 'bigint' || Number.isInteger(value);
}
const stringifyJSON = ({ value }) => JSON.stringify(value);
const jsonScalars = [
    {
        identify: value => typeof value === 'string',
        default: true,
        tag: 'tag:yaml.org,2002:str',
        resolve: str => str,
        stringify: stringifyJSON
    },
    {
        identify: value => value == null,
        createNode: () => new Scalar.Scalar(null),
        default: true,
        tag: 'tag:yaml.org,2002:null',
        test: /^null$/,
        resolve: () => null,
        stringify: stringifyJSON
    },
    {
        identify: value => typeof value === 'boolean',
        default: true,
        tag: 'tag:yaml.org,2002:bool',
        test: /^true$|^false$/,
        resolve: str => str === 'true',
        stringify: stringifyJSON
    },
    {
        identify: intIdentify,
        default: true,
        tag: 'tag:yaml.org,2002:int',
        test: /^-?(?:0|[1-9][0-9]*)$/,
        resolve: (str, _onError, { intAsBigInt }) => intAsBigInt ? BigInt(str) : parseInt(str, 10),
        stringify: ({ value }) => intIdentify(value) ? value.toString() : JSON.stringify(value)
    },
    {
        identify: value => typeof value === 'number',
        default: true,
        tag: 'tag:yaml.org,2002:float',
        test: /^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,
        resolve: str => parseFloat(str),
        stringify: stringifyJSON
    }
];
const jsonError = {
    default: true,
    tag: '',
    test: /^/,
    resolve(str, onError) {
        onError(`Unresolved plain scalar ${JSON.stringify(str)}`);
        return str;
    }
};
const schema = [map.map, seq.seq].concat(jsonScalars, jsonError);

exports.schema = schema;


/***/ }),
/* 88 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var node_buffer = __webpack_require__(89);
var Scalar = __webpack_require__(63);
var stringifyString = __webpack_require__(68);

const binary = {
    identify: value => value instanceof Uint8Array, // Buffer inherits from Uint8Array
    default: false,
    tag: 'tag:yaml.org,2002:binary',
    /**
     * Returns a Buffer in node and an Uint8Array in browsers
     *
     * To use the resulting buffer as an image, you'll want to do something like:
     *
     *   const blob = new Blob([buffer], { type: 'image/jpeg' })
     *   document.querySelector('#photo').src = URL.createObjectURL(blob)
     */
    resolve(src, onError) {
        if (typeof node_buffer.Buffer === 'function') {
            return node_buffer.Buffer.from(src, 'base64');
        }
        else if (typeof atob === 'function') {
            // On IE 11, atob() can't handle newlines
            const str = atob(src.replace(/[\n\r]/g, ''));
            const buffer = new Uint8Array(str.length);
            for (let i = 0; i < str.length; ++i)
                buffer[i] = str.charCodeAt(i);
            return buffer;
        }
        else {
            onError('This environment does not support reading binary tags; either Buffer or atob is required');
            return src;
        }
    },
    stringify({ comment, type, value }, ctx, onComment, onChompKeep) {
        if (!value)
            return '';
        const buf = value; // checked earlier by binary.identify()
        let str;
        if (typeof node_buffer.Buffer === 'function') {
            str =
                buf instanceof node_buffer.Buffer
                    ? buf.toString('base64')
                    : node_buffer.Buffer.from(buf.buffer).toString('base64');
        }
        else if (typeof btoa === 'function') {
            let s = '';
            for (let i = 0; i < buf.length; ++i)
                s += String.fromCharCode(buf[i]);
            str = btoa(s);
        }
        else {
            throw new Error('This environment does not support writing binary tags; either Buffer or btoa is required');
        }
        type ?? (type = Scalar.Scalar.BLOCK_LITERAL);
        if (type !== Scalar.Scalar.QUOTE_DOUBLE) {
            const lineWidth = Math.max(ctx.options.lineWidth - ctx.indent.length, ctx.options.minContentWidth);
            const n = Math.ceil(str.length / lineWidth);
            const lines = new Array(n);
            for (let i = 0, o = 0; i < n; ++i, o += lineWidth) {
                lines[i] = str.substr(o, lineWidth);
            }
            str = lines.join(type === Scalar.Scalar.BLOCK_LITERAL ? '\n' : ' ');
        }
        return stringifyString.stringifyString({ comment, type, value: str }, ctx, onComment, onChompKeep);
    }
};

exports.binary = binary;


/***/ }),
/* 89 */
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),
/* 90 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var toJS = __webpack_require__(60);
var YAMLMap = __webpack_require__(75);
var YAMLSeq = __webpack_require__(78);
var pairs = __webpack_require__(91);

class YAMLOMap extends YAMLSeq.YAMLSeq {
    constructor() {
        super();
        this.add = YAMLMap.YAMLMap.prototype.add.bind(this);
        this.delete = YAMLMap.YAMLMap.prototype.delete.bind(this);
        this.get = YAMLMap.YAMLMap.prototype.get.bind(this);
        this.has = YAMLMap.YAMLMap.prototype.has.bind(this);
        this.set = YAMLMap.YAMLMap.prototype.set.bind(this);
        this.tag = YAMLOMap.tag;
    }
    /**
     * If `ctx` is given, the return type is actually `Map<unknown, unknown>`,
     * but TypeScript won't allow widening the signature of a child method.
     */
    toJSON(_, ctx) {
        if (!ctx)
            return super.toJSON(_);
        const map = new Map();
        if (ctx?.onCreate)
            ctx.onCreate(map);
        for (const pair of this.items) {
            let key, value;
            if (identity.isPair(pair)) {
                key = toJS.toJS(pair.key, '', ctx);
                value = toJS.toJS(pair.value, key, ctx);
            }
            else {
                key = toJS.toJS(pair, '', ctx);
            }
            if (map.has(key))
                throw new Error('Ordered maps must not include duplicate keys');
            map.set(key, value);
        }
        return map;
    }
    static from(schema, iterable, ctx) {
        const pairs$1 = pairs.createPairs(schema, iterable, ctx);
        const omap = new this();
        omap.items = pairs$1.items;
        return omap;
    }
}
YAMLOMap.tag = 'tag:yaml.org,2002:omap';
const omap = {
    collection: 'seq',
    identify: value => value instanceof Map,
    nodeClass: YAMLOMap,
    default: false,
    tag: 'tag:yaml.org,2002:omap',
    resolve(seq, onError) {
        const pairs$1 = pairs.resolvePairs(seq, onError);
        const seenKeys = [];
        for (const { key } of pairs$1.items) {
            if (identity.isScalar(key)) {
                if (seenKeys.includes(key.value)) {
                    onError(`Ordered maps must not include duplicate keys: ${key.value}`);
                }
                else {
                    seenKeys.push(key.value);
                }
            }
        }
        return Object.assign(new YAMLOMap(), pairs$1);
    },
    createNode: (schema, iterable, ctx) => YAMLOMap.from(schema, iterable, ctx)
};

exports.YAMLOMap = YAMLOMap;
exports.omap = omap;


/***/ }),
/* 91 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var Scalar = __webpack_require__(63);
var YAMLSeq = __webpack_require__(78);

function resolvePairs(seq, onError) {
    if (identity.isSeq(seq)) {
        for (let i = 0; i < seq.items.length; ++i) {
            let item = seq.items[i];
            if (identity.isPair(item))
                continue;
            else if (identity.isMap(item)) {
                if (item.items.length > 1)
                    onError('Each pair must have its own sequence indicator');
                const pair = item.items[0] || new Pair.Pair(new Scalar.Scalar(null));
                if (item.commentBefore)
                    pair.key.commentBefore = pair.key.commentBefore
                        ? `${item.commentBefore}\n${pair.key.commentBefore}`
                        : item.commentBefore;
                if (item.comment) {
                    const cn = pair.value ?? pair.key;
                    cn.comment = cn.comment
                        ? `${item.comment}\n${cn.comment}`
                        : item.comment;
                }
                item = pair;
            }
            seq.items[i] = identity.isPair(item) ? item : new Pair.Pair(item);
        }
    }
    else
        onError('Expected a sequence for this tag');
    return seq;
}
function createPairs(schema, iterable, ctx) {
    const { replacer } = ctx;
    const pairs = new YAMLSeq.YAMLSeq(schema);
    pairs.tag = 'tag:yaml.org,2002:pairs';
    let i = 0;
    if (iterable && Symbol.iterator in Object(iterable))
        for (let it of iterable) {
            if (typeof replacer === 'function')
                it = replacer.call(iterable, String(i++), it);
            let key, value;
            if (Array.isArray(it)) {
                if (it.length === 2) {
                    key = it[0];
                    value = it[1];
                }
                else
                    throw new TypeError(`Expected [key, value] tuple: ${it}`);
            }
            else if (it && it instanceof Object) {
                const keys = Object.keys(it);
                if (keys.length === 1) {
                    key = keys[0];
                    value = it[key];
                }
                else {
                    throw new TypeError(`Expected tuple with one key, not ${keys.length} keys`);
                }
            }
            else {
                key = it;
            }
            pairs.items.push(Pair.createPair(key, value, ctx));
        }
    return pairs;
}
const pairs = {
    collection: 'seq',
    default: false,
    tag: 'tag:yaml.org,2002:pairs',
    resolve: resolvePairs,
    createNode: createPairs
};

exports.createPairs = createPairs;
exports.pairs = pairs;
exports.resolvePairs = resolvePairs;


/***/ }),
/* 92 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var map = __webpack_require__(74);
var _null = __webpack_require__(81);
var seq = __webpack_require__(77);
var string = __webpack_require__(79);
var binary = __webpack_require__(88);
var bool = __webpack_require__(93);
var float = __webpack_require__(94);
var int = __webpack_require__(95);
var merge = __webpack_require__(72);
var omap = __webpack_require__(90);
var pairs = __webpack_require__(91);
var set = __webpack_require__(96);
var timestamp = __webpack_require__(97);

const schema = [
    map.map,
    seq.seq,
    string.string,
    _null.nullTag,
    bool.trueTag,
    bool.falseTag,
    int.intBin,
    int.intOct,
    int.int,
    int.intHex,
    float.floatNaN,
    float.floatExp,
    float.float,
    binary.binary,
    merge.merge,
    omap.omap,
    pairs.pairs,
    set.set,
    timestamp.intTime,
    timestamp.floatTime,
    timestamp.timestamp
];

exports.schema = schema;


/***/ }),
/* 93 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);

function boolStringify({ value, source }, ctx) {
    const boolObj = value ? trueTag : falseTag;
    if (source && boolObj.test.test(source))
        return source;
    return value ? ctx.options.trueStr : ctx.options.falseStr;
}
const trueTag = {
    identify: value => value === true,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,
    resolve: () => new Scalar.Scalar(true),
    stringify: boolStringify
};
const falseTag = {
    identify: value => value === false,
    default: true,
    tag: 'tag:yaml.org,2002:bool',
    test: /^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/,
    resolve: () => new Scalar.Scalar(false),
    stringify: boolStringify
};

exports.falseTag = falseTag;
exports.trueTag = trueTag;


/***/ }),
/* 94 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var stringifyNumber = __webpack_require__(84);

const floatNaN = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^(?:[-+]?\.(?:inf|Inf|INF)|\.nan|\.NaN|\.NAN)$/,
    resolve: (str) => str.slice(-3).toLowerCase() === 'nan'
        ? NaN
        : str[0] === '-'
            ? Number.NEGATIVE_INFINITY
            : Number.POSITIVE_INFINITY,
    stringify: stringifyNumber.stringifyNumber
};
const floatExp = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'EXP',
    test: /^[-+]?(?:[0-9][0-9_]*)?(?:\.[0-9_]*)?[eE][-+]?[0-9]+$/,
    resolve: (str) => parseFloat(str.replace(/_/g, '')),
    stringify(node) {
        const num = Number(node.value);
        return isFinite(num) ? num.toExponential() : stringifyNumber.stringifyNumber(node);
    }
};
const float = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    test: /^[-+]?(?:[0-9][0-9_]*)?\.[0-9_]*$/,
    resolve(str) {
        const node = new Scalar.Scalar(parseFloat(str.replace(/_/g, '')));
        const dot = str.indexOf('.');
        if (dot !== -1) {
            const f = str.substring(dot + 1).replace(/_/g, '');
            if (f[f.length - 1] === '0')
                node.minFractionDigits = f.length;
        }
        return node;
    },
    stringify: stringifyNumber.stringifyNumber
};

exports.float = float;
exports.floatExp = floatExp;
exports.floatNaN = floatNaN;


/***/ }),
/* 95 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(84);

const intIdentify = (value) => typeof value === 'bigint' || Number.isInteger(value);
function intResolve(str, offset, radix, { intAsBigInt }) {
    const sign = str[0];
    if (sign === '-' || sign === '+')
        offset += 1;
    str = str.substring(offset).replace(/_/g, '');
    if (intAsBigInt) {
        switch (radix) {
            case 2:
                str = `0b${str}`;
                break;
            case 8:
                str = `0o${str}`;
                break;
            case 16:
                str = `0x${str}`;
                break;
        }
        const n = BigInt(str);
        return sign === '-' ? BigInt(-1) * n : n;
    }
    const n = parseInt(str, radix);
    return sign === '-' ? -1 * n : n;
}
function intStringify(node, radix, prefix) {
    const { value } = node;
    if (intIdentify(value)) {
        const str = value.toString(radix);
        return value < 0 ? '-' + prefix + str.substr(1) : prefix + str;
    }
    return stringifyNumber.stringifyNumber(node);
}
const intBin = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'BIN',
    test: /^[-+]?0b[0-1_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 2, opt),
    stringify: node => intStringify(node, 2, '0b')
};
const intOct = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'OCT',
    test: /^[-+]?0[0-7_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 1, 8, opt),
    stringify: node => intStringify(node, 8, '0')
};
const int = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    test: /^[-+]?[0-9][0-9_]*$/,
    resolve: (str, _onError, opt) => intResolve(str, 0, 10, opt),
    stringify: stringifyNumber.stringifyNumber
};
const intHex = {
    identify: intIdentify,
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'HEX',
    test: /^[-+]?0x[0-9a-fA-F_]+$/,
    resolve: (str, _onError, opt) => intResolve(str, 2, 16, opt),
    stringify: node => intStringify(node, 16, '0x')
};

exports.int = int;
exports.intBin = intBin;
exports.intHex = intHex;
exports.intOct = intOct;


/***/ }),
/* 96 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var YAMLMap = __webpack_require__(75);

class YAMLSet extends YAMLMap.YAMLMap {
    constructor(schema) {
        super(schema);
        this.tag = YAMLSet.tag;
    }
    add(key) {
        let pair;
        if (identity.isPair(key))
            pair = key;
        else if (key &&
            typeof key === 'object' &&
            'key' in key &&
            'value' in key &&
            key.value === null)
            pair = new Pair.Pair(key.key, null);
        else
            pair = new Pair.Pair(key, null);
        const prev = YAMLMap.findPair(this.items, pair.key);
        if (!prev)
            this.items.push(pair);
    }
    /**
     * If `keepPair` is `true`, returns the Pair matching `key`.
     * Otherwise, returns the value of that Pair's key.
     */
    get(key, keepPair) {
        const pair = YAMLMap.findPair(this.items, key);
        return !keepPair && identity.isPair(pair)
            ? identity.isScalar(pair.key)
                ? pair.key.value
                : pair.key
            : pair;
    }
    set(key, value) {
        if (typeof value !== 'boolean')
            throw new Error(`Expected boolean value for set(key, value) in a YAML set, not ${typeof value}`);
        const prev = YAMLMap.findPair(this.items, key);
        if (prev && !value) {
            this.items.splice(this.items.indexOf(prev), 1);
        }
        else if (!prev && value) {
            this.items.push(new Pair.Pair(key));
        }
    }
    toJSON(_, ctx) {
        return super.toJSON(_, ctx, Set);
    }
    toString(ctx, onComment, onChompKeep) {
        if (!ctx)
            return JSON.stringify(this);
        if (this.hasAllNullValues(true))
            return super.toString(Object.assign({}, ctx, { allNullValues: true }), onComment, onChompKeep);
        else
            throw new Error('Set items must all have null values');
    }
    static from(schema, iterable, ctx) {
        const { replacer } = ctx;
        const set = new this(schema);
        if (iterable && Symbol.iterator in Object(iterable))
            for (let value of iterable) {
                if (typeof replacer === 'function')
                    value = replacer.call(iterable, value, value);
                set.items.push(Pair.createPair(value, null, ctx));
            }
        return set;
    }
}
YAMLSet.tag = 'tag:yaml.org,2002:set';
const set = {
    collection: 'map',
    identify: value => value instanceof Set,
    nodeClass: YAMLSet,
    default: false,
    tag: 'tag:yaml.org,2002:set',
    createNode: (schema, iterable, ctx) => YAMLSet.from(schema, iterable, ctx),
    resolve(map, onError) {
        if (identity.isMap(map)) {
            if (map.hasAllNullValues(true))
                return Object.assign(new YAMLSet(), map);
            else
                onError('Set items must all have null values');
        }
        else
            onError('Expected a mapping for this tag');
        return map;
    }
};

exports.YAMLSet = YAMLSet;
exports.set = set;


/***/ }),
/* 97 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var stringifyNumber = __webpack_require__(84);

/** Internal types handle bigint as number, because TS can't figure it out. */
function parseSexagesimal(str, asBigInt) {
    const sign = str[0];
    const parts = sign === '-' || sign === '+' ? str.substring(1) : str;
    const num = (n) => asBigInt ? BigInt(n) : Number(n);
    const res = parts
        .replace(/_/g, '')
        .split(':')
        .reduce((res, p) => res * num(60) + num(p), num(0));
    return (sign === '-' ? num(-1) * res : res);
}
/**
 * hhhh:mm:ss.sss
 *
 * Internal types handle bigint as number, because TS can't figure it out.
 */
function stringifySexagesimal(node) {
    let { value } = node;
    let num = (n) => n;
    if (typeof value === 'bigint')
        num = n => BigInt(n);
    else if (isNaN(value) || !isFinite(value))
        return stringifyNumber.stringifyNumber(node);
    let sign = '';
    if (value < 0) {
        sign = '-';
        value *= num(-1);
    }
    const _60 = num(60);
    const parts = [value % _60]; // seconds, including ms
    if (value < 60) {
        parts.unshift(0); // at least one : is required
    }
    else {
        value = (value - parts[0]) / _60;
        parts.unshift(value % _60); // minutes
        if (value >= 60) {
            value = (value - parts[0]) / _60;
            parts.unshift(value); // hours
        }
    }
    return (sign +
        parts
            .map(n => String(n).padStart(2, '0'))
            .join(':')
            .replace(/000000\d*$/, '') // % 60 may introduce error
    );
}
const intTime = {
    identify: value => typeof value === 'bigint' || Number.isInteger(value),
    default: true,
    tag: 'tag:yaml.org,2002:int',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+$/,
    resolve: (str, _onError, { intAsBigInt }) => parseSexagesimal(str, intAsBigInt),
    stringify: stringifySexagesimal
};
const floatTime = {
    identify: value => typeof value === 'number',
    default: true,
    tag: 'tag:yaml.org,2002:float',
    format: 'TIME',
    test: /^[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*$/,
    resolve: str => parseSexagesimal(str, false),
    stringify: stringifySexagesimal
};
const timestamp = {
    identify: value => value instanceof Date,
    default: true,
    tag: 'tag:yaml.org,2002:timestamp',
    // If the time zone is omitted, the timestamp is assumed to be specified in UTC. The time part
    // may be omitted altogether, resulting in a date format. In such a case, the time part is
    // assumed to be 00:00:00Z (start of day, UTC).
    test: RegExp('^([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})' + // YYYY-Mm-Dd
        '(?:' + // time is optional
        '(?:t|T|[ \\t]+)' + // t | T | whitespace
        '([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)' + // Hh:Mm:Ss(.ss)?
        '(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?' + // Z | +5 | -03:30
        ')?$'),
    resolve(str) {
        const match = str.match(timestamp.test);
        if (!match)
            throw new Error('!!timestamp expects a date, starting with yyyy-mm-dd');
        const [, year, month, day, hour, minute, second] = match.map(Number);
        const millisec = match[7] ? Number((match[7] + '00').substr(1, 3)) : 0;
        let date = Date.UTC(year, month - 1, day, hour || 0, minute || 0, second || 0, millisec);
        const tz = match[8];
        if (tz && tz !== 'Z') {
            let d = parseSexagesimal(tz, false);
            if (Math.abs(d) < 30)
                d *= 60;
            date -= 60000 * d;
        }
        return new Date(date);
    },
    stringify: ({ value }) => value?.toISOString().replace(/(T00:00:00)?\.000Z$/, '') ?? ''
};

exports.floatTime = floatTime;
exports.intTime = intTime;
exports.timestamp = timestamp;


/***/ }),
/* 98 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var stringify = __webpack_require__(66);
var stringifyComment = __webpack_require__(67);

function stringifyDocument(doc, options) {
    const lines = [];
    let hasDirectives = options.directives === true;
    if (options.directives !== false && doc.directives) {
        const dir = doc.directives.toString(doc);
        if (dir) {
            lines.push(dir);
            hasDirectives = true;
        }
        else if (doc.directives.docStart)
            hasDirectives = true;
    }
    if (hasDirectives)
        lines.push('---');
    const ctx = stringify.createStringifyContext(doc, options);
    const { commentString } = ctx.options;
    if (doc.commentBefore) {
        if (lines.length !== 1)
            lines.unshift('');
        const cs = commentString(doc.commentBefore);
        lines.unshift(stringifyComment.indentComment(cs, ''));
    }
    let chompKeep = false;
    let contentComment = null;
    if (doc.contents) {
        if (identity.isNode(doc.contents)) {
            if (doc.contents.spaceBefore && hasDirectives)
                lines.push('');
            if (doc.contents.commentBefore) {
                const cs = commentString(doc.contents.commentBefore);
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            // top-level block scalars need to be indented if followed by a comment
            ctx.forceBlockIndent = !!doc.comment;
            contentComment = doc.contents.comment;
        }
        const onChompKeep = contentComment ? undefined : () => (chompKeep = true);
        let body = stringify.stringify(doc.contents, ctx, () => (contentComment = null), onChompKeep);
        if (contentComment)
            body += stringifyComment.lineComment(body, '', commentString(contentComment));
        if ((body[0] === '|' || body[0] === '>') &&
            lines[lines.length - 1] === '---') {
            // Top-level block scalars with a preceding doc marker ought to use the
            // same line for their header.
            lines[lines.length - 1] = `--- ${body}`;
        }
        else
            lines.push(body);
    }
    else {
        lines.push(stringify.stringify(doc.contents, ctx));
    }
    if (doc.directives?.docEnd) {
        if (doc.comment) {
            const cs = commentString(doc.comment);
            if (cs.includes('\n')) {
                lines.push('...');
                lines.push(stringifyComment.indentComment(cs, ''));
            }
            else {
                lines.push(`... ${cs}`);
            }
        }
        else {
            lines.push('...');
        }
    }
    else {
        let dc = doc.comment;
        if (dc && chompKeep)
            dc = dc.replace(/^\n+/, '');
        if (dc) {
            if ((!chompKeep || contentComment) && lines[lines.length - 1] !== '')
                lines.push('');
            lines.push(stringifyComment.indentComment(commentString(dc), ''));
        }
    }
    return lines.join('\n') + '\n';
}

exports.stringifyDocument = stringifyDocument;


/***/ }),
/* 99 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


class YAMLError extends Error {
    constructor(name, pos, code, message) {
        super();
        this.name = name;
        this.code = code;
        this.message = message;
        this.pos = pos;
    }
}
class YAMLParseError extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLParseError', pos, code, message);
    }
}
class YAMLWarning extends YAMLError {
    constructor(pos, code, message) {
        super('YAMLWarning', pos, code, message);
    }
}
const prettifyError = (src, lc) => (error) => {
    if (error.pos[0] === -1)
        return;
    error.linePos = error.pos.map(pos => lc.linePos(pos));
    const { line, col } = error.linePos[0];
    error.message += ` at line ${line}, column ${col}`;
    let ci = col - 1;
    let lineStr = src
        .substring(lc.lineStarts[line - 1], lc.lineStarts[line])
        .replace(/[\n\r]+$/, '');
    // Trim to max 80 chars, keeping col position near the middle
    if (ci >= 60 && lineStr.length > 80) {
        const trimStart = Math.min(ci - 39, lineStr.length - 79);
        lineStr = '…' + lineStr.substring(trimStart);
        ci -= trimStart - 1;
    }
    if (lineStr.length > 80)
        lineStr = lineStr.substring(0, 79) + '…';
    // Include previous line in context if pointing at line start
    if (line > 1 && /^ *$/.test(lineStr.substring(0, ci))) {
        // Regexp won't match if start is trimmed
        let prev = src.substring(lc.lineStarts[line - 2], lc.lineStarts[line - 1]);
        if (prev.length > 80)
            prev = prev.substring(0, 79) + '…\n';
        lineStr = prev + lineStr;
    }
    if (/[^ ]/.test(lineStr)) {
        let count = 1;
        const end = error.linePos[1];
        if (end && end.line === line && end.col > col) {
            count = Math.max(1, Math.min(end.col - col, 80 - ci));
        }
        const pointer = ' '.repeat(ci) + '^'.repeat(count);
        error.message += `:\n\n${lineStr}\n${pointer}\n`;
    }
};

exports.YAMLError = YAMLError;
exports.YAMLParseError = YAMLParseError;
exports.YAMLWarning = YAMLWarning;
exports.prettifyError = prettifyError;


/***/ }),
/* 100 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Document = __webpack_require__(55);
var composeNode = __webpack_require__(101);
var resolveEnd = __webpack_require__(110);
var resolveProps = __webpack_require__(104);

function composeDoc(options, directives, { offset, start, value, end }, onError) {
    const opts = Object.assign({ _directives: directives }, options);
    const doc = new Document.Document(undefined, opts);
    const ctx = {
        atKey: false,
        atRoot: true,
        directives: doc.directives,
        options: doc.options,
        schema: doc.schema
    };
    const props = resolveProps.resolveProps(start, {
        indicator: 'doc-start',
        next: value ?? end?.[0],
        offset,
        onError,
        parentIndent: 0,
        startOnNewline: true
    });
    if (props.found) {
        doc.directives.docStart = true;
        if (value &&
            (value.type === 'block-map' || value.type === 'block-seq') &&
            !props.hasNewline)
            onError(props.end, 'MISSING_CHAR', 'Block collection cannot start on same line with directives-end marker');
    }
    // @ts-expect-error If Contents is set, let's trust the user
    doc.contents = value
        ? composeNode.composeNode(ctx, value, props, onError)
        : composeNode.composeEmptyNode(ctx, props.end, start, null, props, onError);
    const contentEnd = doc.contents.range[2];
    const re = resolveEnd.resolveEnd(end, contentEnd, false, onError);
    if (re.comment)
        doc.comment = re.comment;
    doc.range = [offset, contentEnd, re.offset];
    return doc;
}

exports.composeDoc = composeDoc;


/***/ }),
/* 101 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Alias = __webpack_require__(56);
var identity = __webpack_require__(53);
var composeCollection = __webpack_require__(102);
var composeScalar = __webpack_require__(111);
var resolveEnd = __webpack_require__(110);
var utilEmptyScalarPosition = __webpack_require__(114);

const CN = { composeNode, composeEmptyNode };
function composeNode(ctx, token, props, onError) {
    const atKey = ctx.atKey;
    const { spaceBefore, comment, anchor, tag } = props;
    let node;
    let isSrcToken = true;
    switch (token.type) {
        case 'alias':
            node = composeAlias(ctx, token, onError);
            if (anchor || tag)
                onError(token, 'ALIAS_PROPS', 'An alias node must not specify any properties');
            break;
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'block-scalar':
            node = composeScalar.composeScalar(ctx, token, tag, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        case 'block-map':
        case 'block-seq':
        case 'flow-collection':
            node = composeCollection.composeCollection(CN, ctx, token, props, onError);
            if (anchor)
                node.anchor = anchor.source.substring(1);
            break;
        default: {
            const message = token.type === 'error'
                ? token.message
                : `Unsupported token (type: ${token.type})`;
            onError(token, 'UNEXPECTED_TOKEN', message);
            node = composeEmptyNode(ctx, token.offset, undefined, null, props, onError);
            isSrcToken = false;
        }
    }
    if (anchor && node.anchor === '')
        onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    if (atKey &&
        ctx.options.stringKeys &&
        (!identity.isScalar(node) ||
            typeof node.value !== 'string' ||
            (node.tag && node.tag !== 'tag:yaml.org,2002:str'))) {
        const msg = 'With stringKeys, all keys must be strings';
        onError(tag ?? token, 'NON_STRING_KEY', msg);
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        if (token.type === 'scalar' && token.source === '')
            node.comment = comment;
        else
            node.commentBefore = comment;
    }
    // @ts-expect-error Type checking misses meaning of isSrcToken
    if (ctx.options.keepSourceTokens && isSrcToken)
        node.srcToken = token;
    return node;
}
function composeEmptyNode(ctx, offset, before, pos, { spaceBefore, comment, anchor, tag, end }, onError) {
    const token = {
        type: 'scalar',
        offset: utilEmptyScalarPosition.emptyScalarPosition(offset, before, pos),
        indent: -1,
        source: ''
    };
    const node = composeScalar.composeScalar(ctx, token, tag, onError);
    if (anchor) {
        node.anchor = anchor.source.substring(1);
        if (node.anchor === '')
            onError(anchor, 'BAD_ALIAS', 'Anchor cannot be an empty string');
    }
    if (spaceBefore)
        node.spaceBefore = true;
    if (comment) {
        node.comment = comment;
        node.range[2] = end;
    }
    return node;
}
function composeAlias({ options }, { offset, source, end }, onError) {
    const alias = new Alias.Alias(source.substring(1));
    if (alias.source === '')
        onError(offset, 'BAD_ALIAS', 'Alias cannot be an empty string');
    if (alias.source.endsWith(':'))
        onError(offset + source.length - 1, 'BAD_ALIAS', 'Alias ending in : is ambiguous', true);
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, options.strict, onError);
    alias.range = [offset, valueEnd, re.offset];
    if (re.comment)
        alias.comment = re.comment;
    return alias;
}

exports.composeEmptyNode = composeEmptyNode;
exports.composeNode = composeNode;


/***/ }),
/* 102 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);
var YAMLMap = __webpack_require__(75);
var YAMLSeq = __webpack_require__(78);
var resolveBlockMap = __webpack_require__(103);
var resolveBlockSeq = __webpack_require__(108);
var resolveFlowCollection = __webpack_require__(109);

function resolveCollection(CN, ctx, token, onError, tagName, tag) {
    const coll = token.type === 'block-map'
        ? resolveBlockMap.resolveBlockMap(CN, ctx, token, onError, tag)
        : token.type === 'block-seq'
            ? resolveBlockSeq.resolveBlockSeq(CN, ctx, token, onError, tag)
            : resolveFlowCollection.resolveFlowCollection(CN, ctx, token, onError, tag);
    const Coll = coll.constructor;
    // If we got a tagName matching the class, or the tag name is '!',
    // then use the tagName from the node class used to create it.
    if (tagName === '!' || tagName === Coll.tagName) {
        coll.tag = Coll.tagName;
        return coll;
    }
    if (tagName)
        coll.tag = tagName;
    return coll;
}
function composeCollection(CN, ctx, token, props, onError) {
    const tagToken = props.tag;
    const tagName = !tagToken
        ? null
        : ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg));
    if (token.type === 'block-seq') {
        const { anchor, newlineAfterProp: nl } = props;
        const lastProp = anchor && tagToken
            ? anchor.offset > tagToken.offset
                ? anchor
                : tagToken
            : (anchor ?? tagToken);
        if (lastProp && (!nl || nl.offset < lastProp.offset)) {
            const message = 'Missing newline after block sequence props';
            onError(lastProp, 'MISSING_CHAR', message);
        }
    }
    const expType = token.type === 'block-map'
        ? 'map'
        : token.type === 'block-seq'
            ? 'seq'
            : token.start.source === '{'
                ? 'map'
                : 'seq';
    // shortcut: check if it's a generic YAMLMap or YAMLSeq
    // before jumping into the custom tag logic.
    if (!tagToken ||
        !tagName ||
        tagName === '!' ||
        (tagName === YAMLMap.YAMLMap.tagName && expType === 'map') ||
        (tagName === YAMLSeq.YAMLSeq.tagName && expType === 'seq')) {
        return resolveCollection(CN, ctx, token, onError, tagName);
    }
    let tag = ctx.schema.tags.find(t => t.tag === tagName && t.collection === expType);
    if (!tag) {
        const kt = ctx.schema.knownTags[tagName];
        if (kt && kt.collection === expType) {
            ctx.schema.tags.push(Object.assign({}, kt, { default: false }));
            tag = kt;
        }
        else {
            if (kt) {
                onError(tagToken, 'BAD_COLLECTION_TYPE', `${kt.tag} used for ${expType} collection, but expects ${kt.collection ?? 'scalar'}`, true);
            }
            else {
                onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, true);
            }
            return resolveCollection(CN, ctx, token, onError, tagName);
        }
    }
    const coll = resolveCollection(CN, ctx, token, onError, tagName, tag);
    const res = tag.resolve?.(coll, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg), ctx.options) ?? coll;
    const node = identity.isNode(res)
        ? res
        : new Scalar.Scalar(res);
    node.range = coll.range;
    node.tag = tagName;
    if (tag?.format)
        node.format = tag.format;
    return node;
}

exports.composeCollection = composeCollection;


/***/ }),
/* 103 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Pair = __webpack_require__(64);
var YAMLMap = __webpack_require__(75);
var resolveProps = __webpack_require__(104);
var utilContainsNewline = __webpack_require__(105);
var utilFlowIndentCheck = __webpack_require__(106);
var utilMapIncludes = __webpack_require__(107);

const startColMsg = 'All mapping items must start at the same column';
function resolveBlockMap({ composeNode, composeEmptyNode }, ctx, bm, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLMap.YAMLMap;
    const map = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    let offset = bm.offset;
    let commentEnd = null;
    for (const collItem of bm.items) {
        const { start, key, sep, value } = collItem;
        // key properties
        const keyProps = resolveProps.resolveProps(start, {
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: bm.indent,
            startOnNewline: true
        });
        const implicitKey = !keyProps.found;
        if (implicitKey) {
            if (key) {
                if (key.type === 'block-seq')
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'A block sequence may not be used as an implicit map key');
                else if ('indent' in key && key.indent !== bm.indent)
                    onError(offset, 'BAD_INDENT', startColMsg);
            }
            if (!keyProps.anchor && !keyProps.tag && !sep) {
                commentEnd = keyProps.end;
                if (keyProps.comment) {
                    if (map.comment)
                        map.comment += '\n' + keyProps.comment;
                    else
                        map.comment = keyProps.comment;
                }
                continue;
            }
            if (keyProps.newlineAfterProp || utilContainsNewline.containsNewline(key)) {
                onError(key ?? start[start.length - 1], 'MULTILINE_IMPLICIT_KEY', 'Implicit keys need to be on a single line');
            }
        }
        else if (keyProps.found?.indent !== bm.indent) {
            onError(offset, 'BAD_INDENT', startColMsg);
        }
        // key value
        ctx.atKey = true;
        const keyStart = keyProps.end;
        const keyNode = key
            ? composeNode(ctx, key, keyProps, onError)
            : composeEmptyNode(ctx, keyStart, start, null, keyProps, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bm.indent, key, onError);
        ctx.atKey = false;
        if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
            onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
        // value properties
        const valueProps = resolveProps.resolveProps(sep ?? [], {
            indicator: 'map-value-ind',
            next: value,
            offset: keyNode.range[2],
            onError,
            parentIndent: bm.indent,
            startOnNewline: !key || key.type === 'block-scalar'
        });
        offset = valueProps.end;
        if (valueProps.found) {
            if (implicitKey) {
                if (value?.type === 'block-map' && !valueProps.hasNewline)
                    onError(offset, 'BLOCK_AS_IMPLICIT_KEY', 'Nested mappings are not allowed in compact mappings');
                if (ctx.options.strict &&
                    keyProps.start < valueProps.found.offset - 1024)
                    onError(keyNode.range, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit block mapping key');
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : composeEmptyNode(ctx, offset, sep, null, valueProps, onError);
            if (ctx.schema.compat)
                utilFlowIndentCheck.flowIndentCheck(bm.indent, value, onError);
            offset = valueNode.range[2];
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
        else {
            // key with no value
            if (implicitKey)
                onError(keyNode.range, 'MISSING_CHAR', 'Implicit map keys need to be followed by map values');
            if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            map.items.push(pair);
        }
    }
    if (commentEnd && commentEnd < offset)
        onError(commentEnd, 'IMPOSSIBLE', 'Map comment with trailing content');
    map.range = [bm.offset, offset, commentEnd ?? offset];
    return map;
}

exports.resolveBlockMap = resolveBlockMap;


/***/ }),
/* 104 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveProps(tokens, { flow, indicator, next, offset, onError, parentIndent, startOnNewline }) {
    let spaceBefore = false;
    let atNewline = startOnNewline;
    let hasSpace = startOnNewline;
    let comment = '';
    let commentSep = '';
    let hasNewline = false;
    let reqSpace = false;
    let tab = null;
    let anchor = null;
    let tag = null;
    let newlineAfterProp = null;
    let comma = null;
    let found = null;
    let start = null;
    for (const token of tokens) {
        if (reqSpace) {
            if (token.type !== 'space' &&
                token.type !== 'newline' &&
                token.type !== 'comma')
                onError(token.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
            reqSpace = false;
        }
        if (tab) {
            if (atNewline && token.type !== 'comment' && token.type !== 'newline') {
                onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
            }
            tab = null;
        }
        switch (token.type) {
            case 'space':
                // At the doc level, tabs at line start may be parsed
                // as leading white space rather than indentation.
                // In a flow collection, only the parser handles indent.
                if (!flow &&
                    (indicator !== 'doc-start' || next?.type !== 'flow-collection') &&
                    token.source.includes('\t')) {
                    tab = token;
                }
                hasSpace = true;
                break;
            case 'comment': {
                if (!hasSpace)
                    onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                const cb = token.source.substring(1) || ' ';
                if (!comment)
                    comment = cb;
                else
                    comment += commentSep + cb;
                commentSep = '';
                atNewline = false;
                break;
            }
            case 'newline':
                if (atNewline) {
                    if (comment)
                        comment += token.source;
                    else if (!found || indicator !== 'seq-item-ind')
                        spaceBefore = true;
                }
                else
                    commentSep += token.source;
                atNewline = true;
                hasNewline = true;
                if (anchor || tag)
                    newlineAfterProp = token;
                hasSpace = true;
                break;
            case 'anchor':
                if (anchor)
                    onError(token, 'MULTIPLE_ANCHORS', 'A node can have at most one anchor');
                if (token.source.endsWith(':'))
                    onError(token.offset + token.source.length - 1, 'BAD_ALIAS', 'Anchor ending in : is ambiguous', true);
                anchor = token;
                start ?? (start = token.offset);
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            case 'tag': {
                if (tag)
                    onError(token, 'MULTIPLE_TAGS', 'A node can have at most one tag');
                tag = token;
                start ?? (start = token.offset);
                atNewline = false;
                hasSpace = false;
                reqSpace = true;
                break;
            }
            case indicator:
                // Could here handle preceding comments differently
                if (anchor || tag)
                    onError(token, 'BAD_PROP_ORDER', `Anchors and tags must be after the ${token.source} indicator`);
                if (found)
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.source} in ${flow ?? 'collection'}`);
                found = token;
                atNewline =
                    indicator === 'seq-item-ind' || indicator === 'explicit-key-ind';
                hasSpace = false;
                break;
            case 'comma':
                if (flow) {
                    if (comma)
                        onError(token, 'UNEXPECTED_TOKEN', `Unexpected , in ${flow}`);
                    comma = token;
                    atNewline = false;
                    hasSpace = false;
                    break;
                }
            // else fallthrough
            default:
                onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${token.type} token`);
                atNewline = false;
                hasSpace = false;
        }
    }
    const last = tokens[tokens.length - 1];
    const end = last ? last.offset + last.source.length : offset;
    if (reqSpace &&
        next &&
        next.type !== 'space' &&
        next.type !== 'newline' &&
        next.type !== 'comma' &&
        (next.type !== 'scalar' || next.source !== '')) {
        onError(next.offset, 'MISSING_CHAR', 'Tags and anchors must be separated from the next token by white space');
    }
    if (tab &&
        ((atNewline && tab.indent <= parentIndent) ||
            next?.type === 'block-map' ||
            next?.type === 'block-seq'))
        onError(tab, 'TAB_AS_INDENT', 'Tabs are not allowed as indentation');
    return {
        comma,
        found,
        spaceBefore,
        comment,
        hasNewline,
        anchor,
        tag,
        newlineAfterProp,
        end,
        start: start ?? end
    };
}

exports.resolveProps = resolveProps;


/***/ }),
/* 105 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function containsNewline(key) {
    if (!key)
        return null;
    switch (key.type) {
        case 'alias':
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            if (key.source.includes('\n'))
                return true;
            if (key.end)
                for (const st of key.end)
                    if (st.type === 'newline')
                        return true;
            return false;
        case 'flow-collection':
            for (const it of key.items) {
                for (const st of it.start)
                    if (st.type === 'newline')
                        return true;
                if (it.sep)
                    for (const st of it.sep)
                        if (st.type === 'newline')
                            return true;
                if (containsNewline(it.key) || containsNewline(it.value))
                    return true;
            }
            return false;
        default:
            return true;
    }
}

exports.containsNewline = containsNewline;


/***/ }),
/* 106 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var utilContainsNewline = __webpack_require__(105);

function flowIndentCheck(indent, fc, onError) {
    if (fc?.type === 'flow-collection') {
        const end = fc.end[0];
        if (end.indent === indent &&
            (end.source === ']' || end.source === '}') &&
            utilContainsNewline.containsNewline(fc)) {
            const msg = 'Flow end indicator should be more indented than parent';
            onError(end, 'BAD_INDENT', msg, true);
        }
    }
}

exports.flowIndentCheck = flowIndentCheck;


/***/ }),
/* 107 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);

function mapIncludes(ctx, items, search) {
    const { uniqueKeys } = ctx.options;
    if (uniqueKeys === false)
        return false;
    const isEqual = typeof uniqueKeys === 'function'
        ? uniqueKeys
        : (a, b) => a === b || (identity.isScalar(a) && identity.isScalar(b) && a.value === b.value);
    return items.some(pair => isEqual(pair.key, search));
}

exports.mapIncludes = mapIncludes;


/***/ }),
/* 108 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var YAMLSeq = __webpack_require__(78);
var resolveProps = __webpack_require__(104);
var utilFlowIndentCheck = __webpack_require__(106);

function resolveBlockSeq({ composeNode, composeEmptyNode }, ctx, bs, onError, tag) {
    const NodeClass = tag?.nodeClass ?? YAMLSeq.YAMLSeq;
    const seq = new NodeClass(ctx.schema);
    if (ctx.atRoot)
        ctx.atRoot = false;
    if (ctx.atKey)
        ctx.atKey = false;
    let offset = bs.offset;
    let commentEnd = null;
    for (const { start, value } of bs.items) {
        const props = resolveProps.resolveProps(start, {
            indicator: 'seq-item-ind',
            next: value,
            offset,
            onError,
            parentIndent: bs.indent,
            startOnNewline: true
        });
        if (!props.found) {
            if (props.anchor || props.tag || value) {
                if (value && value.type === 'block-seq')
                    onError(props.end, 'BAD_INDENT', 'All sequence items must start at the same column');
                else
                    onError(offset, 'MISSING_CHAR', 'Sequence item without - indicator');
            }
            else {
                commentEnd = props.end;
                if (props.comment)
                    seq.comment = props.comment;
                continue;
            }
        }
        const node = value
            ? composeNode(ctx, value, props, onError)
            : composeEmptyNode(ctx, props.end, start, null, props, onError);
        if (ctx.schema.compat)
            utilFlowIndentCheck.flowIndentCheck(bs.indent, value, onError);
        offset = node.range[2];
        seq.items.push(node);
    }
    seq.range = [bs.offset, offset, commentEnd ?? offset];
    return seq;
}

exports.resolveBlockSeq = resolveBlockSeq;


/***/ }),
/* 109 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Pair = __webpack_require__(64);
var YAMLMap = __webpack_require__(75);
var YAMLSeq = __webpack_require__(78);
var resolveEnd = __webpack_require__(110);
var resolveProps = __webpack_require__(104);
var utilContainsNewline = __webpack_require__(105);
var utilMapIncludes = __webpack_require__(107);

const blockMsg = 'Block collections are not allowed within flow collections';
const isBlock = (token) => token && (token.type === 'block-map' || token.type === 'block-seq');
function resolveFlowCollection({ composeNode, composeEmptyNode }, ctx, fc, onError, tag) {
    const isMap = fc.start.source === '{';
    const fcName = isMap ? 'flow map' : 'flow sequence';
    const NodeClass = (tag?.nodeClass ?? (isMap ? YAMLMap.YAMLMap : YAMLSeq.YAMLSeq));
    const coll = new NodeClass(ctx.schema);
    coll.flow = true;
    const atRoot = ctx.atRoot;
    if (atRoot)
        ctx.atRoot = false;
    if (ctx.atKey)
        ctx.atKey = false;
    let offset = fc.offset + fc.start.source.length;
    for (let i = 0; i < fc.items.length; ++i) {
        const collItem = fc.items[i];
        const { start, key, sep, value } = collItem;
        const props = resolveProps.resolveProps(start, {
            flow: fcName,
            indicator: 'explicit-key-ind',
            next: key ?? sep?.[0],
            offset,
            onError,
            parentIndent: fc.indent,
            startOnNewline: false
        });
        if (!props.found) {
            if (!props.anchor && !props.tag && !sep && !value) {
                if (i === 0 && props.comma)
                    onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
                else if (i < fc.items.length - 1)
                    onError(props.start, 'UNEXPECTED_TOKEN', `Unexpected empty item in ${fcName}`);
                if (props.comment) {
                    if (coll.comment)
                        coll.comment += '\n' + props.comment;
                    else
                        coll.comment = props.comment;
                }
                offset = props.end;
                continue;
            }
            if (!isMap && ctx.options.strict && utilContainsNewline.containsNewline(key))
                onError(key, // checked by containsNewline()
                'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
        }
        if (i === 0) {
            if (props.comma)
                onError(props.comma, 'UNEXPECTED_TOKEN', `Unexpected , in ${fcName}`);
        }
        else {
            if (!props.comma)
                onError(props.start, 'MISSING_CHAR', `Missing , between ${fcName} items`);
            if (props.comment) {
                let prevItemComment = '';
                loop: for (const st of start) {
                    switch (st.type) {
                        case 'comma':
                        case 'space':
                            break;
                        case 'comment':
                            prevItemComment = st.source.substring(1);
                            break loop;
                        default:
                            break loop;
                    }
                }
                if (prevItemComment) {
                    let prev = coll.items[coll.items.length - 1];
                    if (identity.isPair(prev))
                        prev = prev.value ?? prev.key;
                    if (prev.comment)
                        prev.comment += '\n' + prevItemComment;
                    else
                        prev.comment = prevItemComment;
                    props.comment = props.comment.substring(prevItemComment.length + 1);
                }
            }
        }
        if (!isMap && !sep && !props.found) {
            // item is a value in a seq
            // → key & sep are empty, start does not include ? or :
            const valueNode = value
                ? composeNode(ctx, value, props, onError)
                : composeEmptyNode(ctx, props.end, sep, null, props, onError);
            coll.items.push(valueNode);
            offset = valueNode.range[2];
            if (isBlock(value))
                onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
        }
        else {
            // item is a key+value pair
            // key value
            ctx.atKey = true;
            const keyStart = props.end;
            const keyNode = key
                ? composeNode(ctx, key, props, onError)
                : composeEmptyNode(ctx, keyStart, start, null, props, onError);
            if (isBlock(key))
                onError(keyNode.range, 'BLOCK_IN_FLOW', blockMsg);
            ctx.atKey = false;
            // value properties
            const valueProps = resolveProps.resolveProps(sep ?? [], {
                flow: fcName,
                indicator: 'map-value-ind',
                next: value,
                offset: keyNode.range[2],
                onError,
                parentIndent: fc.indent,
                startOnNewline: false
            });
            if (valueProps.found) {
                if (!isMap && !props.found && ctx.options.strict) {
                    if (sep)
                        for (const st of sep) {
                            if (st === valueProps.found)
                                break;
                            if (st.type === 'newline') {
                                onError(st, 'MULTILINE_IMPLICIT_KEY', 'Implicit keys of flow sequence pairs need to be on a single line');
                                break;
                            }
                        }
                    if (props.start < valueProps.found.offset - 1024)
                        onError(valueProps.found, 'KEY_OVER_1024_CHARS', 'The : indicator must be at most 1024 chars after the start of an implicit flow sequence key');
                }
            }
            else if (value) {
                if ('source' in value && value.source && value.source[0] === ':')
                    onError(value, 'MISSING_CHAR', `Missing space after : in ${fcName}`);
                else
                    onError(valueProps.start, 'MISSING_CHAR', `Missing , or : between ${fcName} items`);
            }
            // value value
            const valueNode = value
                ? composeNode(ctx, value, valueProps, onError)
                : valueProps.found
                    ? composeEmptyNode(ctx, valueProps.end, sep, null, valueProps, onError)
                    : null;
            if (valueNode) {
                if (isBlock(value))
                    onError(valueNode.range, 'BLOCK_IN_FLOW', blockMsg);
            }
            else if (valueProps.comment) {
                if (keyNode.comment)
                    keyNode.comment += '\n' + valueProps.comment;
                else
                    keyNode.comment = valueProps.comment;
            }
            const pair = new Pair.Pair(keyNode, valueNode);
            if (ctx.options.keepSourceTokens)
                pair.srcToken = collItem;
            if (isMap) {
                const map = coll;
                if (utilMapIncludes.mapIncludes(ctx, map.items, keyNode))
                    onError(keyStart, 'DUPLICATE_KEY', 'Map keys must be unique');
                map.items.push(pair);
            }
            else {
                const map = new YAMLMap.YAMLMap(ctx.schema);
                map.flow = true;
                map.items.push(pair);
                const endRange = (valueNode ?? keyNode).range;
                map.range = [keyNode.range[0], endRange[1], endRange[2]];
                coll.items.push(map);
            }
            offset = valueNode ? valueNode.range[2] : valueProps.end;
        }
    }
    const expectedEnd = isMap ? '}' : ']';
    const [ce, ...ee] = fc.end;
    let cePos = offset;
    if (ce && ce.source === expectedEnd)
        cePos = ce.offset + ce.source.length;
    else {
        const name = fcName[0].toUpperCase() + fcName.substring(1);
        const msg = atRoot
            ? `${name} must end with a ${expectedEnd}`
            : `${name} in block collection must be sufficiently indented and end with a ${expectedEnd}`;
        onError(offset, atRoot ? 'MISSING_CHAR' : 'BAD_INDENT', msg);
        if (ce && ce.source.length !== 1)
            ee.unshift(ce);
    }
    if (ee.length > 0) {
        const end = resolveEnd.resolveEnd(ee, cePos, ctx.options.strict, onError);
        if (end.comment) {
            if (coll.comment)
                coll.comment += '\n' + end.comment;
            else
                coll.comment = end.comment;
        }
        coll.range = [fc.offset, cePos, end.offset];
    }
    else {
        coll.range = [fc.offset, cePos, cePos];
    }
    return coll;
}

exports.resolveFlowCollection = resolveFlowCollection;


/***/ }),
/* 110 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function resolveEnd(end, offset, reqSpace, onError) {
    let comment = '';
    if (end) {
        let hasSpace = false;
        let sep = '';
        for (const token of end) {
            const { source, type } = token;
            switch (type) {
                case 'space':
                    hasSpace = true;
                    break;
                case 'comment': {
                    if (reqSpace && !hasSpace)
                        onError(token, 'MISSING_CHAR', 'Comments must be separated from other tokens by white space characters');
                    const cb = source.substring(1) || ' ';
                    if (!comment)
                        comment = cb;
                    else
                        comment += sep + cb;
                    sep = '';
                    break;
                }
                case 'newline':
                    if (comment)
                        sep += source;
                    hasSpace = true;
                    break;
                default:
                    onError(token, 'UNEXPECTED_TOKEN', `Unexpected ${type} at node end`);
            }
            offset += source.length;
        }
    }
    return { comment, offset };
}

exports.resolveEnd = resolveEnd;


/***/ }),
/* 111 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var identity = __webpack_require__(53);
var Scalar = __webpack_require__(63);
var resolveBlockScalar = __webpack_require__(112);
var resolveFlowScalar = __webpack_require__(113);

function composeScalar(ctx, token, tagToken, onError) {
    const { value, type, comment, range } = token.type === 'block-scalar'
        ? resolveBlockScalar.resolveBlockScalar(ctx, token, onError)
        : resolveFlowScalar.resolveFlowScalar(token, ctx.options.strict, onError);
    const tagName = tagToken
        ? ctx.directives.tagName(tagToken.source, msg => onError(tagToken, 'TAG_RESOLVE_FAILED', msg))
        : null;
    let tag;
    if (ctx.options.stringKeys && ctx.atKey) {
        tag = ctx.schema[identity.SCALAR];
    }
    else if (tagName)
        tag = findScalarTagByName(ctx.schema, value, tagName, tagToken, onError);
    else if (token.type === 'scalar')
        tag = findScalarTagByTest(ctx, value, token, onError);
    else
        tag = ctx.schema[identity.SCALAR];
    let scalar;
    try {
        const res = tag.resolve(value, msg => onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg), ctx.options);
        scalar = identity.isScalar(res) ? res : new Scalar.Scalar(res);
    }
    catch (error) {
        const msg = error instanceof Error ? error.message : String(error);
        onError(tagToken ?? token, 'TAG_RESOLVE_FAILED', msg);
        scalar = new Scalar.Scalar(value);
    }
    scalar.range = range;
    scalar.source = value;
    if (type)
        scalar.type = type;
    if (tagName)
        scalar.tag = tagName;
    if (tag.format)
        scalar.format = tag.format;
    if (comment)
        scalar.comment = comment;
    return scalar;
}
function findScalarTagByName(schema, value, tagName, tagToken, onError) {
    if (tagName === '!')
        return schema[identity.SCALAR]; // non-specific tag
    const matchWithTest = [];
    for (const tag of schema.tags) {
        if (!tag.collection && tag.tag === tagName) {
            if (tag.default && tag.test)
                matchWithTest.push(tag);
            else
                return tag;
        }
    }
    for (const tag of matchWithTest)
        if (tag.test?.test(value))
            return tag;
    const kt = schema.knownTags[tagName];
    if (kt && !kt.collection) {
        // Ensure that the known tag is available for stringifying,
        // but does not get used by default.
        schema.tags.push(Object.assign({}, kt, { default: false, test: undefined }));
        return kt;
    }
    onError(tagToken, 'TAG_RESOLVE_FAILED', `Unresolved tag: ${tagName}`, tagName !== 'tag:yaml.org,2002:str');
    return schema[identity.SCALAR];
}
function findScalarTagByTest({ atKey, directives, schema }, value, token, onError) {
    const tag = schema.tags.find(tag => (tag.default === true || (atKey && tag.default === 'key')) &&
        tag.test?.test(value)) || schema[identity.SCALAR];
    if (schema.compat) {
        const compat = schema.compat.find(tag => tag.default && tag.test?.test(value)) ??
            schema[identity.SCALAR];
        if (tag.tag !== compat.tag) {
            const ts = directives.tagString(tag.tag);
            const cs = directives.tagString(compat.tag);
            const msg = `Value may be parsed as either ${ts} or ${cs}`;
            onError(token, 'TAG_RESOLVE_FAILED', msg, true);
        }
    }
    return tag;
}

exports.composeScalar = composeScalar;


/***/ }),
/* 112 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);

function resolveBlockScalar(ctx, scalar, onError) {
    const start = scalar.offset;
    const header = parseBlockScalarHeader(scalar, ctx.options.strict, onError);
    if (!header)
        return { value: '', type: null, comment: '', range: [start, start, start] };
    const type = header.mode === '>' ? Scalar.Scalar.BLOCK_FOLDED : Scalar.Scalar.BLOCK_LITERAL;
    const lines = scalar.source ? splitLines(scalar.source) : [];
    // determine the end of content & start of chomping
    let chompStart = lines.length;
    for (let i = lines.length - 1; i >= 0; --i) {
        const content = lines[i][1];
        if (content === '' || content === '\r')
            chompStart = i;
        else
            break;
    }
    // shortcut for empty contents
    if (chompStart === 0) {
        const value = header.chomp === '+' && lines.length > 0
            ? '\n'.repeat(Math.max(1, lines.length - 1))
            : '';
        let end = start + header.length;
        if (scalar.source)
            end += scalar.source.length;
        return { value, type, comment: header.comment, range: [start, end, end] };
    }
    // find the indentation level to trim from start
    let trimIndent = scalar.indent + header.indent;
    let offset = scalar.offset + header.length;
    let contentStart = 0;
    for (let i = 0; i < chompStart; ++i) {
        const [indent, content] = lines[i];
        if (content === '' || content === '\r') {
            if (header.indent === 0 && indent.length > trimIndent)
                trimIndent = indent.length;
        }
        else {
            if (indent.length < trimIndent) {
                const message = 'Block scalars with more-indented leading empty lines must use an explicit indentation indicator';
                onError(offset + indent.length, 'MISSING_CHAR', message);
            }
            if (header.indent === 0)
                trimIndent = indent.length;
            contentStart = i;
            if (trimIndent === 0 && !ctx.atRoot) {
                const message = 'Block scalar values in collections must be indented';
                onError(offset, 'BAD_INDENT', message);
            }
            break;
        }
        offset += indent.length + content.length + 1;
    }
    // include trailing more-indented empty lines in content
    for (let i = lines.length - 1; i >= chompStart; --i) {
        if (lines[i][0].length > trimIndent)
            chompStart = i + 1;
    }
    let value = '';
    let sep = '';
    let prevMoreIndented = false;
    // leading whitespace is kept intact
    for (let i = 0; i < contentStart; ++i)
        value += lines[i][0].slice(trimIndent) + '\n';
    for (let i = contentStart; i < chompStart; ++i) {
        let [indent, content] = lines[i];
        offset += indent.length + content.length + 1;
        const crlf = content[content.length - 1] === '\r';
        if (crlf)
            content = content.slice(0, -1);
        /* istanbul ignore if already caught in lexer */
        if (content && indent.length < trimIndent) {
            const src = header.indent
                ? 'explicit indentation indicator'
                : 'first line';
            const message = `Block scalar lines must not be less indented than their ${src}`;
            onError(offset - content.length - (crlf ? 2 : 1), 'BAD_INDENT', message);
            indent = '';
        }
        if (type === Scalar.Scalar.BLOCK_LITERAL) {
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
        }
        else if (indent.length > trimIndent || content[0] === '\t') {
            // more-indented content within a folded block
            if (sep === ' ')
                sep = '\n';
            else if (!prevMoreIndented && sep === '\n')
                sep = '\n\n';
            value += sep + indent.slice(trimIndent) + content;
            sep = '\n';
            prevMoreIndented = true;
        }
        else if (content === '') {
            // empty line
            if (sep === '\n')
                value += '\n';
            else
                sep = '\n';
        }
        else {
            value += sep + content;
            sep = ' ';
            prevMoreIndented = false;
        }
    }
    switch (header.chomp) {
        case '-':
            break;
        case '+':
            for (let i = chompStart; i < lines.length; ++i)
                value += '\n' + lines[i][0].slice(trimIndent);
            if (value[value.length - 1] !== '\n')
                value += '\n';
            break;
        default:
            value += '\n';
    }
    const end = start + header.length + scalar.source.length;
    return { value, type, comment: header.comment, range: [start, end, end] };
}
function parseBlockScalarHeader({ offset, props }, strict, onError) {
    /* istanbul ignore if should not happen */
    if (props[0].type !== 'block-scalar-header') {
        onError(props[0], 'IMPOSSIBLE', 'Block scalar header not found');
        return null;
    }
    const { source } = props[0];
    const mode = source[0];
    let indent = 0;
    let chomp = '';
    let error = -1;
    for (let i = 1; i < source.length; ++i) {
        const ch = source[i];
        if (!chomp && (ch === '-' || ch === '+'))
            chomp = ch;
        else {
            const n = Number(ch);
            if (!indent && n)
                indent = n;
            else if (error === -1)
                error = offset + i;
        }
    }
    if (error !== -1)
        onError(error, 'UNEXPECTED_TOKEN', `Block scalar header includes extra characters: ${source}`);
    let hasSpace = false;
    let comment = '';
    let length = source.length;
    for (let i = 1; i < props.length; ++i) {
        const token = props[i];
        switch (token.type) {
            case 'space':
                hasSpace = true;
            // fallthrough
            case 'newline':
                length += token.source.length;
                break;
            case 'comment':
                if (strict && !hasSpace) {
                    const message = 'Comments must be separated from other tokens by white space characters';
                    onError(token, 'MISSING_CHAR', message);
                }
                length += token.source.length;
                comment = token.source.substring(1);
                break;
            case 'error':
                onError(token, 'UNEXPECTED_TOKEN', token.message);
                length += token.source.length;
                break;
            /* istanbul ignore next should not happen */
            default: {
                const message = `Unexpected token in block scalar header: ${token.type}`;
                onError(token, 'UNEXPECTED_TOKEN', message);
                const ts = token.source;
                if (ts && typeof ts === 'string')
                    length += ts.length;
            }
        }
    }
    return { mode, indent, chomp, comment, length };
}
/** @returns Array of lines split up as `[indent, content]` */
function splitLines(source) {
    const split = source.split(/\n( *)/);
    const first = split[0];
    const m = first.match(/^( *)/);
    const line0 = m?.[1]
        ? [m[1], first.slice(m[1].length)]
        : ['', first];
    const lines = [line0];
    for (let i = 1; i < split.length; i += 2)
        lines.push([split[i], split[i + 1]]);
    return lines;
}

exports.resolveBlockScalar = resolveBlockScalar;


/***/ }),
/* 113 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var Scalar = __webpack_require__(63);
var resolveEnd = __webpack_require__(110);

function resolveFlowScalar(scalar, strict, onError) {
    const { offset, type, source, end } = scalar;
    let _type;
    let value;
    const _onError = (rel, code, msg) => onError(offset + rel, code, msg);
    switch (type) {
        case 'scalar':
            _type = Scalar.Scalar.PLAIN;
            value = plainValue(source, _onError);
            break;
        case 'single-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_SINGLE;
            value = singleQuotedValue(source, _onError);
            break;
        case 'double-quoted-scalar':
            _type = Scalar.Scalar.QUOTE_DOUBLE;
            value = doubleQuotedValue(source, _onError);
            break;
        /* istanbul ignore next should not happen */
        default:
            onError(scalar, 'UNEXPECTED_TOKEN', `Expected a flow scalar value, but found: ${type}`);
            return {
                value: '',
                type: null,
                comment: '',
                range: [offset, offset + source.length, offset + source.length]
            };
    }
    const valueEnd = offset + source.length;
    const re = resolveEnd.resolveEnd(end, valueEnd, strict, onError);
    return {
        value,
        type: _type,
        comment: re.comment,
        range: [offset, valueEnd, re.offset]
    };
}
function plainValue(source, onError) {
    let badChar = '';
    switch (source[0]) {
        /* istanbul ignore next should not happen */
        case '\t':
            badChar = 'a tab character';
            break;
        case ',':
            badChar = 'flow indicator character ,';
            break;
        case '%':
            badChar = 'directive indicator character %';
            break;
        case '|':
        case '>': {
            badChar = `block scalar indicator ${source[0]}`;
            break;
        }
        case '@':
        case '`': {
            badChar = `reserved character ${source[0]}`;
            break;
        }
    }
    if (badChar)
        onError(0, 'BAD_SCALAR_START', `Plain value cannot start with ${badChar}`);
    return foldLines(source);
}
function singleQuotedValue(source, onError) {
    if (source[source.length - 1] !== "'" || source.length === 1)
        onError(source.length, 'MISSING_CHAR', "Missing closing 'quote");
    return foldLines(source.slice(1, -1)).replace(/''/g, "'");
}
function foldLines(source) {
    /**
     * The negative lookbehind here and in the `re` RegExp is to
     * prevent causing a polynomial search time in certain cases.
     *
     * The try-catch is for Safari, which doesn't support this yet:
     * https://caniuse.com/js-regexp-lookbehind
     */
    let first, line;
    try {
        first = new RegExp('(.*?)(?<![ \t])[ \t]*\r?\n', 'sy');
        line = new RegExp('[ \t]*(.*?)(?:(?<![ \t])[ \t]*)?\r?\n', 'sy');
    }
    catch {
        first = /(.*?)[ \t]*\r?\n/sy;
        line = /[ \t]*(.*?)[ \t]*\r?\n/sy;
    }
    let match = first.exec(source);
    if (!match)
        return source;
    let res = match[1];
    let sep = ' ';
    let pos = first.lastIndex;
    line.lastIndex = pos;
    while ((match = line.exec(source))) {
        if (match[1] === '') {
            if (sep === '\n')
                res += sep;
            else
                sep = '\n';
        }
        else {
            res += sep + match[1];
            sep = ' ';
        }
        pos = line.lastIndex;
    }
    const last = /[ \t]*(.*)/sy;
    last.lastIndex = pos;
    match = last.exec(source);
    return res + sep + (match?.[1] ?? '');
}
function doubleQuotedValue(source, onError) {
    let res = '';
    for (let i = 1; i < source.length - 1; ++i) {
        const ch = source[i];
        if (ch === '\r' && source[i + 1] === '\n')
            continue;
        if (ch === '\n') {
            const { fold, offset } = foldNewline(source, i);
            res += fold;
            i = offset;
        }
        else if (ch === '\\') {
            let next = source[++i];
            const cc = escapeCodes[next];
            if (cc)
                res += cc;
            else if (next === '\n') {
                // skip escaped newlines, but still trim the following line
                next = source[i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === '\r' && source[i + 1] === '\n') {
                // skip escaped CRLF newlines, but still trim the following line
                next = source[++i + 1];
                while (next === ' ' || next === '\t')
                    next = source[++i + 1];
            }
            else if (next === 'x' || next === 'u' || next === 'U') {
                const length = { x: 2, u: 4, U: 8 }[next];
                res += parseCharCode(source, i + 1, length, onError);
                i += length;
            }
            else {
                const raw = source.substr(i - 1, 2);
                onError(i - 1, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
                res += raw;
            }
        }
        else if (ch === ' ' || ch === '\t') {
            // trim trailing whitespace
            const wsStart = i;
            let next = source[i + 1];
            while (next === ' ' || next === '\t')
                next = source[++i + 1];
            if (next !== '\n' && !(next === '\r' && source[i + 2] === '\n'))
                res += i > wsStart ? source.slice(wsStart, i + 1) : ch;
        }
        else {
            res += ch;
        }
    }
    if (source[source.length - 1] !== '"' || source.length === 1)
        onError(source.length, 'MISSING_CHAR', 'Missing closing "quote');
    return res;
}
/**
 * Fold a single newline into a space, multiple newlines to N - 1 newlines.
 * Presumes `source[offset] === '\n'`
 */
function foldNewline(source, offset) {
    let fold = '';
    let ch = source[offset + 1];
    while (ch === ' ' || ch === '\t' || ch === '\n' || ch === '\r') {
        if (ch === '\r' && source[offset + 2] !== '\n')
            break;
        if (ch === '\n')
            fold += '\n';
        offset += 1;
        ch = source[offset + 1];
    }
    if (!fold)
        fold = ' ';
    return { fold, offset };
}
const escapeCodes = {
    '0': '\0', // null character
    a: '\x07', // bell character
    b: '\b', // backspace
    e: '\x1b', // escape character
    f: '\f', // form feed
    n: '\n', // line feed
    r: '\r', // carriage return
    t: '\t', // horizontal tab
    v: '\v', // vertical tab
    N: '\u0085', // Unicode next line
    _: '\u00a0', // Unicode non-breaking space
    L: '\u2028', // Unicode line separator
    P: '\u2029', // Unicode paragraph separator
    ' ': ' ',
    '"': '"',
    '/': '/',
    '\\': '\\',
    '\t': '\t'
};
function parseCharCode(source, offset, length, onError) {
    const cc = source.substr(offset, length);
    const ok = cc.length === length && /^[0-9a-fA-F]+$/.test(cc);
    const code = ok ? parseInt(cc, 16) : NaN;
    if (isNaN(code)) {
        const raw = source.substr(offset - 2, length + 2);
        onError(offset - 2, 'BAD_DQ_ESCAPE', `Invalid escape sequence ${raw}`);
        return raw;
    }
    return String.fromCodePoint(code);
}

exports.resolveFlowScalar = resolveFlowScalar;


/***/ }),
/* 114 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


function emptyScalarPosition(offset, before, pos) {
    if (before) {
        pos ?? (pos = before.length);
        for (let i = pos - 1; i >= 0; --i) {
            let st = before[i];
            switch (st.type) {
                case 'space':
                case 'comment':
                case 'newline':
                    offset -= st.source.length;
                    continue;
            }
            // Technically, an empty scalar is immediately after the last non-empty
            // node, but it's more useful to place it after any whitespace.
            st = before[++i];
            while (st?.type === 'space') {
                offset += st.source.length;
                st = before[++i];
            }
            break;
        }
    }
    return offset;
}

exports.emptyScalarPosition = emptyScalarPosition;


/***/ }),
/* 115 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cstScalar = __webpack_require__(116);
var cstStringify = __webpack_require__(117);
var cstVisit = __webpack_require__(118);

/** The byte order mark */
const BOM = '\u{FEFF}';
/** Start of doc-mode */
const DOCUMENT = '\x02'; // C0: Start of Text
/** Unexpected end of flow-mode */
const FLOW_END = '\x18'; // C0: Cancel
/** Next token is a scalar value */
const SCALAR = '\x1f'; // C0: Unit Separator
/** @returns `true` if `token` is a flow or block collection */
const isCollection = (token) => !!token && 'items' in token;
/** @returns `true` if `token` is a flow or block scalar; not an alias */
const isScalar = (token) => !!token &&
    (token.type === 'scalar' ||
        token.type === 'single-quoted-scalar' ||
        token.type === 'double-quoted-scalar' ||
        token.type === 'block-scalar');
/* istanbul ignore next */
/** Get a printable representation of a lexer token */
function prettyToken(token) {
    switch (token) {
        case BOM:
            return '<BOM>';
        case DOCUMENT:
            return '<DOC>';
        case FLOW_END:
            return '<FLOW_END>';
        case SCALAR:
            return '<SCALAR>';
        default:
            return JSON.stringify(token);
    }
}
/** Identify the type of a lexer token. May return `null` for unknown tokens. */
function tokenType(source) {
    switch (source) {
        case BOM:
            return 'byte-order-mark';
        case DOCUMENT:
            return 'doc-mode';
        case FLOW_END:
            return 'flow-error-end';
        case SCALAR:
            return 'scalar';
        case '---':
            return 'doc-start';
        case '...':
            return 'doc-end';
        case '':
        case '\n':
        case '\r\n':
            return 'newline';
        case '-':
            return 'seq-item-ind';
        case '?':
            return 'explicit-key-ind';
        case ':':
            return 'map-value-ind';
        case '{':
            return 'flow-map-start';
        case '}':
            return 'flow-map-end';
        case '[':
            return 'flow-seq-start';
        case ']':
            return 'flow-seq-end';
        case ',':
            return 'comma';
    }
    switch (source[0]) {
        case ' ':
        case '\t':
            return 'space';
        case '#':
            return 'comment';
        case '%':
            return 'directive-line';
        case '*':
            return 'alias';
        case '&':
            return 'anchor';
        case '!':
            return 'tag';
        case "'":
            return 'single-quoted-scalar';
        case '"':
            return 'double-quoted-scalar';
        case '|':
        case '>':
            return 'block-scalar-header';
    }
    return null;
}

exports.createScalarToken = cstScalar.createScalarToken;
exports.resolveAsScalar = cstScalar.resolveAsScalar;
exports.setScalarValue = cstScalar.setScalarValue;
exports.stringify = cstStringify.stringify;
exports.visit = cstVisit.visit;
exports.BOM = BOM;
exports.DOCUMENT = DOCUMENT;
exports.FLOW_END = FLOW_END;
exports.SCALAR = SCALAR;
exports.isCollection = isCollection;
exports.isScalar = isScalar;
exports.prettyToken = prettyToken;
exports.tokenType = tokenType;


/***/ }),
/* 116 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var resolveBlockScalar = __webpack_require__(112);
var resolveFlowScalar = __webpack_require__(113);
var errors = __webpack_require__(99);
var stringifyString = __webpack_require__(68);

function resolveAsScalar(token, strict = true, onError) {
    if (token) {
        const _onError = (pos, code, message) => {
            const offset = typeof pos === 'number' ? pos : Array.isArray(pos) ? pos[0] : pos.offset;
            if (onError)
                onError(offset, code, message);
            else
                throw new errors.YAMLParseError([offset, offset + 1], code, message);
        };
        switch (token.type) {
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return resolveFlowScalar.resolveFlowScalar(token, strict, _onError);
            case 'block-scalar':
                return resolveBlockScalar.resolveBlockScalar({ options: { strict } }, token, _onError);
        }
    }
    return null;
}
/**
 * Create a new scalar token with `value`
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.end Comments and whitespace after the end of the value, or after the block scalar header. If undefined, a newline will be added.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.indent The indent level of the token.
 * @param context.inFlow Is this scalar within a flow collection? This may affect the resolved type of the token's value.
 * @param context.offset The offset position of the token.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function createScalarToken(value, context) {
    const { implicitKey = false, indent, inFlow = false, offset = -1, type = 'PLAIN' } = context;
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey,
        indent: indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    const end = context.end ?? [
        { type: 'newline', offset: -1, indent, source: '\n' }
    ];
    switch (source[0]) {
        case '|':
        case '>': {
            const he = source.indexOf('\n');
            const head = source.substring(0, he);
            const body = source.substring(he + 1) + '\n';
            const props = [
                { type: 'block-scalar-header', offset, indent, source: head }
            ];
            if (!addEndtoBlockProps(props, end))
                props.push({ type: 'newline', offset: -1, indent, source: '\n' });
            return { type: 'block-scalar', offset, indent, props, source: body };
        }
        case '"':
            return { type: 'double-quoted-scalar', offset, indent, source, end };
        case "'":
            return { type: 'single-quoted-scalar', offset, indent, source, end };
        default:
            return { type: 'scalar', offset, indent, source, end };
    }
}
/**
 * Set the value of `token` to the given string `value`, overwriting any previous contents and type that it may have.
 *
 * Best efforts are made to retain any comments previously associated with the `token`,
 * though all contents within a collection's `items` will be overwritten.
 *
 * Values that represent an actual string but may be parsed as a different type should use a `type` other than `'PLAIN'`,
 * as this function does not support any schema operations and won't check for such conflicts.
 *
 * @param token Any token. If it does not include an `indent` value, the value will be stringified as if it were an implicit key.
 * @param value The string representation of the value, which will have its content properly indented.
 * @param context.afterKey In most cases, values after a key should have an additional level of indentation.
 * @param context.implicitKey Being within an implicit key may affect the resolved type of the token's value.
 * @param context.inFlow Being within a flow collection may affect the resolved type of the token's value.
 * @param context.type The preferred type of the scalar token. If undefined, the previous type of the `token` will be used, defaulting to `'PLAIN'`.
 */
function setScalarValue(token, value, context = {}) {
    let { afterKey = false, implicitKey = false, inFlow = false, type } = context;
    let indent = 'indent' in token ? token.indent : null;
    if (afterKey && typeof indent === 'number')
        indent += 2;
    if (!type)
        switch (token.type) {
            case 'single-quoted-scalar':
                type = 'QUOTE_SINGLE';
                break;
            case 'double-quoted-scalar':
                type = 'QUOTE_DOUBLE';
                break;
            case 'block-scalar': {
                const header = token.props[0];
                if (header.type !== 'block-scalar-header')
                    throw new Error('Invalid block scalar header');
                type = header.source[0] === '>' ? 'BLOCK_FOLDED' : 'BLOCK_LITERAL';
                break;
            }
            default:
                type = 'PLAIN';
        }
    const source = stringifyString.stringifyString({ type, value }, {
        implicitKey: implicitKey || indent === null,
        indent: indent !== null && indent > 0 ? ' '.repeat(indent) : '',
        inFlow,
        options: { blockQuote: true, lineWidth: -1 }
    });
    switch (source[0]) {
        case '|':
        case '>':
            setBlockScalarValue(token, source);
            break;
        case '"':
            setFlowScalarValue(token, source, 'double-quoted-scalar');
            break;
        case "'":
            setFlowScalarValue(token, source, 'single-quoted-scalar');
            break;
        default:
            setFlowScalarValue(token, source, 'scalar');
    }
}
function setBlockScalarValue(token, source) {
    const he = source.indexOf('\n');
    const head = source.substring(0, he);
    const body = source.substring(he + 1) + '\n';
    if (token.type === 'block-scalar') {
        const header = token.props[0];
        if (header.type !== 'block-scalar-header')
            throw new Error('Invalid block scalar header');
        header.source = head;
        token.source = body;
    }
    else {
        const { offset } = token;
        const indent = 'indent' in token ? token.indent : -1;
        const props = [
            { type: 'block-scalar-header', offset, indent, source: head }
        ];
        if (!addEndtoBlockProps(props, 'end' in token ? token.end : undefined))
            props.push({ type: 'newline', offset: -1, indent, source: '\n' });
        for (const key of Object.keys(token))
            if (key !== 'type' && key !== 'offset')
                delete token[key];
        Object.assign(token, { type: 'block-scalar', indent, props, source: body });
    }
}
/** @returns `true` if last token is a newline */
function addEndtoBlockProps(props, end) {
    if (end)
        for (const st of end)
            switch (st.type) {
                case 'space':
                case 'comment':
                    props.push(st);
                    break;
                case 'newline':
                    props.push(st);
                    return true;
            }
    return false;
}
function setFlowScalarValue(token, source, type) {
    switch (token.type) {
        case 'scalar':
        case 'double-quoted-scalar':
        case 'single-quoted-scalar':
            token.type = type;
            token.source = source;
            break;
        case 'block-scalar': {
            const end = token.props.slice(1);
            let oa = source.length;
            if (token.props[0].type === 'block-scalar-header')
                oa -= token.props[0].source.length;
            for (const tok of end)
                tok.offset += oa;
            delete token.props;
            Object.assign(token, { type, source, end });
            break;
        }
        case 'block-map':
        case 'block-seq': {
            const offset = token.offset + source.length;
            const nl = { type: 'newline', offset, indent: token.indent, source: '\n' };
            delete token.items;
            Object.assign(token, { type, source, end: [nl] });
            break;
        }
        default: {
            const indent = 'indent' in token ? token.indent : -1;
            const end = 'end' in token && Array.isArray(token.end)
                ? token.end.filter(st => st.type === 'space' ||
                    st.type === 'comment' ||
                    st.type === 'newline')
                : [];
            for (const key of Object.keys(token))
                if (key !== 'type' && key !== 'offset')
                    delete token[key];
            Object.assign(token, { type, indent, source, end });
        }
    }
}

exports.createScalarToken = createScalarToken;
exports.resolveAsScalar = resolveAsScalar;
exports.setScalarValue = setScalarValue;


/***/ }),
/* 117 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Stringify a CST document, token, or collection item
 *
 * Fair warning: This applies no validation whatsoever, and
 * simply concatenates the sources in their logical order.
 */
const stringify = (cst) => 'type' in cst ? stringifyToken(cst) : stringifyItem(cst);
function stringifyToken(token) {
    switch (token.type) {
        case 'block-scalar': {
            let res = '';
            for (const tok of token.props)
                res += stringifyToken(tok);
            return res + token.source;
        }
        case 'block-map':
        case 'block-seq': {
            let res = '';
            for (const item of token.items)
                res += stringifyItem(item);
            return res;
        }
        case 'flow-collection': {
            let res = token.start.source;
            for (const item of token.items)
                res += stringifyItem(item);
            for (const st of token.end)
                res += st.source;
            return res;
        }
        case 'document': {
            let res = stringifyItem(token);
            if (token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
        default: {
            let res = token.source;
            if ('end' in token && token.end)
                for (const st of token.end)
                    res += st.source;
            return res;
        }
    }
}
function stringifyItem({ start, key, sep, value }) {
    let res = '';
    for (const st of start)
        res += st.source;
    if (key)
        res += stringifyToken(key);
    if (sep)
        for (const st of sep)
            res += st.source;
    if (value)
        res += stringifyToken(value);
    return res;
}

exports.stringify = stringify;


/***/ }),
/* 118 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const BREAK = Symbol('break visit');
const SKIP = Symbol('skip children');
const REMOVE = Symbol('remove item');
/**
 * Apply a visitor to a CST document or item.
 *
 * Walks through the tree (depth-first) starting from the root, calling a
 * `visitor` function with two arguments when entering each item:
 *   - `item`: The current item, which included the following members:
 *     - `start: SourceToken[]` – Source tokens before the key or value,
 *       possibly including its anchor or tag.
 *     - `key?: Token | null` – Set for pair values. May then be `null`, if
 *       the key before the `:` separator is empty.
 *     - `sep?: SourceToken[]` – Source tokens between the key and the value,
 *       which should include the `:` map value indicator if `value` is set.
 *     - `value?: Token` – The value of a sequence item, or of a map pair.
 *   - `path`: The steps from the root to the current node, as an array of
 *     `['key' | 'value', number]` tuples.
 *
 * The return value of the visitor may be used to control the traversal:
 *   - `undefined` (default): Do nothing and continue
 *   - `visit.SKIP`: Do not visit the children of this token, continue with
 *      next sibling
 *   - `visit.BREAK`: Terminate traversal completely
 *   - `visit.REMOVE`: Remove the current item, then continue with the next one
 *   - `number`: Set the index of the next step. This is useful especially if
 *     the index of the current token has changed.
 *   - `function`: Define the next visitor for this item. After the original
 *     visitor is called on item entry, next visitors are called after handling
 *     a non-empty `key` and when exiting the item.
 */
function visit(cst, visitor) {
    if ('type' in cst && cst.type === 'document')
        cst = { start: cst.start, value: cst.value };
    _visit(Object.freeze([]), cst, visitor);
}
// Without the `as symbol` casts, TS declares these in the `visit`
// namespace using `var`, but then complains about that because
// `unique symbol` must be `const`.
/** Terminate visit traversal completely */
visit.BREAK = BREAK;
/** Do not visit the children of the current item */
visit.SKIP = SKIP;
/** Remove the current item */
visit.REMOVE = REMOVE;
/** Find the item at `path` from `cst` as the root */
visit.itemAtPath = (cst, path) => {
    let item = cst;
    for (const [field, index] of path) {
        const tok = item?.[field];
        if (tok && 'items' in tok) {
            item = tok.items[index];
        }
        else
            return undefined;
    }
    return item;
};
/**
 * Get the immediate parent collection of the item at `path` from `cst` as the root.
 *
 * Throws an error if the collection is not found, which should never happen if the item itself exists.
 */
visit.parentCollection = (cst, path) => {
    const parent = visit.itemAtPath(cst, path.slice(0, -1));
    const field = path[path.length - 1][0];
    const coll = parent?.[field];
    if (coll && 'items' in coll)
        return coll;
    throw new Error('Parent collection not found');
};
function _visit(path, item, visitor) {
    let ctrl = visitor(item, path);
    if (typeof ctrl === 'symbol')
        return ctrl;
    for (const field of ['key', 'value']) {
        const token = item[field];
        if (token && 'items' in token) {
            for (let i = 0; i < token.items.length; ++i) {
                const ci = _visit(Object.freeze(path.concat([[field, i]])), token.items[i], visitor);
                if (typeof ci === 'number')
                    i = ci - 1;
                else if (ci === BREAK)
                    return BREAK;
                else if (ci === REMOVE) {
                    token.items.splice(i, 1);
                    i -= 1;
                }
            }
            if (typeof ctrl === 'function' && field === 'key')
                ctrl = ctrl(item, path);
        }
    }
    return typeof ctrl === 'function' ? ctrl(item, path) : ctrl;
}

exports.visit = visit;


/***/ }),
/* 119 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var cst = __webpack_require__(115);

/*
START -> stream

stream
  directive -> line-end -> stream
  indent + line-end -> stream
  [else] -> line-start

line-end
  comment -> line-end
  newline -> .
  input-end -> END

line-start
  doc-start -> doc
  doc-end -> stream
  [else] -> indent -> block-start

block-start
  seq-item-start -> block-start
  explicit-key-start -> block-start
  map-value-start -> block-start
  [else] -> doc

doc
  line-end -> line-start
  spaces -> doc
  anchor -> doc
  tag -> doc
  flow-start -> flow -> doc
  flow-end -> error -> doc
  seq-item-start -> error -> doc
  explicit-key-start -> error -> doc
  map-value-start -> doc
  alias -> doc
  quote-start -> quoted-scalar -> doc
  block-scalar-header -> line-end -> block-scalar(min) -> line-start
  [else] -> plain-scalar(false, min) -> doc

flow
  line-end -> flow
  spaces -> flow
  anchor -> flow
  tag -> flow
  flow-start -> flow -> flow
  flow-end -> .
  seq-item-start -> error -> flow
  explicit-key-start -> flow
  map-value-start -> flow
  alias -> flow
  quote-start -> quoted-scalar -> flow
  comma -> flow
  [else] -> plain-scalar(true, 0) -> flow

quoted-scalar
  quote-end -> .
  [else] -> quoted-scalar

block-scalar(min)
  newline + peek(indent < min) -> .
  [else] -> block-scalar(min)

plain-scalar(is-flow, min)
  scalar-end(is-flow) -> .
  peek(newline + (indent < min)) -> .
  [else] -> plain-scalar(min)
*/
function isEmpty(ch) {
    switch (ch) {
        case undefined:
        case ' ':
        case '\n':
        case '\r':
        case '\t':
            return true;
        default:
            return false;
    }
}
const hexDigits = new Set('0123456789ABCDEFabcdef');
const tagChars = new Set("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-#;/?:@&=+$_.!~*'()");
const flowIndicatorChars = new Set(',[]{}');
const invalidAnchorChars = new Set(' ,[]{}\n\r\t');
const isNotAnchorChar = (ch) => !ch || invalidAnchorChars.has(ch);
/**
 * Splits an input string into lexical tokens, i.e. smaller strings that are
 * easily identifiable by `tokens.tokenType()`.
 *
 * Lexing starts always in a "stream" context. Incomplete input may be buffered
 * until a complete token can be emitted.
 *
 * In addition to slices of the original input, the following control characters
 * may also be emitted:
 *
 * - `\x02` (Start of Text): A document starts with the next token
 * - `\x18` (Cancel): Unexpected end of flow-mode (indicates an error)
 * - `\x1f` (Unit Separator): Next token is a scalar value
 * - `\u{FEFF}` (Byte order mark): Emitted separately outside documents
 */
class Lexer {
    constructor() {
        /**
         * Flag indicating whether the end of the current buffer marks the end of
         * all input
         */
        this.atEnd = false;
        /**
         * Explicit indent set in block scalar header, as an offset from the current
         * minimum indent, so e.g. set to 1 from a header `|2+`. Set to -1 if not
         * explicitly set.
         */
        this.blockScalarIndent = -1;
        /**
         * Block scalars that include a + (keep) chomping indicator in their header
         * include trailing empty lines, which are otherwise excluded from the
         * scalar's contents.
         */
        this.blockScalarKeep = false;
        /** Current input */
        this.buffer = '';
        /**
         * Flag noting whether the map value indicator : can immediately follow this
         * node within a flow context.
         */
        this.flowKey = false;
        /** Count of surrounding flow collection levels. */
        this.flowLevel = 0;
        /**
         * Minimum level of indentation required for next lines to be parsed as a
         * part of the current scalar value.
         */
        this.indentNext = 0;
        /** Indentation level of the current line. */
        this.indentValue = 0;
        /** Position of the next \n character. */
        this.lineEndPos = null;
        /** Stores the state of the lexer if reaching the end of incpomplete input */
        this.next = null;
        /** A pointer to `buffer`; the current position of the lexer. */
        this.pos = 0;
    }
    /**
     * Generate YAML tokens from the `source` string. If `incomplete`,
     * a part of the last line may be left as a buffer for the next call.
     *
     * @returns A generator of lexical tokens
     */
    *lex(source, incomplete = false) {
        if (source) {
            if (typeof source !== 'string')
                throw TypeError('source is not a string');
            this.buffer = this.buffer ? this.buffer + source : source;
            this.lineEndPos = null;
        }
        this.atEnd = !incomplete;
        let next = this.next ?? 'stream';
        while (next && (incomplete || this.hasChars(1)))
            next = yield* this.parseNext(next);
    }
    atLineEnd() {
        let i = this.pos;
        let ch = this.buffer[i];
        while (ch === ' ' || ch === '\t')
            ch = this.buffer[++i];
        if (!ch || ch === '#' || ch === '\n')
            return true;
        if (ch === '\r')
            return this.buffer[i + 1] === '\n';
        return false;
    }
    charAt(n) {
        return this.buffer[this.pos + n];
    }
    continueScalar(offset) {
        let ch = this.buffer[offset];
        if (this.indentNext > 0) {
            let indent = 0;
            while (ch === ' ')
                ch = this.buffer[++indent + offset];
            if (ch === '\r') {
                const next = this.buffer[indent + offset + 1];
                if (next === '\n' || (!next && !this.atEnd))
                    return offset + indent + 1;
            }
            return ch === '\n' || indent >= this.indentNext || (!ch && !this.atEnd)
                ? offset + indent
                : -1;
        }
        if (ch === '-' || ch === '.') {
            const dt = this.buffer.substr(offset, 3);
            if ((dt === '---' || dt === '...') && isEmpty(this.buffer[offset + 3]))
                return -1;
        }
        return offset;
    }
    getLine() {
        let end = this.lineEndPos;
        if (typeof end !== 'number' || (end !== -1 && end < this.pos)) {
            end = this.buffer.indexOf('\n', this.pos);
            this.lineEndPos = end;
        }
        if (end === -1)
            return this.atEnd ? this.buffer.substring(this.pos) : null;
        if (this.buffer[end - 1] === '\r')
            end -= 1;
        return this.buffer.substring(this.pos, end);
    }
    hasChars(n) {
        return this.pos + n <= this.buffer.length;
    }
    setNext(state) {
        this.buffer = this.buffer.substring(this.pos);
        this.pos = 0;
        this.lineEndPos = null;
        this.next = state;
        return null;
    }
    peek(n) {
        return this.buffer.substr(this.pos, n);
    }
    *parseNext(next) {
        switch (next) {
            case 'stream':
                return yield* this.parseStream();
            case 'line-start':
                return yield* this.parseLineStart();
            case 'block-start':
                return yield* this.parseBlockStart();
            case 'doc':
                return yield* this.parseDocument();
            case 'flow':
                return yield* this.parseFlowCollection();
            case 'quoted-scalar':
                return yield* this.parseQuotedScalar();
            case 'block-scalar':
                return yield* this.parseBlockScalar();
            case 'plain-scalar':
                return yield* this.parsePlainScalar();
        }
    }
    *parseStream() {
        let line = this.getLine();
        if (line === null)
            return this.setNext('stream');
        if (line[0] === cst.BOM) {
            yield* this.pushCount(1);
            line = line.substring(1);
        }
        if (line[0] === '%') {
            let dirEnd = line.length;
            let cs = line.indexOf('#');
            while (cs !== -1) {
                const ch = line[cs - 1];
                if (ch === ' ' || ch === '\t') {
                    dirEnd = cs - 1;
                    break;
                }
                else {
                    cs = line.indexOf('#', cs + 1);
                }
            }
            while (true) {
                const ch = line[dirEnd - 1];
                if (ch === ' ' || ch === '\t')
                    dirEnd -= 1;
                else
                    break;
            }
            const n = (yield* this.pushCount(dirEnd)) + (yield* this.pushSpaces(true));
            yield* this.pushCount(line.length - n); // possible comment
            this.pushNewline();
            return 'stream';
        }
        if (this.atLineEnd()) {
            const sp = yield* this.pushSpaces(true);
            yield* this.pushCount(line.length - sp);
            yield* this.pushNewline();
            return 'stream';
        }
        yield cst.DOCUMENT;
        return yield* this.parseLineStart();
    }
    *parseLineStart() {
        const ch = this.charAt(0);
        if (!ch && !this.atEnd)
            return this.setNext('line-start');
        if (ch === '-' || ch === '.') {
            if (!this.atEnd && !this.hasChars(4))
                return this.setNext('line-start');
            const s = this.peek(3);
            if ((s === '---' || s === '...') && isEmpty(this.charAt(3))) {
                yield* this.pushCount(3);
                this.indentValue = 0;
                this.indentNext = 0;
                return s === '---' ? 'doc' : 'stream';
            }
        }
        this.indentValue = yield* this.pushSpaces(false);
        if (this.indentNext > this.indentValue && !isEmpty(this.charAt(1)))
            this.indentNext = this.indentValue;
        return yield* this.parseBlockStart();
    }
    *parseBlockStart() {
        const [ch0, ch1] = this.peek(2);
        if (!ch1 && !this.atEnd)
            return this.setNext('block-start');
        if ((ch0 === '-' || ch0 === '?' || ch0 === ':') && isEmpty(ch1)) {
            const n = (yield* this.pushCount(1)) + (yield* this.pushSpaces(true));
            this.indentNext = this.indentValue + 1;
            this.indentValue += n;
            return yield* this.parseBlockStart();
        }
        return 'doc';
    }
    *parseDocument() {
        yield* this.pushSpaces(true);
        const line = this.getLine();
        if (line === null)
            return this.setNext('doc');
        let n = yield* this.pushIndicators();
        switch (line[n]) {
            case '#':
                yield* this.pushCount(line.length - n);
            // fallthrough
            case undefined:
                yield* this.pushNewline();
                return yield* this.parseLineStart();
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel = 1;
                return 'flow';
            case '}':
            case ']':
                // this is an error
                yield* this.pushCount(1);
                return 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'doc';
            case '"':
            case "'":
                return yield* this.parseQuotedScalar();
            case '|':
            case '>':
                n += yield* this.parseBlockScalarHeader();
                n += yield* this.pushSpaces(true);
                yield* this.pushCount(line.length - n);
                yield* this.pushNewline();
                return yield* this.parseBlockScalar();
            default:
                return yield* this.parsePlainScalar();
        }
    }
    *parseFlowCollection() {
        let nl, sp;
        let indent = -1;
        do {
            nl = yield* this.pushNewline();
            if (nl > 0) {
                sp = yield* this.pushSpaces(false);
                this.indentValue = indent = sp;
            }
            else {
                sp = 0;
            }
            sp += yield* this.pushSpaces(true);
        } while (nl + sp > 0);
        const line = this.getLine();
        if (line === null)
            return this.setNext('flow');
        if ((indent !== -1 && indent < this.indentNext && line[0] !== '#') ||
            (indent === 0 &&
                (line.startsWith('---') || line.startsWith('...')) &&
                isEmpty(line[3]))) {
            // Allowing for the terminal ] or } at the same (rather than greater)
            // indent level as the initial [ or { is technically invalid, but
            // failing here would be surprising to users.
            const atFlowEndMarker = indent === this.indentNext - 1 &&
                this.flowLevel === 1 &&
                (line[0] === ']' || line[0] === '}');
            if (!atFlowEndMarker) {
                // this is an error
                this.flowLevel = 0;
                yield cst.FLOW_END;
                return yield* this.parseLineStart();
            }
        }
        let n = 0;
        while (line[n] === ',') {
            n += yield* this.pushCount(1);
            n += yield* this.pushSpaces(true);
            this.flowKey = false;
        }
        n += yield* this.pushIndicators();
        switch (line[n]) {
            case undefined:
                return 'flow';
            case '#':
                yield* this.pushCount(line.length - n);
                return 'flow';
            case '{':
            case '[':
                yield* this.pushCount(1);
                this.flowKey = false;
                this.flowLevel += 1;
                return 'flow';
            case '}':
            case ']':
                yield* this.pushCount(1);
                this.flowKey = true;
                this.flowLevel -= 1;
                return this.flowLevel ? 'flow' : 'doc';
            case '*':
                yield* this.pushUntil(isNotAnchorChar);
                return 'flow';
            case '"':
            case "'":
                this.flowKey = true;
                return yield* this.parseQuotedScalar();
            case ':': {
                const next = this.charAt(1);
                if (this.flowKey || isEmpty(next) || next === ',') {
                    this.flowKey = false;
                    yield* this.pushCount(1);
                    yield* this.pushSpaces(true);
                    return 'flow';
                }
            }
            // fallthrough
            default:
                this.flowKey = false;
                return yield* this.parsePlainScalar();
        }
    }
    *parseQuotedScalar() {
        const quote = this.charAt(0);
        let end = this.buffer.indexOf(quote, this.pos + 1);
        if (quote === "'") {
            while (end !== -1 && this.buffer[end + 1] === "'")
                end = this.buffer.indexOf("'", end + 2);
        }
        else {
            // double-quote
            while (end !== -1) {
                let n = 0;
                while (this.buffer[end - 1 - n] === '\\')
                    n += 1;
                if (n % 2 === 0)
                    break;
                end = this.buffer.indexOf('"', end + 1);
            }
        }
        // Only looking for newlines within the quotes
        const qb = this.buffer.substring(0, end);
        let nl = qb.indexOf('\n', this.pos);
        if (nl !== -1) {
            while (nl !== -1) {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = qb.indexOf('\n', cs);
            }
            if (nl !== -1) {
                // this is an error caused by an unexpected unindent
                end = nl - (qb[nl - 1] === '\r' ? 2 : 1);
            }
        }
        if (end === -1) {
            if (!this.atEnd)
                return this.setNext('quoted-scalar');
            end = this.buffer.length;
        }
        yield* this.pushToIndex(end + 1, false);
        return this.flowLevel ? 'flow' : 'doc';
    }
    *parseBlockScalarHeader() {
        this.blockScalarIndent = -1;
        this.blockScalarKeep = false;
        let i = this.pos;
        while (true) {
            const ch = this.buffer[++i];
            if (ch === '+')
                this.blockScalarKeep = true;
            else if (ch > '0' && ch <= '9')
                this.blockScalarIndent = Number(ch) - 1;
            else if (ch !== '-')
                break;
        }
        return yield* this.pushUntil(ch => isEmpty(ch) || ch === '#');
    }
    *parseBlockScalar() {
        let nl = this.pos - 1; // may be -1 if this.pos === 0
        let indent = 0;
        let ch;
        loop: for (let i = this.pos; (ch = this.buffer[i]); ++i) {
            switch (ch) {
                case ' ':
                    indent += 1;
                    break;
                case '\n':
                    nl = i;
                    indent = 0;
                    break;
                case '\r': {
                    const next = this.buffer[i + 1];
                    if (!next && !this.atEnd)
                        return this.setNext('block-scalar');
                    if (next === '\n')
                        break;
                } // fallthrough
                default:
                    break loop;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('block-scalar');
        if (indent >= this.indentNext) {
            if (this.blockScalarIndent === -1)
                this.indentNext = indent;
            else {
                this.indentNext =
                    this.blockScalarIndent + (this.indentNext === 0 ? 1 : this.indentNext);
            }
            do {
                const cs = this.continueScalar(nl + 1);
                if (cs === -1)
                    break;
                nl = this.buffer.indexOf('\n', cs);
            } while (nl !== -1);
            if (nl === -1) {
                if (!this.atEnd)
                    return this.setNext('block-scalar');
                nl = this.buffer.length;
            }
        }
        // Trailing insufficiently indented tabs are invalid.
        // To catch that during parsing, we include them in the block scalar value.
        let i = nl + 1;
        ch = this.buffer[i];
        while (ch === ' ')
            ch = this.buffer[++i];
        if (ch === '\t') {
            while (ch === '\t' || ch === ' ' || ch === '\r' || ch === '\n')
                ch = this.buffer[++i];
            nl = i - 1;
        }
        else if (!this.blockScalarKeep) {
            do {
                let i = nl - 1;
                let ch = this.buffer[i];
                if (ch === '\r')
                    ch = this.buffer[--i];
                const lastChar = i; // Drop the line if last char not more indented
                while (ch === ' ')
                    ch = this.buffer[--i];
                if (ch === '\n' && i >= this.pos && i + 1 + indent > lastChar)
                    nl = i;
                else
                    break;
            } while (true);
        }
        yield cst.SCALAR;
        yield* this.pushToIndex(nl + 1, true);
        return yield* this.parseLineStart();
    }
    *parsePlainScalar() {
        const inFlow = this.flowLevel > 0;
        let end = this.pos - 1;
        let i = this.pos - 1;
        let ch;
        while ((ch = this.buffer[++i])) {
            if (ch === ':') {
                const next = this.buffer[i + 1];
                if (isEmpty(next) || (inFlow && flowIndicatorChars.has(next)))
                    break;
                end = i;
            }
            else if (isEmpty(ch)) {
                let next = this.buffer[i + 1];
                if (ch === '\r') {
                    if (next === '\n') {
                        i += 1;
                        ch = '\n';
                        next = this.buffer[i + 1];
                    }
                    else
                        end = i;
                }
                if (next === '#' || (inFlow && flowIndicatorChars.has(next)))
                    break;
                if (ch === '\n') {
                    const cs = this.continueScalar(i + 1);
                    if (cs === -1)
                        break;
                    i = Math.max(i, cs - 2); // to advance, but still account for ' #'
                }
            }
            else {
                if (inFlow && flowIndicatorChars.has(ch))
                    break;
                end = i;
            }
        }
        if (!ch && !this.atEnd)
            return this.setNext('plain-scalar');
        yield cst.SCALAR;
        yield* this.pushToIndex(end + 1, true);
        return inFlow ? 'flow' : 'doc';
    }
    *pushCount(n) {
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos += n;
            return n;
        }
        return 0;
    }
    *pushToIndex(i, allowEmpty) {
        const s = this.buffer.slice(this.pos, i);
        if (s) {
            yield s;
            this.pos += s.length;
            return s.length;
        }
        else if (allowEmpty)
            yield '';
        return 0;
    }
    *pushIndicators() {
        switch (this.charAt(0)) {
            case '!':
                return ((yield* this.pushTag()) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '&':
                return ((yield* this.pushUntil(isNotAnchorChar)) +
                    (yield* this.pushSpaces(true)) +
                    (yield* this.pushIndicators()));
            case '-': // this is an error
            case '?': // this is an error outside flow collections
            case ':': {
                const inFlow = this.flowLevel > 0;
                const ch1 = this.charAt(1);
                if (isEmpty(ch1) || (inFlow && flowIndicatorChars.has(ch1))) {
                    if (!inFlow)
                        this.indentNext = this.indentValue + 1;
                    else if (this.flowKey)
                        this.flowKey = false;
                    return ((yield* this.pushCount(1)) +
                        (yield* this.pushSpaces(true)) +
                        (yield* this.pushIndicators()));
                }
            }
        }
        return 0;
    }
    *pushTag() {
        if (this.charAt(1) === '<') {
            let i = this.pos + 2;
            let ch = this.buffer[i];
            while (!isEmpty(ch) && ch !== '>')
                ch = this.buffer[++i];
            return yield* this.pushToIndex(ch === '>' ? i + 1 : i, false);
        }
        else {
            let i = this.pos + 1;
            let ch = this.buffer[i];
            while (ch) {
                if (tagChars.has(ch))
                    ch = this.buffer[++i];
                else if (ch === '%' &&
                    hexDigits.has(this.buffer[i + 1]) &&
                    hexDigits.has(this.buffer[i + 2])) {
                    ch = this.buffer[(i += 3)];
                }
                else
                    break;
            }
            return yield* this.pushToIndex(i, false);
        }
    }
    *pushNewline() {
        const ch = this.buffer[this.pos];
        if (ch === '\n')
            return yield* this.pushCount(1);
        else if (ch === '\r' && this.charAt(1) === '\n')
            return yield* this.pushCount(2);
        else
            return 0;
    }
    *pushSpaces(allowTabs) {
        let i = this.pos - 1;
        let ch;
        do {
            ch = this.buffer[++i];
        } while (ch === ' ' || (allowTabs && ch === '\t'));
        const n = i - this.pos;
        if (n > 0) {
            yield this.buffer.substr(this.pos, n);
            this.pos = i;
        }
        return n;
    }
    *pushUntil(test) {
        let i = this.pos;
        let ch = this.buffer[i];
        while (!test(ch))
            ch = this.buffer[++i];
        return yield* this.pushToIndex(i, false);
    }
}

exports.Lexer = Lexer;


/***/ }),
/* 120 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * Tracks newlines during parsing in order to provide an efficient API for
 * determining the one-indexed `{ line, col }` position for any offset
 * within the input.
 */
class LineCounter {
    constructor() {
        this.lineStarts = [];
        /**
         * Should be called in ascending order. Otherwise, call
         * `lineCounter.lineStarts.sort()` before calling `linePos()`.
         */
        this.addNewLine = (offset) => this.lineStarts.push(offset);
        /**
         * Performs a binary search and returns the 1-indexed { line, col }
         * position of `offset`. If `line === 0`, `addNewLine` has never been
         * called or `offset` is before the first known newline.
         */
        this.linePos = (offset) => {
            let low = 0;
            let high = this.lineStarts.length;
            while (low < high) {
                const mid = (low + high) >> 1; // Math.floor((low + high) / 2)
                if (this.lineStarts[mid] < offset)
                    low = mid + 1;
                else
                    high = mid;
            }
            if (this.lineStarts[low] === offset)
                return { line: low + 1, col: 1 };
            if (low === 0)
                return { line: 0, col: offset };
            const start = this.lineStarts[low - 1];
            return { line: low, col: offset - start + 1 };
        };
    }
}

exports.LineCounter = LineCounter;


/***/ }),
/* 121 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var node_process = __webpack_require__(51);
var cst = __webpack_require__(115);
var lexer = __webpack_require__(119);

function includesToken(list, type) {
    for (let i = 0; i < list.length; ++i)
        if (list[i].type === type)
            return true;
    return false;
}
function findNonEmptyIndex(list) {
    for (let i = 0; i < list.length; ++i) {
        switch (list[i].type) {
            case 'space':
            case 'comment':
            case 'newline':
                break;
            default:
                return i;
        }
    }
    return -1;
}
function isFlowToken(token) {
    switch (token?.type) {
        case 'alias':
        case 'scalar':
        case 'single-quoted-scalar':
        case 'double-quoted-scalar':
        case 'flow-collection':
            return true;
        default:
            return false;
    }
}
function getPrevProps(parent) {
    switch (parent.type) {
        case 'document':
            return parent.start;
        case 'block-map': {
            const it = parent.items[parent.items.length - 1];
            return it.sep ?? it.start;
        }
        case 'block-seq':
            return parent.items[parent.items.length - 1].start;
        /* istanbul ignore next should not happen */
        default:
            return [];
    }
}
/** Note: May modify input array */
function getFirstKeyStartProps(prev) {
    if (prev.length === 0)
        return [];
    let i = prev.length;
    loop: while (--i >= 0) {
        switch (prev[i].type) {
            case 'doc-start':
            case 'explicit-key-ind':
            case 'map-value-ind':
            case 'seq-item-ind':
            case 'newline':
                break loop;
        }
    }
    while (prev[++i]?.type === 'space') {
        /* loop */
    }
    return prev.splice(i, prev.length);
}
function fixFlowSeqItems(fc) {
    if (fc.start.type === 'flow-seq-start') {
        for (const it of fc.items) {
            if (it.sep &&
                !it.value &&
                !includesToken(it.start, 'explicit-key-ind') &&
                !includesToken(it.sep, 'map-value-ind')) {
                if (it.key)
                    it.value = it.key;
                delete it.key;
                if (isFlowToken(it.value)) {
                    if (it.value.end)
                        Array.prototype.push.apply(it.value.end, it.sep);
                    else
                        it.value.end = it.sep;
                }
                else
                    Array.prototype.push.apply(it.start, it.sep);
                delete it.sep;
            }
        }
    }
}
/**
 * A YAML concrete syntax tree (CST) parser
 *
 * ```ts
 * const src: string = ...
 * for (const token of new Parser().parse(src)) {
 *   // token: Token
 * }
 * ```
 *
 * To use the parser with a user-provided lexer:
 *
 * ```ts
 * function* parse(source: string, lexer: Lexer) {
 *   const parser = new Parser()
 *   for (const lexeme of lexer.lex(source))
 *     yield* parser.next(lexeme)
 *   yield* parser.end()
 * }
 *
 * const src: string = ...
 * const lexer = new Lexer()
 * for (const token of parse(src, lexer)) {
 *   // token: Token
 * }
 * ```
 */
class Parser {
    /**
     * @param onNewLine - If defined, called separately with the start position of
     *   each new line (in `parse()`, including the start of input).
     */
    constructor(onNewLine) {
        /** If true, space and sequence indicators count as indentation */
        this.atNewLine = true;
        /** If true, next token is a scalar value */
        this.atScalar = false;
        /** Current indentation level */
        this.indent = 0;
        /** Current offset since the start of parsing */
        this.offset = 0;
        /** On the same line with a block map key */
        this.onKeyLine = false;
        /** Top indicates the node that's currently being built */
        this.stack = [];
        /** The source of the current token, set in parse() */
        this.source = '';
        /** The type of the current token, set in parse() */
        this.type = '';
        // Must be defined after `next()`
        this.lexer = new lexer.Lexer();
        this.onNewLine = onNewLine;
    }
    /**
     * Parse `source` as a YAML stream.
     * If `incomplete`, a part of the last line may be left as a buffer for the next call.
     *
     * Errors are not thrown, but yielded as `{ type: 'error', message }` tokens.
     *
     * @returns A generator of tokens representing each directive, document, and other structure.
     */
    *parse(source, incomplete = false) {
        if (this.onNewLine && this.offset === 0)
            this.onNewLine(0);
        for (const lexeme of this.lexer.lex(source, incomplete))
            yield* this.next(lexeme);
        if (!incomplete)
            yield* this.end();
    }
    /**
     * Advance the parser by the `source` of one lexical token.
     */
    *next(source) {
        this.source = source;
        if (node_process.env.LOG_TOKENS)
            console.log('|', cst.prettyToken(source));
        if (this.atScalar) {
            this.atScalar = false;
            yield* this.step();
            this.offset += source.length;
            return;
        }
        const type = cst.tokenType(source);
        if (!type) {
            const message = `Not a YAML token: ${source}`;
            yield* this.pop({ type: 'error', offset: this.offset, message, source });
            this.offset += source.length;
        }
        else if (type === 'scalar') {
            this.atNewLine = false;
            this.atScalar = true;
            this.type = 'scalar';
        }
        else {
            this.type = type;
            yield* this.step();
            switch (type) {
                case 'newline':
                    this.atNewLine = true;
                    this.indent = 0;
                    if (this.onNewLine)
                        this.onNewLine(this.offset + source.length);
                    break;
                case 'space':
                    if (this.atNewLine && source[0] === ' ')
                        this.indent += source.length;
                    break;
                case 'explicit-key-ind':
                case 'map-value-ind':
                case 'seq-item-ind':
                    if (this.atNewLine)
                        this.indent += source.length;
                    break;
                case 'doc-mode':
                case 'flow-error-end':
                    return;
                default:
                    this.atNewLine = false;
            }
            this.offset += source.length;
        }
    }
    /** Call at end of input to push out any remaining constructions */
    *end() {
        while (this.stack.length > 0)
            yield* this.pop();
    }
    get sourceToken() {
        const st = {
            type: this.type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
        return st;
    }
    *step() {
        const top = this.peek(1);
        if (this.type === 'doc-end' && (!top || top.type !== 'doc-end')) {
            while (this.stack.length > 0)
                yield* this.pop();
            this.stack.push({
                type: 'doc-end',
                offset: this.offset,
                source: this.source
            });
            return;
        }
        if (!top)
            return yield* this.stream();
        switch (top.type) {
            case 'document':
                return yield* this.document(top);
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return yield* this.scalar(top);
            case 'block-scalar':
                return yield* this.blockScalar(top);
            case 'block-map':
                return yield* this.blockMap(top);
            case 'block-seq':
                return yield* this.blockSequence(top);
            case 'flow-collection':
                return yield* this.flowCollection(top);
            case 'doc-end':
                return yield* this.documentEnd(top);
        }
        /* istanbul ignore next should not happen */
        yield* this.pop();
    }
    peek(n) {
        return this.stack[this.stack.length - n];
    }
    *pop(error) {
        const token = error ?? this.stack.pop();
        /* istanbul ignore if should not happen */
        if (!token) {
            const message = 'Tried to pop an empty stack';
            yield { type: 'error', offset: this.offset, source: '', message };
        }
        else if (this.stack.length === 0) {
            yield token;
        }
        else {
            const top = this.peek(1);
            if (token.type === 'block-scalar') {
                // Block scalars use their parent rather than header indent
                token.indent = 'indent' in top ? top.indent : 0;
            }
            else if (token.type === 'flow-collection' && top.type === 'document') {
                // Ignore all indent for top-level flow collections
                token.indent = 0;
            }
            if (token.type === 'flow-collection')
                fixFlowSeqItems(token);
            switch (top.type) {
                case 'document':
                    top.value = token;
                    break;
                case 'block-scalar':
                    top.props.push(token); // error
                    break;
                case 'block-map': {
                    const it = top.items[top.items.length - 1];
                    if (it.value) {
                        top.items.push({ start: [], key: token, sep: [] });
                        this.onKeyLine = true;
                        return;
                    }
                    else if (it.sep) {
                        it.value = token;
                    }
                    else {
                        Object.assign(it, { key: token, sep: [] });
                        this.onKeyLine = !it.explicitKey;
                        return;
                    }
                    break;
                }
                case 'block-seq': {
                    const it = top.items[top.items.length - 1];
                    if (it.value)
                        top.items.push({ start: [], value: token });
                    else
                        it.value = token;
                    break;
                }
                case 'flow-collection': {
                    const it = top.items[top.items.length - 1];
                    if (!it || it.value)
                        top.items.push({ start: [], key: token, sep: [] });
                    else if (it.sep)
                        it.value = token;
                    else
                        Object.assign(it, { key: token, sep: [] });
                    return;
                }
                /* istanbul ignore next should not happen */
                default:
                    yield* this.pop();
                    yield* this.pop(token);
            }
            if ((top.type === 'document' ||
                top.type === 'block-map' ||
                top.type === 'block-seq') &&
                (token.type === 'block-map' || token.type === 'block-seq')) {
                const last = token.items[token.items.length - 1];
                if (last &&
                    !last.sep &&
                    !last.value &&
                    last.start.length > 0 &&
                    findNonEmptyIndex(last.start) === -1 &&
                    (token.indent === 0 ||
                        last.start.every(st => st.type !== 'comment' || st.indent < token.indent))) {
                    if (top.type === 'document')
                        top.end = last.start;
                    else
                        top.items.push({ start: last.start });
                    token.items.splice(-1, 1);
                }
            }
        }
    }
    *stream() {
        switch (this.type) {
            case 'directive-line':
                yield { type: 'directive', offset: this.offset, source: this.source };
                return;
            case 'byte-order-mark':
            case 'space':
            case 'comment':
            case 'newline':
                yield this.sourceToken;
                return;
            case 'doc-mode':
            case 'doc-start': {
                const doc = {
                    type: 'document',
                    offset: this.offset,
                    start: []
                };
                if (this.type === 'doc-start')
                    doc.start.push(this.sourceToken);
                this.stack.push(doc);
                return;
            }
        }
        yield {
            type: 'error',
            offset: this.offset,
            message: `Unexpected ${this.type} token in YAML stream`,
            source: this.source
        };
    }
    *document(doc) {
        if (doc.value)
            return yield* this.lineEnd(doc);
        switch (this.type) {
            case 'doc-start': {
                if (findNonEmptyIndex(doc.start) !== -1) {
                    yield* this.pop();
                    yield* this.step();
                }
                else
                    doc.start.push(this.sourceToken);
                return;
            }
            case 'anchor':
            case 'tag':
            case 'space':
            case 'comment':
            case 'newline':
                doc.start.push(this.sourceToken);
                return;
        }
        const bv = this.startBlockValue(doc);
        if (bv)
            this.stack.push(bv);
        else {
            yield {
                type: 'error',
                offset: this.offset,
                message: `Unexpected ${this.type} token in YAML document`,
                source: this.source
            };
        }
    }
    *scalar(scalar) {
        if (this.type === 'map-value-ind') {
            const prev = getPrevProps(this.peek(2));
            const start = getFirstKeyStartProps(prev);
            let sep;
            if (scalar.end) {
                sep = scalar.end;
                sep.push(this.sourceToken);
                delete scalar.end;
            }
            else
                sep = [this.sourceToken];
            const map = {
                type: 'block-map',
                offset: scalar.offset,
                indent: scalar.indent,
                items: [{ start, key: scalar, sep }]
            };
            this.onKeyLine = true;
            this.stack[this.stack.length - 1] = map;
        }
        else
            yield* this.lineEnd(scalar);
    }
    *blockScalar(scalar) {
        switch (this.type) {
            case 'space':
            case 'comment':
            case 'newline':
                scalar.props.push(this.sourceToken);
                return;
            case 'scalar':
                scalar.source = this.source;
                // block-scalar source includes trailing newline
                this.atNewLine = true;
                this.indent = 0;
                if (this.onNewLine) {
                    let nl = this.source.indexOf('\n') + 1;
                    while (nl !== 0) {
                        this.onNewLine(this.offset + nl);
                        nl = this.source.indexOf('\n', nl) + 1;
                    }
                }
                yield* this.pop();
                break;
            /* istanbul ignore next should not happen */
            default:
                yield* this.pop();
                yield* this.step();
        }
    }
    *blockMap(map) {
        const it = map.items[map.items.length - 1];
        // it.sep is true-ish if pair already has key or : separator
        switch (this.type) {
            case 'newline':
                this.onKeyLine = false;
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    it.start.push(this.sourceToken);
                }
                return;
            case 'space':
            case 'comment':
                if (it.value) {
                    map.items.push({ start: [this.sourceToken] });
                }
                else if (it.sep) {
                    it.sep.push(this.sourceToken);
                }
                else {
                    if (this.atIndentedComment(it.start, map.indent)) {
                        const prev = map.items[map.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            map.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
        }
        if (this.indent >= map.indent) {
            const atMapIndent = !this.onKeyLine && this.indent === map.indent;
            const atNextItem = atMapIndent &&
                (it.sep || it.explicitKey) &&
                this.type !== 'seq-item-ind';
            // For empty nodes, assign newline-separated not indented empty tokens to following node
            let start = [];
            if (atNextItem && it.sep && !it.value) {
                const nl = [];
                for (let i = 0; i < it.sep.length; ++i) {
                    const st = it.sep[i];
                    switch (st.type) {
                        case 'newline':
                            nl.push(i);
                            break;
                        case 'space':
                            break;
                        case 'comment':
                            if (st.indent > map.indent)
                                nl.length = 0;
                            break;
                        default:
                            nl.length = 0;
                    }
                }
                if (nl.length >= 2)
                    start = it.sep.splice(nl[1]);
            }
            switch (this.type) {
                case 'anchor':
                case 'tag':
                    if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        it.sep.push(this.sourceToken);
                    }
                    else {
                        it.start.push(this.sourceToken);
                    }
                    return;
                case 'explicit-key-ind':
                    if (!it.sep && !it.explicitKey) {
                        it.start.push(this.sourceToken);
                        it.explicitKey = true;
                    }
                    else if (atNextItem || it.value) {
                        start.push(this.sourceToken);
                        map.items.push({ start, explicitKey: true });
                    }
                    else {
                        this.stack.push({
                            type: 'block-map',
                            offset: this.offset,
                            indent: this.indent,
                            items: [{ start: [this.sourceToken], explicitKey: true }]
                        });
                    }
                    this.onKeyLine = true;
                    return;
                case 'map-value-ind':
                    if (it.explicitKey) {
                        if (!it.sep) {
                            if (includesToken(it.start, 'newline')) {
                                Object.assign(it, { key: null, sep: [this.sourceToken] });
                            }
                            else {
                                const start = getFirstKeyStartProps(it.start);
                                this.stack.push({
                                    type: 'block-map',
                                    offset: this.offset,
                                    indent: this.indent,
                                    items: [{ start, key: null, sep: [this.sourceToken] }]
                                });
                            }
                        }
                        else if (it.value) {
                            map.items.push({ start: [], key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else if (isFlowToken(it.key) &&
                            !includesToken(it.sep, 'newline')) {
                            const start = getFirstKeyStartProps(it.start);
                            const key = it.key;
                            const sep = it.sep;
                            sep.push(this.sourceToken);
                            // @ts-expect-error type guard is wrong here
                            delete it.key;
                            // @ts-expect-error type guard is wrong here
                            delete it.sep;
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start, key, sep }]
                            });
                        }
                        else if (start.length > 0) {
                            // Not actually at next item
                            it.sep = it.sep.concat(start, this.sourceToken);
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    else {
                        if (!it.sep) {
                            Object.assign(it, { key: null, sep: [this.sourceToken] });
                        }
                        else if (it.value || atNextItem) {
                            map.items.push({ start, key: null, sep: [this.sourceToken] });
                        }
                        else if (includesToken(it.sep, 'map-value-ind')) {
                            this.stack.push({
                                type: 'block-map',
                                offset: this.offset,
                                indent: this.indent,
                                items: [{ start: [], key: null, sep: [this.sourceToken] }]
                            });
                        }
                        else {
                            it.sep.push(this.sourceToken);
                        }
                    }
                    this.onKeyLine = true;
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (atNextItem || it.value) {
                        map.items.push({ start, key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    else if (it.sep) {
                        this.stack.push(fs);
                    }
                    else {
                        Object.assign(it, { key: fs, sep: [] });
                        this.onKeyLine = true;
                    }
                    return;
                }
                default: {
                    const bv = this.startBlockValue(map);
                    if (bv) {
                        if (bv.type === 'block-seq') {
                            if (!it.explicitKey &&
                                it.sep &&
                                !includesToken(it.sep, 'newline')) {
                                yield* this.pop({
                                    type: 'error',
                                    offset: this.offset,
                                    message: 'Unexpected block-seq-ind on same line with key',
                                    source: this.source
                                });
                                return;
                            }
                        }
                        else if (atMapIndent) {
                            map.items.push({ start });
                        }
                        this.stack.push(bv);
                        return;
                    }
                }
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *blockSequence(seq) {
        const it = seq.items[seq.items.length - 1];
        switch (this.type) {
            case 'newline':
                if (it.value) {
                    const end = 'end' in it.value ? it.value.end : undefined;
                    const last = Array.isArray(end) ? end[end.length - 1] : undefined;
                    if (last?.type === 'comment')
                        end?.push(this.sourceToken);
                    else
                        seq.items.push({ start: [this.sourceToken] });
                }
                else
                    it.start.push(this.sourceToken);
                return;
            case 'space':
            case 'comment':
                if (it.value)
                    seq.items.push({ start: [this.sourceToken] });
                else {
                    if (this.atIndentedComment(it.start, seq.indent)) {
                        const prev = seq.items[seq.items.length - 2];
                        const end = prev?.value?.end;
                        if (Array.isArray(end)) {
                            Array.prototype.push.apply(end, it.start);
                            end.push(this.sourceToken);
                            seq.items.pop();
                            return;
                        }
                    }
                    it.start.push(this.sourceToken);
                }
                return;
            case 'anchor':
            case 'tag':
                if (it.value || this.indent <= seq.indent)
                    break;
                it.start.push(this.sourceToken);
                return;
            case 'seq-item-ind':
                if (this.indent !== seq.indent)
                    break;
                if (it.value || includesToken(it.start, 'seq-item-ind'))
                    seq.items.push({ start: [this.sourceToken] });
                else
                    it.start.push(this.sourceToken);
                return;
        }
        if (this.indent > seq.indent) {
            const bv = this.startBlockValue(seq);
            if (bv) {
                this.stack.push(bv);
                return;
            }
        }
        yield* this.pop();
        yield* this.step();
    }
    *flowCollection(fc) {
        const it = fc.items[fc.items.length - 1];
        if (this.type === 'flow-error-end') {
            let top;
            do {
                yield* this.pop();
                top = this.peek(1);
            } while (top && top.type === 'flow-collection');
        }
        else if (fc.end.length === 0) {
            switch (this.type) {
                case 'comma':
                case 'explicit-key-ind':
                    if (!it || it.sep)
                        fc.items.push({ start: [this.sourceToken] });
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'map-value-ind':
                    if (!it || it.value)
                        fc.items.push({ start: [], key: null, sep: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        Object.assign(it, { key: null, sep: [this.sourceToken] });
                    return;
                case 'space':
                case 'comment':
                case 'newline':
                case 'anchor':
                case 'tag':
                    if (!it || it.value)
                        fc.items.push({ start: [this.sourceToken] });
                    else if (it.sep)
                        it.sep.push(this.sourceToken);
                    else
                        it.start.push(this.sourceToken);
                    return;
                case 'alias':
                case 'scalar':
                case 'single-quoted-scalar':
                case 'double-quoted-scalar': {
                    const fs = this.flowScalar(this.type);
                    if (!it || it.value)
                        fc.items.push({ start: [], key: fs, sep: [] });
                    else if (it.sep)
                        this.stack.push(fs);
                    else
                        Object.assign(it, { key: fs, sep: [] });
                    return;
                }
                case 'flow-map-end':
                case 'flow-seq-end':
                    fc.end.push(this.sourceToken);
                    return;
            }
            const bv = this.startBlockValue(fc);
            /* istanbul ignore else should not happen */
            if (bv)
                this.stack.push(bv);
            else {
                yield* this.pop();
                yield* this.step();
            }
        }
        else {
            const parent = this.peek(2);
            if (parent.type === 'block-map' &&
                ((this.type === 'map-value-ind' && parent.indent === fc.indent) ||
                    (this.type === 'newline' &&
                        !parent.items[parent.items.length - 1].sep))) {
                yield* this.pop();
                yield* this.step();
            }
            else if (this.type === 'map-value-ind' &&
                parent.type !== 'flow-collection') {
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                fixFlowSeqItems(fc);
                const sep = fc.end.splice(1, fc.end.length);
                sep.push(this.sourceToken);
                const map = {
                    type: 'block-map',
                    offset: fc.offset,
                    indent: fc.indent,
                    items: [{ start, key: fc, sep }]
                };
                this.onKeyLine = true;
                this.stack[this.stack.length - 1] = map;
            }
            else {
                yield* this.lineEnd(fc);
            }
        }
    }
    flowScalar(type) {
        if (this.onNewLine) {
            let nl = this.source.indexOf('\n') + 1;
            while (nl !== 0) {
                this.onNewLine(this.offset + nl);
                nl = this.source.indexOf('\n', nl) + 1;
            }
        }
        return {
            type,
            offset: this.offset,
            indent: this.indent,
            source: this.source
        };
    }
    startBlockValue(parent) {
        switch (this.type) {
            case 'alias':
            case 'scalar':
            case 'single-quoted-scalar':
            case 'double-quoted-scalar':
                return this.flowScalar(this.type);
            case 'block-scalar-header':
                return {
                    type: 'block-scalar',
                    offset: this.offset,
                    indent: this.indent,
                    props: [this.sourceToken],
                    source: ''
                };
            case 'flow-map-start':
            case 'flow-seq-start':
                return {
                    type: 'flow-collection',
                    offset: this.offset,
                    indent: this.indent,
                    start: this.sourceToken,
                    items: [],
                    end: []
                };
            case 'seq-item-ind':
                return {
                    type: 'block-seq',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start: [this.sourceToken] }]
                };
            case 'explicit-key-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                start.push(this.sourceToken);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, explicitKey: true }]
                };
            }
            case 'map-value-ind': {
                this.onKeyLine = true;
                const prev = getPrevProps(parent);
                const start = getFirstKeyStartProps(prev);
                return {
                    type: 'block-map',
                    offset: this.offset,
                    indent: this.indent,
                    items: [{ start, key: null, sep: [this.sourceToken] }]
                };
            }
        }
        return null;
    }
    atIndentedComment(start, indent) {
        if (this.type !== 'comment')
            return false;
        if (this.indent <= indent)
            return false;
        return start.every(st => st.type === 'newline' || st.type === 'space');
    }
    *documentEnd(docEnd) {
        if (this.type !== 'doc-mode') {
            if (docEnd.end)
                docEnd.end.push(this.sourceToken);
            else
                docEnd.end = [this.sourceToken];
            if (this.type === 'newline')
                yield* this.pop();
        }
    }
    *lineEnd(token) {
        switch (this.type) {
            case 'comma':
            case 'doc-start':
            case 'doc-end':
            case 'flow-seq-end':
            case 'flow-map-end':
            case 'map-value-ind':
                yield* this.pop();
                yield* this.step();
                break;
            case 'newline':
                this.onKeyLine = false;
            // fallthrough
            case 'space':
            case 'comment':
            default:
                // all other values are errors
                if (token.end)
                    token.end.push(this.sourceToken);
                else
                    token.end = [this.sourceToken];
                if (this.type === 'newline')
                    yield* this.pop();
        }
    }
}

exports.Parser = Parser;


/***/ }),
/* 122 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var composer = __webpack_require__(50);
var Document = __webpack_require__(55);
var errors = __webpack_require__(99);
var log = __webpack_require__(71);
var identity = __webpack_require__(53);
var lineCounter = __webpack_require__(120);
var parser = __webpack_require__(121);

function parseOptions(options) {
    const prettyErrors = options.prettyErrors !== false;
    const lineCounter$1 = options.lineCounter || (prettyErrors && new lineCounter.LineCounter()) || null;
    return { lineCounter: lineCounter$1, prettyErrors };
}
/**
 * Parse the input as a stream of YAML documents.
 *
 * Documents should be separated from each other by `...` or `---` marker lines.
 *
 * @returns If an empty `docs` array is returned, it will be of type
 *   EmptyStream and contain additional stream information. In
 *   TypeScript, you should use `'empty' in docs` as a type guard for it.
 */
function parseAllDocuments(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    const docs = Array.from(composer$1.compose(parser$1.parse(source)));
    if (prettyErrors && lineCounter)
        for (const doc of docs) {
            doc.errors.forEach(errors.prettifyError(source, lineCounter));
            doc.warnings.forEach(errors.prettifyError(source, lineCounter));
        }
    if (docs.length > 0)
        return docs;
    return Object.assign([], { empty: true }, composer$1.streamInfo());
}
/** Parse an input string into a single YAML.Document */
function parseDocument(source, options = {}) {
    const { lineCounter, prettyErrors } = parseOptions(options);
    const parser$1 = new parser.Parser(lineCounter?.addNewLine);
    const composer$1 = new composer.Composer(options);
    // `doc` is always set by compose.end(true) at the very latest
    let doc = null;
    for (const _doc of composer$1.compose(parser$1.parse(source), true, source.length)) {
        if (!doc)
            doc = _doc;
        else if (doc.options.logLevel !== 'silent') {
            doc.errors.push(new errors.YAMLParseError(_doc.range.slice(0, 2), 'MULTIPLE_DOCS', 'Source contains multiple documents; please use YAML.parseAllDocuments()'));
            break;
        }
    }
    if (prettyErrors && lineCounter) {
        doc.errors.forEach(errors.prettifyError(source, lineCounter));
        doc.warnings.forEach(errors.prettifyError(source, lineCounter));
    }
    return doc;
}
function parse(src, reviver, options) {
    let _reviver = undefined;
    if (typeof reviver === 'function') {
        _reviver = reviver;
    }
    else if (options === undefined && reviver && typeof reviver === 'object') {
        options = reviver;
    }
    const doc = parseDocument(src, options);
    if (!doc)
        return null;
    doc.warnings.forEach(warning => log.warn(doc.options.logLevel, warning));
    if (doc.errors.length > 0) {
        if (doc.options.logLevel !== 'silent')
            throw doc.errors[0];
        else
            doc.errors = [];
    }
    return doc.toJS(Object.assign({ reviver: _reviver }, options));
}
function stringify(value, replacer, options) {
    let _replacer = null;
    if (typeof replacer === 'function' || Array.isArray(replacer)) {
        _replacer = replacer;
    }
    else if (options === undefined && replacer) {
        options = replacer;
    }
    if (typeof options === 'string')
        options = options.length;
    if (typeof options === 'number') {
        const indent = Math.round(options);
        options = indent < 1 ? undefined : indent > 8 ? { indent: 8 } : { indent };
    }
    if (value === undefined) {
        const { keepUndefined } = options ?? replacer ?? {};
        if (!keepUndefined)
            return undefined;
    }
    if (identity.isDocument(value) && !_replacer)
        return value.toString(options);
    return new Document.Document(value, _replacer, options).toString(options);
}

exports.parse = parse;
exports.parseAllDocuments = parseAllDocuments;
exports.parseDocument = parseDocument;
exports.stringify = stringify;


/***/ }),
/* 123 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);
const fs = __webpack_require__(11);
const yaml = __webpack_require__(49);

class Config {
    constructor(userConfig = {}) {
        this.defaultConfig = this._loadDefaultConfig();
        this.apiConfig = this._loadApiConfig();
        this.config = this._mergeConfigs(userConfig);
    }

    _loadDefaultConfig() {
        const defaultConfigPath = path.join(__dirname, '..', 'config', 'default.yaml');
        let defaultConfig = {};
        
        try {
            if (fs.existsSync(defaultConfigPath)) {
                const defaultConfigContent = fs.readFileSync(defaultConfigPath, 'utf8');
                defaultConfig = yaml.parse(defaultConfigContent);
            }
        } catch (error) {
            console.warn('Error loading default config:', error);
        }

        return defaultConfig;
    }

    _loadApiConfig() {
        try {
            const backendApiConfig = __webpack_require__(124);
            return backendApiConfig;
        } catch (error) {
            console.warn('Error loading backend API config:', error);
            return null;
        }
    }

    _mergeConfigs(userConfig) {
        const mergedConfig = {
            // 基础配置（来自 default.yaml）
            ...this.defaultConfig,
            
            // API配置集成
            api: this.apiConfig ? {
                // 获取当前环境的API配置
                current: this.apiConfig.get(process.env.NODE_ENV || 'development'),
                // 提供访问其他环境配置的方法
                get: (env) => this.apiConfig.get(env),
                getApiUrl: (env, endpoint) => this.apiConfig.getApiUrl(env, endpoint),
                parseServerIP: (apiEndpoint) => this.apiConfig.constructor.parseServerIP(apiEndpoint),
                validate: (env) => this.apiConfig.validate(env)
            } : null,

            // 用户配置覆盖
            ...userConfig
        };

        // 如果有API配置，将其集成到相关组件中
        if (this.apiConfig) {
            const currentApiConfig = this.apiConfig.get(process.env.NODE_ENV || 'development');
            
            // 集成到发送配置中
            if (mergedConfig.batchSize && !mergedConfig.maxRetries) {
                mergedConfig.maxRetries = currentApiConfig.retry.maxAttempts;
                mergedConfig.retryDelay = currentApiConfig.retry.delay;
                mergedConfig.apiEndpoint = currentApiConfig.baseURL + currentApiConfig.endpoints.embed;
            }

            // 集成到vectorManager配置中
            if (mergedConfig.vectorManager) {
                mergedConfig.vectorManager.embedding = {
                    endpoint: currentApiConfig.baseURL + currentApiConfig.endpoints.embed,
                    timeout: currentApiConfig.processing.timeout,
                    auth: currentApiConfig.auth
                };
                mergedConfig.vectorManager.retry = {
                    maxAttempts: currentApiConfig.retry.maxAttempts,
                    delay: currentApiConfig.retry.delay
                };
            }
        }

        return mergedConfig;
    }

    get(key) {
        return this.config[key];
    }

    set(key, value) {
        this.config[key] = value;
    }

    getAll() {
        return this.config;
    }

    // 新增：获取API配置的便捷方法
    getApiConfig(env) {
        return this.config.api ? this.config.api.get(env) : null;
    }

    // 新增：获取API URL的便捷方法
    getApiUrl(endpoint = 'embed', env) {
        return this.config.api ? this.config.api.getApiUrl(env, endpoint) : null;
    }

    // 新增：验证配置
    validate(env) {
        if (this.config.api) {
            return this.config.api.validate(env);
        }
        return true;
    }

    // 新增：获取配置摘要（用于调试）
    getConfigSummary() {
        return {
            hasDefaultConfig: Object.keys(this.defaultConfig).length > 0,
            hasApiConfig: this.apiConfig !== null,
            currentEnvironment: process.env.NODE_ENV || 'development',
            configKeys: Object.keys(this.config),
            apiEndpoints: this.config.api ? Object.keys(this.config.api.current.endpoints) : []
        };
    }
}

module.exports = new Config(); 

/***/ }),
/* 124 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Code Chunker 后端API集成配置
 * 基于后端API文档v1.0.3
 */

const path = __webpack_require__(4);

class BackendAPIConfig {
    constructor() {
        this.config = this._loadConfig();
    }

    _loadConfig() {
        // 从环境变量获取服务器IP，如果没有则使用默认值
        const serverIP = process.env.BACKEND_API_SERVER_IP || '42.193.14.136:8087';
        const protocol = process.env.BACKEND_API_PROTOCOL || 'http';
        
        // 构建基础URL
        const baseURL = `${protocol}://${serverIP}`;
        
        return {
            development: {
                baseURL: baseURL,
                endpoints: {
                    health: '/healthz',
                    version: '/version',
                    embed: '/api/v1/codebase/embed',
                    embedStatus: '/api/v1/codebase/embed/status',
                    embedResults: '/api/v1/codebase/embed/results',
                },
                auth: {
                    token: process.env.BACKEND_API_TOKEN || 'test_auth_token',
                },
                processing: {
                    mode: 'auto', // 'sync', 'async', 'auto'
                    syncThreshold: 20, // 小于等于20个块使用同步模式
                    batchSize: 15, // 推荐批次大小
                    maxConcurrency: 3,
                    timeout: 30000,
                },
                retry: {
                    maxAttempts: 3,
                    delay: 1000,
                    backoffMultiplier: 2,
                },
                async: {
                    pollInterval: 2000,
                    maxPollAttempts: 30,
                },
                monitoring: {
                    enabled: true,
                    logLevel: 'info',
                    metrics: {
                        collectResponseTimes: true,
                        collectErrorRates: true,
                    },
                },
            },
            production: {
                baseURL: baseURL,
                endpoints: {
                    health: '/healthz',
                    version: '/version',
                    embed: '/api/v1/codebase/embed',
                    embedStatus: '/api/v1/codebase/embed/status',
                    embedResults: '/api/v1/codebase/embed/results',
                },
                auth: {
                    token: process.env.BACKEND_API_TOKEN || 'test_auth_token',
                },
                processing: {
                    mode: 'auto',
                    syncThreshold: 20,
                    batchSize: 15,
                    maxConcurrency: 5,
                    timeout: 45000,
                },
                retry: {
                    maxAttempts: 5,
                    delay: 2000,
                    backoffMultiplier: 2,
                },
                async: {
                    pollInterval: 3000,
                    maxPollAttempts: 50,
                },
                monitoring: {
                    enabled: true,
                    logLevel: 'warn',
                    metrics: {
                        collectResponseTimes: true,
                        collectErrorRates: true,
                    },
                },
            },
            test: {
                baseURL: baseURL,
                endpoints: {
                    health: '/healthz',
                    version: '/version',
                    embed: '/api/v1/codebase/embed',
                    embedStatus: '/api/v1/codebase/embed/status',
                    embedResults: '/api/v1/codebase/embed/results',
                },
                auth: {
                    token: process.env.BACKEND_API_TOKEN || 'test_auth_token',
                },
                processing: {
                    mode: 'sync',
                    syncThreshold: 10,
                    batchSize: 5,
                    maxConcurrency: 2,
                    timeout: 15000,
                },
                retry: {
                    maxAttempts: 2,
                    delay: 500,
                    backoffMultiplier: 1.5,
                },
                async: {
                    pollInterval: 1000,
                    maxPollAttempts: 10,
                },
                monitoring: {
                    enabled: true,
                    logLevel: 'debug',
                    metrics: {
                        collectResponseTimes: true,
                        collectErrorRates: true,
                    },
                },
            },
        };
    }

    get(env = 'development') {
        return this.config[env] || this.config.development;
    }

    // 获取完整的API URL
    getApiUrl(env = 'development', endpoint = 'embed') {
        const config = this.get(env);
        return `${config.baseURL}${config.endpoints[endpoint]}`;
    }

    // 从配置字符串中解析服务器IP（支持现有的<SERVER_IP>格式）
    static parseServerIP(apiEndpoint) {
        if (typeof apiEndpoint !== 'string') {
            return null;
        }
        
        // 如果包含<SERVER_IP>占位符，使用环境变量替换
        if (apiEndpoint.includes('<SERVER_IP>')) {
            const serverIP = process.env.BACKEND_API_SERVER_IP || '42.193.14.136:8087';
            return apiEndpoint.replace('<SERVER_IP>', serverIP);
        }
        
        return apiEndpoint;
    }

    // 验证配置
    validate(env = 'development') {
        const config = this.get(env);
        const errors = [];

        if (!config.baseURL) {
            errors.push('baseURL is required');
        }

        if (!config.auth.token) {
            errors.push('auth.token is required');
        }

        if (!config.endpoints.embed) {
            errors.push('endpoints.embed is required');
        }

        if (errors.length > 0) {
            throw new Error(`Backend API configuration validation failed: ${errors.join(', ')}`);
        }

        return true;
    }
}

module.exports = new BackendAPIConfig(); 

/***/ }),
/* 125 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const { minimatch } = __webpack_require__(126);
const crypto = __webpack_require__(8);
const PathUtils = __webpack_require__(134);
const FileTypeDetector = __webpack_require__(135);
const IntelligentFileFilter = __webpack_require__(136);

class FileScanner {
    constructor(config, performanceAnalyzer = null) {
        this.config = config;
        this.performanceAnalyzer = performanceAnalyzer;
        
        // 🔥 完全依赖配置文件的白名单，移除硬编码默认值
        if (!config.scanFileExtensions || !Array.isArray(config.scanFileExtensions) || config.scanFileExtensions.length === 0) {
            throw new Error('❌ scanFileExtensions配置缺失或无效！必须在配置文件中指定要处理的文件扩展名白名单。');
        }
        
        this.scanFileExtensions = new Set(
            config.scanFileExtensions.map(ext => ext.toLowerCase())
        );
        
        // 🔥 完全依赖配置的忽略模式，移除硬编码
        this.ignorePatterns = config.ignorePatterns || [];
        
        this.maxFileSize = config.maxFileSize || 2 * 1024 * 1024; // 默认2MB
        this.workspacePath = config.workspacePath || null;
        
            // 添加符号链接循环检测
            this.visitedPaths = new Set(); // 用于检测循环引用
            this.processSymlinks = config.processSymlinks !== false; // 默认处理符号链接
            this.maxSymlinkDepth = config.maxSymlinkDepth || 10; // 最大符号链接深度
            
            // 添加递归深度控制
            this.maxDepth = config.maxDepth || 100; // 默认最大目录深度

            // 添加文件类型检测器
            this.fileTypeDetector = new FileTypeDetector();
            this.includeTextContentOnly = config.includeTextContentOnly !== false; // 默认只包含文本内容
            this.processBinaryFiles = config.processBinaryFiles !== false; // 默认处理二进制文件但不包含内容
        
        // 🎯 添加智能文件筛选器
        this.intelligentFilter = new IntelligentFileFilter();
        this.enableIntelligentFiltering = config.enableIntelligentFiltering !== false; // 默认启用智能筛选
        
        // 🔥 完全依赖配置的目录忽略列表
        this.ignoredDirectories = new Set(config.ignoredDirectories || []);
        }

    async scanWorkspace(workspacePath) {
        // 开始计时：FileScanner初始化
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.startModuleTimer('fileScanner', 'initTime');
            this.performanceAnalyzer.recordMemoryUsage('fileScanner_start');
        }

        // 参数验证
        if (!workspacePath || typeof workspacePath !== 'string') {
            throw new Error('Invalid workspace path: path must be a non-empty string');
        }
    
        // 路径存在性和类型检查
        try {
            const stats = await fs.stat(workspacePath);
            if (!stats.isDirectory()) {
                throw new Error(`Path is not a directory: ${workspacePath}`);
            }
        } catch (error) {
            if (error.code === 'ENOENT') {
                throw new Error(`Workspace path does not exist: ${workspacePath}`);
            } else if (error.code === 'EACCES') {
                throw new Error(`Permission denied to access workspace: ${workspacePath}`);
            }
            throw error;
        }
    
        // 权限检查
        try {
            await fs.access(workspacePath, fs.constants.R_OK);
        } catch (error) {
            throw new Error(`No read permission for workspace: ${workspacePath}`);
        }
    
        this.workspacePath = path.resolve(workspacePath); // 规范化路径
        this.visitedPaths.clear(); // 清理之前的访问记录
        const fileList = [];
        const fileHashes = {};
        const fileContents = [];
        const fileInfos = [];
    
        // 添加统计信息跟踪
        this.scanStats = {
            totalFilesScanned: 0,
            skippedFiles: 0,
            processedFiles: 0,
            skippedDirectories: 0
        };
    
        // 结束初始化，开始扫描
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('fileScanner', 'initTime');
            this.performanceAnalyzer.startModuleTimer('fileScanner', 'scanTime');
        }
    
        try {
            await this._scanDirectory(this.workspacePath, fileList, fileHashes, fileContents, fileInfos, 0, 0);
            
            // 结束扫描，开始过滤
            if (this.performanceAnalyzer) {
                this.performanceAnalyzer.endModuleTimer('fileScanner', 'scanTime');
                this.performanceAnalyzer.startModuleTimer('fileScanner', 'filterTime');
            }
            
            const merkleTree = await this._buildMerkleTree(fileList, fileHashes, fileInfos);
            
            // 结束过滤
            if (this.performanceAnalyzer) {
                this.performanceAnalyzer.endModuleTimer('fileScanner', 'filterTime');
                this.performanceAnalyzer.recordMemoryUsage('fileScanner_end');
            }
            
            console.log(`[FileScanner] ✅ 扫描完成: 发现 ${fileList.length} 个文件`);
            
            return { 
                fileList, 
                merkleTree: merkleTree, 
                fileContents, 
                fileHashes,
                scanStats: this.scanStats
            };
        } catch (error) {
            console.error('[FileScanner] ❌ 扫描工作区时出错:', error);
            throw error;
        }
    }

    async _scanDirectory(dir, fileList, fileHashes, fileContents, fileInfos, symlinkDepth = 0, depth = 0) {
        // 检查递归深度
        if (depth > this.maxDepth) {
            const relativePath = path.relative(this.workspacePath, dir);
            console.warn(`Maximum directory depth (${this.maxDepth}) exceeded: ${relativePath || '.'}`);
            return;
        }
        
        // 🔥 目录级别的快速忽略检查 - 提前终止整个目录树的扫描
        const dirName = path.basename(dir);
        if (this.ignoredDirectories.has(dirName)) {
            return;
        }
        
        const entries = await fs.readdir(dir, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = path.join(dir, entry.name);
            let relativePath = path.relative(this.workspacePath, fullPath);

            // 标准化路径为正斜杠格式（跨平台兼容）
            relativePath = PathUtils.normalizePath(relativePath);

            // 🔥 增强的忽略检查 - 先检查目录级忽略，再检查模式匹配
            if (entry.isDirectory()) {
                // 目录级快速忽略
                if (this.ignoredDirectories.has(entry.name)) {
                    this.scanStats.skippedDirectories++;
                continue;
            }

                // 使用新的扫描逻辑检查目录
                if (!this._shouldScan(relativePath + '/')) { // 目录路径加斜杠
                    this.scanStats.skippedDirectories++;
                    continue;
                }

                await this._scanDirectory(fullPath, fileList, fileHashes, fileContents, fileInfos, symlinkDepth, depth + 1);
            } else if (entry.isFile()) {
                this.scanStats.totalFilesScanned++;
                
                // 1. 🔥 新的白名单扫描检查
                if (!this._shouldScan(relativePath)) {
                    this.scanStats.skippedFiles++;
                    continue;
                }
                
                // 2. 🎯 智能文件筛选检查
                if (this.enableIntelligentFiltering) {
                    if (!this.intelligentFilter.isValuableFile(relativePath)) {
                        this.scanStats.skippedFiles++;
                        continue;
                    }
                }
                
                await this._processFile(fullPath, relativePath, fileList, fileHashes, fileContents, fileInfos);
                this.scanStats.processedFiles++;
            } else if (entry.isSymbolicLink()) {
                // 检查符号链接是否应该扫描
                if (!this._shouldScan(relativePath)) {
                    continue;
                }
                
                // 处理符号链接
                await this._processSymbolicLink(fullPath, relativePath, fileList, fileHashes, fileContents, symlinkDepth);
            } else {
                // 记录其他特殊文件类型
                this._logSpecialFileType(entry, relativePath);
            }
        }
    }

    /**
     * 🔥 新方法：基于白名单的文件扫描判断
     * 只扫描配置中指定的文件扩展名，大大提升扫描效率
     */
    _shouldScan(filePath) {
        // 🔥 快速路径检查 - 检查是否包含被忽略的目录段
        const pathSegments = filePath.split('/');
        for (const segment of pathSegments) {
            if (this.ignoredDirectories.has(segment)) {
                return false; // 路径中包含被忽略的目录
            }
        }
        
        // 🔥 目录特殊处理：目录本身应该允许扫描（不受扩展名限制）
        if (filePath.endsWith('/')) {
            // 这是目录，只检查模式匹配
            return !this.ignorePatterns.some(pattern => minimatch(filePath, pattern));
        }
        
        // 🔥 特殊文件检查 - 优先级最高的忽略逻辑
        const fileBaseName = path.basename(filePath).toLowerCase();
        
        // 忽略 CUDA 相关的大型生成文件
        if (fileBaseName.includes('.cubin.') || fileBaseName.includes('_cubin.') || 
            fileBaseName.includes('.ptx.') || fileBaseName.includes('_ptx.') ||
            fileBaseName.includes('.fatbin.') || fileBaseName.includes('_fatbin.') ||
            fileBaseName.includes('cubin.cpp') || fileBaseName.includes('ptx.cpp')) {
            console.log(`🚫 Ignoring CUDA binary file: ${filePath}`);
            return false;
        }
        
        // 🔥 白名单扩展名检查 - 这是核心逻辑（只对文件生效）
        const ext = path.extname(filePath).toLowerCase();
        if (!ext || !this.scanFileExtensions.has(ext)) {
            // 添加调试信息来确认文件是否被正确忽略
            if (filePath.includes('.cubin')) {
                console.log(`🚫 Ignoring cubin file: ${filePath} (extension: ${ext || 'none'})`);
            }
            return false; // 没有扩展名或扩展名不在白名单中
        }
        
        // 🔥 特殊文件名检查（即使扩展名正确也要忽略）
        const fileName = fileBaseName;
        const specialIgnoredFiles = [
            '.ds_store', 'thumbs.db', 'desktop.ini',
            // 编译和压缩文件（即使扩展名匹配也要忽略）
            '.min.js', '.min.css', '.bundle.js', '.bundle.css',
            '.chunk.js', '.chunk.css'
        ];
        if (specialIgnoredFiles.includes(fileName)) {
            return false;
        }
        
        // 检查是否是编译/压缩文件
        if (fileName.includes('.min.') || fileName.includes('.bundle.') || fileName.includes('.chunk.')) {
            return false;
        }
        
        // 🔥 最后使用模式匹配进行额外检查（最耗时，放在最后）
        if (this.ignorePatterns.some(pattern => {
            const match = minimatch(filePath, pattern);
            if (match && filePath.includes('.cubin')) {
                console.log(`🚫 Ignoring cubin file by pattern: ${filePath} (matched pattern: ${pattern})`);
            }
            return match;
        })) {
            return false;
        }
        
        return true; // 通过所有检查，应该扫描此文件
    }
    
    /**
     * 🔥 保留原有方法名的兼容性封装
     * @deprecated 建议使用 _shouldScan 方法
     */
    _shouldIgnore(filePath) {
        return !this._shouldScan(filePath);
    }

        // 提取文件处理逻辑为独立方法
        async _processFile(fullPath, relativePath, fileList, fileHashes, fileContents, fileInfos) {
            try {
                const stats = await fs.stat(fullPath);
                
                // 🔥 提前检查文件大小 - 避免读取大文件
                if (stats.size > this.maxFileSize) {
                    console.warn(`File ${relativePath} exceeds maximum size limit (${stats.size} bytes, max: ${this.maxFileSize} bytes)`);
                    this.scanStats.skippedFiles++;
                    return;
                }
        
                // 使用新的文件读取和类型检测逻辑
                const buffer = await fs.readFile(fullPath);
                const fileInfo = this.fileTypeDetector.analyzeFile(buffer, relativePath);
                
                // 处理文件信息
                if (fileInfo.error) {
                    console.warn(`Failed to analyze file ${relativePath}: ${fileInfo.error}`);
                    return;
                }
                
                // 决定是否处理此文件
                if (fileInfo.isBinary && !this.processBinaryFiles) {
                    return;
                }
                
                // 关键修复：只有所有操作都成功后，才同时添加到所有数据结构
                // 这确保了 fileList、fileContents 和 fileHashes 的索引对应关系
                fileList.push(relativePath);
                fileHashes[relativePath] = fileInfo.hash;

                fileInfos.push({
                    path: relativePath,
                    fullPath: fullPath,
                    stats: stats,
                    hash: fileInfo.hash,
                    isBinary: fileInfo.isBinary,
                    encoding: fileInfo.encoding
                });
                
                if (fileInfo.isBinary) {
                    // 对于二进制文件，存储特殊标记而不是内容
                    if (this.includeTextContentOnly) {
                        fileContents.push(`[BINARY FILE: ${stats.size} bytes, type: ${this._getFileType(relativePath)}]`);
                    } else {
                        // 如果需要包含二进制文件，可以存储base64编码
                        fileContents.push(`[BINARY:${buffer.toString('base64')}]`);
                    }
                } else {
                    // 对于文本文件，存储内容
                    fileContents.push(fileInfo.content);
                }
                
            } catch (error) {
                // 完整的错误处理：处理各种可能的错误情况
                if (error.code === 'ENOENT') {
                    console.warn(`File ${relativePath} was deleted during scan`);
                } else if (error.code === 'EACCES') {
                    console.warn(`Permission denied reading file ${relativePath}`);
                } else if (error.code === 'EISDIR') {
                    console.warn(`Expected file but found directory: ${relativePath}`);
                } else if (error.code === 'EMFILE' || error.code === 'ENFILE') {
                    console.warn(`Too many open files, skipping ${relativePath}`);
                } else if (error.message.includes('invalid byte sequence') || 
                           error.message.includes('malformed UTF-8') ||
                           error.message.includes('Invalid or incomplete UTF-8')) {
                    console.warn(`File ${relativePath} contains non-UTF-8 content, skipping`);
                } else {
                    console.warn(`Failed to process file ${relativePath}: ${error.message}`);
                }
                // 处理失败的文件不会被添加到任何数组中，保持数据一致性
            }
        }
    
        // 符号链接处理方法
        async _processSymbolicLink(fullPath, relativePath, fileList, fileHashes, fileContents, symlinkDepth) {
            if (!this.processSymlinks) {
                console.debug(`Skipping symbolic link (disabled): ${relativePath}`);
                return;
            }
    
            // 检查符号链接深度
            if (symlinkDepth >= this.maxSymlinkDepth) {
                console.warn(`Maximum symbolic link depth exceeded: ${relativePath} (depth: ${symlinkDepth})`);
                return;
            }
    
            try {
                // 读取符号链接目标
                const linkTarget = await fs.readlink(fullPath);
                const resolvedPath = path.resolve(path.dirname(fullPath), linkTarget);
                
                // 检查循环引用
                if (this._isCircularReference(resolvedPath, fullPath)) {
                    console.warn(`Circular reference detected: ${relativePath} -> ${linkTarget}`);
                    return;
                }
    
                // 检查链接目标是否存在并获取其状态
                let targetStats;
                try {
                    targetStats = await fs.stat(resolvedPath);
                } catch (statError) {
                    if (statError.code === 'ENOENT') {
                        console.warn(`Broken symbolic link: ${relativePath} -> ${linkTarget} (target not found)`);
                    } else if (statError.code === 'EACCES') {
                        console.warn(`Broken symbolic link: ${relativePath} -> ${linkTarget} (permission denied)`);
                    } else {
                        console.warn(`Broken symbolic link: ${relativePath} -> ${linkTarget} (${statError.message})`);
                    }
                    return;
                }
    
                // 检查是否指向工作区外部
                const resolvedRelative = path.relative(this.workspacePath, resolvedPath);
                if (resolvedRelative.startsWith('..') || path.isAbsolute(resolvedRelative)) {
                    console.warn(`Symbolic link points outside workspace: ${relativePath} -> ${linkTarget}`);
                    return;
                }
    
                // 记录访问的路径以检测循环
                this.visitedPaths.add(path.resolve(fullPath));
    
                try {
                    if (targetStats.isDirectory()) {
                        // 处理目录符号链接
                        await this._scanDirectory(resolvedPath, fileList, fileHashes, fileContents, fileInfos, symlinkDepth + 1, depth + 1);
                    } else if (targetStats.isFile()) {
                        // 处理文件符号链接
                        await this._processFile(resolvedPath, relativePath, fileList, fileHashes, fileContents, fileInfos);
                    }
                } finally {
                    // 清理访问记录
                    this.visitedPaths.delete(path.resolve(fullPath));
                }
    
            } catch (error) {
                console.warn(`Error processing symbolic link ${relativePath}: ${error.message}`);
            }
        }
    
        // 循环引用检测
        _isCircularReference(resolvedPath, currentPath) {
            const normalizedResolved = path.resolve(resolvedPath);
            const normalizedCurrent = path.resolve(currentPath);
            
            // 检查是否指向自己
            if (normalizedResolved === normalizedCurrent) {
                return true;
            }
            
            // 检查是否已经访问过
            if (this.visitedPaths.has(normalizedResolved)) {
                return true;
            }
            
            // 检查是否指向父目录（可能造成循环）
            let parent = path.dirname(normalizedCurrent);
            while (parent !== path.dirname(parent)) { // 直到根目录
                if (normalizedResolved === parent) {
                    return true;
                }
                parent = path.dirname(parent);
            }
            
            return false;
        }
    
        // 特殊文件类型记录
        _logSpecialFileType(entry, relativePath) {
            let fileType = 'unknown';
            
            if (entry.isBlockDevice()) {
                fileType = 'block device';
            } else if (entry.isCharacterDevice()) {
                fileType = 'character device';
            } else if (entry.isFIFO()) {
                fileType = 'FIFO/pipe';
            } else if (entry.isSocket()) {
                fileType = 'socket';
            }
            

        }

        // 添加文件类型判断方法
        _getFileType(filePath) {
            const ext = path.extname(filePath).toLowerCase();
            const typeMap = {
                '.jpg': 'image', '.jpeg': 'image', '.png': 'image', '.gif': 'image', '.bmp': 'image',
                '.mp3': 'audio', '.wav': 'audio', '.mp4': 'video', '.avi': 'video',
                '.zip': 'archive', '.rar': 'archive', '.7z': 'archive', '.tar': 'archive',
                '.pdf': 'document', '.doc': 'document', '.docx': 'document',
                '.exe': 'executable', '.dll': 'executable', '.so': 'executable'
            };
            return typeMap[ext] || 'binary';
        }

    async _calculateFileHash(filePath) {
        const content = await fs.readFile(filePath);
        return crypto.createHash('sha256').update(content).digest('hex');
    }

    async _buildMerkleTree(fileList, fileHashes, fileInfos) {
        const merkleTree = {
            // 根节点信息
            root: {
                hash: this._calculateRootHash(fileHashes),
                timestamp: Date.now(),
                fileCount: fileList.length
            },
            
            // 文件节点映射
            files: {},
            
            // 目录节点映射
            directories: {},
            
            // 快速索引
            index: {
                byExtension: {},
                bySize: { small: [], medium: [], large: [] },
                recentlyModified: []
            },
            
            // 元数据
            metadata: {
                version: "2.0",
                createdAt: Date.now(),
                workspace: this.workspacePath,
                totalSize: 0,
                treeDepth: 0
            }
        };

        // 构建文件和目录映射
        await this._buildFileDirectoryMappings(fileInfos, fileHashes, merkleTree);
        
        // 构建索引
        await this._buildIndexes(fileInfos, merkleTree);
        
        return merkleTree;
    }

    async _buildFileDirectoryMappings(fileInfos, fileHashes, tree) {
        const directoryContents = {};
        
        for (const fileInfo of fileInfos) {
            const { path: relativePath, stats } = fileInfo;  // ✅ 复用已有的stats信息
            const parentDir = PathUtils.getParentDir(relativePath);
            
            // 添加文件信息 - 使用已收集的stats，避免重复系统调用
            tree.files[relativePath] = {
                hash: fileInfo.hash,
                size: stats.size,
                lastModified: stats.mtime.getTime(),
                path: relativePath,
                parentPath: PathUtils.isCurrentDir(parentDir) ? '' : parentDir
            };
            
            // 收集目录信息
            if (!directoryContents[parentDir]) {
                directoryContents[parentDir] = {
                    files: [],
                    subdirs: new Set()
                };
            }
            directoryContents[parentDir].files.push(relativePath);
            
            // 处理嵌套目录
            let currentDir = parentDir;
            while (currentDir && currentDir !== '' && !PathUtils.isCurrentDir(currentDir)) {
                const parentOfCurrent = PathUtils.getParentOfDir(currentDir);
                if (PathUtils.isCurrentDir(parentOfCurrent) || PathUtils.pathEquals(parentOfCurrent, currentDir)) break;
                
                if (!directoryContents[parentOfCurrent]) {
                    directoryContents[parentOfCurrent] = {
                        files: [],
                        subdirs: new Set()
                    };
                }
                directoryContents[parentOfCurrent].subdirs.add(currentDir);
                currentDir = parentOfCurrent;
            }
        }
        
        // 按目录深度排序，确保子目录先于父目录处理
        const sortedDirs = Object.keys(directoryContents)
            .filter(dir => !PathUtils.isCurrentDir(dir))
            .sort((a, b) => {
                const depthA = PathUtils.getPathDepth(a);
                const depthB = PathUtils.getPathDepth(b);
                return depthB - depthA; // 深度大的先处理（自底向上）
            });
        
        // 自底向上构建目录节点并计算正确的哈希值
        for (const dirPath of sortedDirs) {
            const contents = directoryContents[dirPath];
            const subdirs = Array.from(contents.subdirs);
            const allChildren = [...contents.files, ...subdirs];

            tree.directories[dirPath] = {
                hash: this._calculateDirectoryHash(allChildren, tree.files, tree.directories),
                fileCount: contents.files.length,
                children: allChildren,
                files: contents.files,
                subdirs: subdirs
            };
        }
    }

    async _buildIndexes(fileInfos, tree) {
        for (const fileInfo of fileInfos) {
            const { path: relativePath, stats } = fileInfo;
            const ext = path.extname(relativePath);
            const treeFileInfo = tree.files[relativePath];
            
            // 按扩展名分组
            if (!tree.index.byExtension[ext]) {
                tree.index.byExtension[ext] = [];
            }
            tree.index.byExtension[ext].push(relativePath);
            
            // 按大小分组
            if (stats.size < 10240) { // ✅ 使用 stats.size
                tree.index.bySize.small.push(relativePath);
            } else if (stats.size < 102400) { // ✅ 使用 stats.size
                tree.index.bySize.medium.push(relativePath);
            } else {
                tree.index.bySize.large.push(relativePath);
            }
            
            tree.metadata.totalSize += stats.size; // ✅ 使用 stats.size
        }
        
        // 计算目录树深度
        tree.metadata.treeDepth = this._calculateTreeDepth(Object.keys(tree.directories));
    }

    _calculateDirectoryHash(children, fileMap, directories) {
        const childHashes = children.map(child => {
            if (fileMap[child]) {
                // 是文件，返回文件哈希
                return fileMap[child].hash;
            } else {
                // 是子目录，返回子目录的哈希值
                const subDirInfo = directories[child];
                if (subDirInfo && subDirInfo.hash) {
                    return subDirInfo.hash;
                } else {
                    // 如果子目录信息不存在，使用目录名作为兜底
                    console.warn(`Warning: Directory hash not found for ${child}, using directory name as fallback`);
                    return child;
                }
            }
        }).sort();
        
        return crypto.createHash('sha256')
            .update(childHashes.join(''))
            .digest('hex');
    }

    _calculateTreeDepth(directories) {
        return Math.max(...directories.map(dir => PathUtils.getPathDepth(dir)), 0);
    }

    _calculateRootHash(fileHashes) {
        if (!fileHashes || Object.keys(fileHashes).length === 0) {
            return crypto.createHash('sha256').update('').digest('hex');
        }
        
        const sortedHashes = Object.keys(fileHashes)
            .sort()
            .map(key => fileHashes[key])
            .join('');
        return crypto.createHash('sha256').update(sortedHashes).digest('hex');
    }

    // 计算实际扫描深度
    _calculateScanDepth(directories) {
        if (!directories || Object.keys(directories).length === 0) {
            return 0;
        }
        
        let maxDepth = 0;
        for (const dirPath of Object.keys(directories)) {
            const depth = dirPath.split(path.sep).length;
            maxDepth = Math.max(maxDepth, depth);
        }
        return maxDepth;
    }

    static findChangedFiles(oldTree, newTree) {
        const changedFiles = [];
        
        // 检查新增和修改的文件
        for (const [path, fileInfo] of Object.entries(newTree.files)) {
            const oldFileInfo = oldTree.files[path];
            
            if (!oldFileInfo) {
                changedFiles.push({
                    path,
                    type: 'added',
                    newHash: fileInfo.hash
                });
            } else if (oldFileInfo.hash !== fileInfo.hash) {
                changedFiles.push({
                    path,
                    type: 'modified',
                    oldHash: oldFileInfo.hash,
                    newHash: fileInfo.hash
                });
            }
        }
        
        // 检查删除的文件
        for (const [path, fileInfo] of Object.entries(oldTree.files)) {
            if (!newTree.files[path]) {
                changedFiles.push({
                    path,
                    type: 'deleted',
                    oldHash: fileInfo.hash
                });
            }
        }
        
        return changedFiles;
    }
}

module.exports = FileScanner; 

/***/ }),
/* 126 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unescape = exports.escape = exports.AST = exports.Minimatch = exports.match = exports.makeRe = exports.braceExpand = exports.defaults = exports.filter = exports.GLOBSTAR = exports.sep = exports.minimatch = void 0;
const brace_expansion_1 = __importDefault(__webpack_require__(127));
const assert_valid_pattern_js_1 = __webpack_require__(129);
const ast_js_1 = __webpack_require__(130);
const escape_js_1 = __webpack_require__(133);
const unescape_js_1 = __webpack_require__(132);
const minimatch = (p, pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // shortcut: comments match nothing.
    if (!options.nocomment && pattern.charAt(0) === '#') {
        return false;
    }
    return new Minimatch(pattern, options).match(p);
};
exports.minimatch = minimatch;
// Optimized checking for the most common glob patterns.
const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
const starDotExtTest = (ext) => (f) => !f.startsWith('.') && f.endsWith(ext);
const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
const starDotExtTestNocase = (ext) => {
    ext = ext.toLowerCase();
    return (f) => !f.startsWith('.') && f.toLowerCase().endsWith(ext);
};
const starDotExtTestNocaseDot = (ext) => {
    ext = ext.toLowerCase();
    return (f) => f.toLowerCase().endsWith(ext);
};
const starDotStarRE = /^\*+\.\*+$/;
const starDotStarTest = (f) => !f.startsWith('.') && f.includes('.');
const starDotStarTestDot = (f) => f !== '.' && f !== '..' && f.includes('.');
const dotStarRE = /^\.\*+$/;
const dotStarTest = (f) => f !== '.' && f !== '..' && f.startsWith('.');
const starRE = /^\*+$/;
const starTest = (f) => f.length !== 0 && !f.startsWith('.');
const starTestDot = (f) => f.length !== 0 && f !== '.' && f !== '..';
const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
const qmarksTestNocase = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestNocaseDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    if (!ext)
        return noext;
    ext = ext.toLowerCase();
    return (f) => noext(f) && f.toLowerCase().endsWith(ext);
};
const qmarksTestDot = ([$0, ext = '']) => {
    const noext = qmarksTestNoExtDot([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTest = ([$0, ext = '']) => {
    const noext = qmarksTestNoExt([$0]);
    return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
};
const qmarksTestNoExt = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && !f.startsWith('.');
};
const qmarksTestNoExtDot = ([$0]) => {
    const len = $0.length;
    return (f) => f.length === len && f !== '.' && f !== '..';
};
/* c8 ignore start */
const defaultPlatform = (typeof process === 'object' && process
    ? (typeof process.env === 'object' &&
        process.env &&
        process.env.__MINIMATCH_TESTING_PLATFORM__) ||
        process.platform
    : 'posix');
const path = {
    win32: { sep: '\\' },
    posix: { sep: '/' },
};
/* c8 ignore stop */
exports.sep = defaultPlatform === 'win32' ? path.win32.sep : path.posix.sep;
exports.minimatch.sep = exports.sep;
exports.GLOBSTAR = Symbol('globstar **');
exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
// any single thing other than /
// don't need to escape / when using new RegExp()
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
const twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
// not a ^ or / followed by a dot,
// followed by anything, any number of times.
const twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
const filter = (pattern, options = {}) => (p) => (0, exports.minimatch)(p, pattern, options);
exports.filter = filter;
exports.minimatch.filter = exports.filter;
const ext = (a, b = {}) => Object.assign({}, a, b);
const defaults = (def) => {
    if (!def || typeof def !== 'object' || !Object.keys(def).length) {
        return exports.minimatch;
    }
    const orig = exports.minimatch;
    const m = (p, pattern, options = {}) => orig(p, pattern, ext(def, options));
    return Object.assign(m, {
        Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
                super(pattern, ext(def, options));
            }
            static defaults(options) {
                return orig.defaults(ext(def, options)).Minimatch;
            }
        },
        AST: class AST extends orig.AST {
            /* c8 ignore start */
            constructor(type, parent, options = {}) {
                super(type, parent, ext(def, options));
            }
            /* c8 ignore stop */
            static fromGlob(pattern, options = {}) {
                return orig.AST.fromGlob(pattern, ext(def, options));
            }
        },
        unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
        escape: (s, options = {}) => orig.escape(s, ext(def, options)),
        filter: (pattern, options = {}) => orig.filter(pattern, ext(def, options)),
        defaults: (options) => orig.defaults(ext(def, options)),
        makeRe: (pattern, options = {}) => orig.makeRe(pattern, ext(def, options)),
        braceExpand: (pattern, options = {}) => orig.braceExpand(pattern, ext(def, options)),
        match: (list, pattern, options = {}) => orig.match(list, pattern, ext(def, options)),
        sep: orig.sep,
        GLOBSTAR: exports.GLOBSTAR,
    });
};
exports.defaults = defaults;
exports.minimatch.defaults = exports.defaults;
// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
const braceExpand = (pattern, options = {}) => {
    (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
    // Thanks to Yeting Li <https://github.com/yetingli> for
    // improving this regexp to avoid a ReDOS vulnerability.
    if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
        // shortcut. no need to expand.
        return [pattern];
    }
    return (0, brace_expansion_1.default)(pattern);
};
exports.braceExpand = braceExpand;
exports.minimatch.braceExpand = exports.braceExpand;
// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
const makeRe = (pattern, options = {}) => new Minimatch(pattern, options).makeRe();
exports.makeRe = makeRe;
exports.minimatch.makeRe = exports.makeRe;
const match = (list, pattern, options = {}) => {
    const mm = new Minimatch(pattern, options);
    list = list.filter(f => mm.match(f));
    if (mm.options.nonull && !list.length) {
        list.push(pattern);
    }
    return list;
};
exports.match = match;
exports.minimatch.match = exports.match;
// replace stuff like \* with *
const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
class Minimatch {
    options;
    set;
    pattern;
    windowsPathsNoEscape;
    nonegate;
    negate;
    comment;
    empty;
    preserveMultipleSlashes;
    partial;
    globSet;
    globParts;
    nocase;
    isWindows;
    platform;
    windowsNoMagicRoot;
    regexp;
    constructor(pattern, options = {}) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        options = options || {};
        this.options = options;
        this.pattern = pattern;
        this.platform = options.platform || defaultPlatform;
        this.isWindows = this.platform === 'win32';
        this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
        if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, '/');
        }
        this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
        this.regexp = null;
        this.negate = false;
        this.nonegate = !!options.nonegate;
        this.comment = false;
        this.empty = false;
        this.partial = !!options.partial;
        this.nocase = !!this.options.nocase;
        this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
                ? options.windowsNoMagicRoot
                : !!(this.isWindows && this.nocase);
        this.globSet = [];
        this.globParts = [];
        this.set = [];
        // make the set of regexps etc.
        this.make();
    }
    hasMagic() {
        if (this.options.magicalBraces && this.set.length > 1) {
            return true;
        }
        for (const pattern of this.set) {
            for (const part of pattern) {
                if (typeof part !== 'string')
                    return true;
            }
        }
        return false;
    }
    debug(..._) { }
    make() {
        const pattern = this.pattern;
        const options = this.options;
        // empty patterns and comments match nothing.
        if (!options.nocomment && pattern.charAt(0) === '#') {
            this.comment = true;
            return;
        }
        if (!pattern) {
            this.empty = true;
            return;
        }
        // step 1: figure out negation, etc.
        this.parseNegate();
        // step 2: expand braces
        this.globSet = [...new Set(this.braceExpand())];
        if (options.debug) {
            this.debug = (...args) => console.error(...args);
        }
        this.debug(this.pattern, this.globSet);
        // step 3: now we have a set, so turn each one into a series of
        // path-portion matching patterns.
        // These will be regexps, except in the case of "**", which is
        // set to the GLOBSTAR object for globstar behavior,
        // and will not contain any / characters
        //
        // First, we preprocess to make the glob pattern sets a bit simpler
        // and deduped.  There are some perf-killing patterns that can cause
        // problems with a glob walk, but we can simplify them down a bit.
        const rawGlobParts = this.globSet.map(s => this.slashSplit(s));
        this.globParts = this.preprocess(rawGlobParts);
        this.debug(this.pattern, this.globParts);
        // glob --> regexps
        let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
                // check if it's a drive or unc path.
                const isUNC = s[0] === '' &&
                    s[1] === '' &&
                    (s[2] === '?' || !globMagic.test(s[2])) &&
                    !globMagic.test(s[3]);
                const isDrive = /^[a-z]:/i.test(s[0]);
                if (isUNC) {
                    return [...s.slice(0, 4), ...s.slice(4).map(ss => this.parse(ss))];
                }
                else if (isDrive) {
                    return [s[0], ...s.slice(1).map(ss => this.parse(ss))];
                }
            }
            return s.map(ss => this.parse(ss));
        });
        this.debug(this.pattern, set);
        // filter out everything that didn't compile properly.
        this.set = set.filter(s => s.indexOf(false) === -1);
        // do not treat the ? in UNC paths as magic
        if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
                const p = this.set[i];
                if (p[0] === '' &&
                    p[1] === '' &&
                    this.globParts[i][2] === '?' &&
                    typeof p[3] === 'string' &&
                    /^[a-z]:$/i.test(p[3])) {
                    p[2] = '?';
                }
            }
        }
        this.debug(this.pattern, this.set);
    }
    // various transforms to equivalent pattern sets that are
    // faster to process in a filesystem walk.  The goal is to
    // eliminate what we can, and push all ** patterns as far
    // to the right as possible, even if it increases the number
    // of patterns that we have to process.
    preprocess(globParts) {
        // if we're not in globstar mode, then turn all ** into *
        if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
                for (let j = 0; j < globParts[i].length; j++) {
                    if (globParts[i][j] === '**') {
                        globParts[i][j] = '*';
                    }
                }
            }
        }
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            // aggressive optimization for the purpose of fs walking
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
        }
        else if (optimizationLevel >= 1) {
            // just basic optimizations to remove some .. parts
            globParts = this.levelOneOptimize(globParts);
        }
        else {
            // just collapse multiple ** portions into one
            globParts = this.adjascentGlobstarOptimize(globParts);
        }
        return globParts;
    }
    // just get rid of adjascent ** portions
    adjascentGlobstarOptimize(globParts) {
        return globParts.map(parts => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                let i = gs;
                while (parts[i + 1] === '**') {
                    i++;
                }
                if (i !== gs) {
                    parts.splice(gs, i - gs);
                }
            }
            return parts;
        });
    }
    // get rid of adjascent ** and resolve .. portions
    levelOneOptimize(globParts) {
        return globParts.map(parts => {
            parts = parts.reduce((set, part) => {
                const prev = set[set.length - 1];
                if (part === '**' && prev === '**') {
                    return set;
                }
                if (part === '..') {
                    if (prev && prev !== '..' && prev !== '.' && prev !== '**') {
                        set.pop();
                        return set;
                    }
                }
                set.push(part);
                return set;
            }, []);
            return parts.length === 0 ? [''] : parts;
        });
    }
    levelTwoFileOptimize(parts) {
        if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
        }
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/<e>/<rest> -> <pre>/<rest>
            if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                    const p = parts[i];
                    // don't squeeze out UNC patterns
                    if (i === 1 && p === '' && parts[0] === '')
                        continue;
                    if (p === '.' || p === '') {
                        didSomething = true;
                        parts.splice(i, 1);
                        i--;
                    }
                }
                if (parts[0] === '.' &&
                    parts.length === 2 &&
                    (parts[1] === '.' || parts[1] === '')) {
                    didSomething = true;
                    parts.pop();
                }
            }
            // <pre>/<p>/../<rest> -> <pre>/<rest>
            let dd = 0;
            while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== '.' && p !== '..' && p !== '**') {
                    didSomething = true;
                    parts.splice(dd - 1, 2);
                    dd -= 2;
                }
            }
        } while (didSomething);
        return parts.length === 0 ? [''] : parts;
    }
    // First phase: single-pattern processing
    // <pre> is 1 or more portions
    // <rest> is 1 or more portions
    // <p> is any portion other than ., .., '', or **
    // <e> is . or ''
    //
    // **/.. is *brutal* for filesystem walking performance, because
    // it effectively resets the recursive walk each time it occurs,
    // and ** cannot be reduced out by a .. pattern part like a regexp
    // or most strings (other than .., ., and '') can be.
    //
    // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
    // <pre>/<e>/<rest> -> <pre>/<rest>
    // <pre>/<p>/../<rest> -> <pre>/<rest>
    // **/**/<rest> -> **/<rest>
    //
    // **/*/<rest> -> */**/<rest> <== not valid because ** doesn't follow
    // this WOULD be allowed if ** did follow symlinks, or * didn't
    firstPhasePreProcess(globParts) {
        let didSomething = false;
        do {
            didSomething = false;
            // <pre>/**/../<p>/<p>/<rest> -> {<pre>/../<p>/<p>/<rest>,<pre>/**/<p>/<p>/<rest>}
            for (let parts of globParts) {
                let gs = -1;
                while (-1 !== (gs = parts.indexOf('**', gs + 1))) {
                    let gss = gs;
                    while (parts[gss + 1] === '**') {
                        // <pre>/**/**/<rest> -> <pre>/**/<rest>
                        gss++;
                    }
                    // eg, if gs is 2 and gss is 4, that means we have 3 **
                    // parts, and can remove 2 of them.
                    if (gss > gs) {
                        parts.splice(gs + 1, gss - gs);
                    }
                    let next = parts[gs + 1];
                    const p = parts[gs + 2];
                    const p2 = parts[gs + 3];
                    if (next !== '..')
                        continue;
                    if (!p ||
                        p === '.' ||
                        p === '..' ||
                        !p2 ||
                        p2 === '.' ||
                        p2 === '..') {
                        continue;
                    }
                    didSomething = true;
                    // edit parts in place, and push the new one
                    parts.splice(gs, 1);
                    const other = parts.slice(0);
                    other[gs] = '**';
                    globParts.push(other);
                    gs--;
                }
                // <pre>/<e>/<rest> -> <pre>/<rest>
                if (!this.preserveMultipleSlashes) {
                    for (let i = 1; i < parts.length - 1; i++) {
                        const p = parts[i];
                        // don't squeeze out UNC patterns
                        if (i === 1 && p === '' && parts[0] === '')
                            continue;
                        if (p === '.' || p === '') {
                            didSomething = true;
                            parts.splice(i, 1);
                            i--;
                        }
                    }
                    if (parts[0] === '.' &&
                        parts.length === 2 &&
                        (parts[1] === '.' || parts[1] === '')) {
                        didSomething = true;
                        parts.pop();
                    }
                }
                // <pre>/<p>/../<rest> -> <pre>/<rest>
                let dd = 0;
                while (-1 !== (dd = parts.indexOf('..', dd + 1))) {
                    const p = parts[dd - 1];
                    if (p && p !== '.' && p !== '..' && p !== '**') {
                        didSomething = true;
                        const needDot = dd === 1 && parts[dd + 1] === '**';
                        const splin = needDot ? ['.'] : [];
                        parts.splice(dd - 1, 2, ...splin);
                        if (parts.length === 0)
                            parts.push('');
                        dd -= 2;
                    }
                }
            }
        } while (didSomething);
        return globParts;
    }
    // second phase: multi-pattern dedupes
    // {<pre>/*/<rest>,<pre>/<p>/<rest>} -> <pre>/*/<rest>
    // {<pre>/<rest>,<pre>/<rest>} -> <pre>/<rest>
    // {<pre>/**/<rest>,<pre>/<rest>} -> <pre>/**/<rest>
    //
    // {<pre>/**/<rest>,<pre>/**/<p>/<rest>} -> <pre>/**/<rest>
    // ^-- not valid because ** doens't follow symlinks
    secondPhasePreProcess(globParts) {
        for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
                const matched = this.partsMatch(globParts[i], globParts[j], !this.preserveMultipleSlashes);
                if (matched) {
                    globParts[i] = [];
                    globParts[j] = matched;
                    break;
                }
            }
        }
        return globParts.filter(gs => gs.length);
    }
    partsMatch(a, b, emptyGSMatch = false) {
        let ai = 0;
        let bi = 0;
        let result = [];
        let which = '';
        while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
                result.push(which === 'b' ? b[bi] : a[ai]);
                ai++;
                bi++;
            }
            else if (emptyGSMatch && a[ai] === '**' && b[bi] === a[ai + 1]) {
                result.push(a[ai]);
                ai++;
            }
            else if (emptyGSMatch && b[bi] === '**' && a[ai] === b[bi + 1]) {
                result.push(b[bi]);
                bi++;
            }
            else if (a[ai] === '*' &&
                b[bi] &&
                (this.options.dot || !b[bi].startsWith('.')) &&
                b[bi] !== '**') {
                if (which === 'b')
                    return false;
                which = 'a';
                result.push(a[ai]);
                ai++;
                bi++;
            }
            else if (b[bi] === '*' &&
                a[ai] &&
                (this.options.dot || !a[ai].startsWith('.')) &&
                a[ai] !== '**') {
                if (which === 'a')
                    return false;
                which = 'b';
                result.push(b[bi]);
                ai++;
                bi++;
            }
            else {
                return false;
            }
        }
        // if we fall out of the loop, it means they two are identical
        // as long as their lengths match
        return a.length === b.length && result;
    }
    parseNegate() {
        if (this.nonegate)
            return;
        const pattern = this.pattern;
        let negate = false;
        let negateOffset = 0;
        for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {
            negate = !negate;
            negateOffset++;
        }
        if (negateOffset)
            this.pattern = pattern.slice(negateOffset);
        this.negate = negate;
    }
    // set partial to true to test if, for example,
    // "/a/b" matches the start of "/*/b/*/d"
    // Partial means, if you run out of file before you run
    // out of pattern, then that's fine, as long as all
    // the parts match.
    matchOne(file, pattern, partial = false) {
        const options = this.options;
        // UNC paths like //?/X:/... can match X:/... and vice versa
        // Drive letters in absolute drive or unc paths are always compared
        // case-insensitively.
        if (this.isWindows) {
            const fileDrive = typeof file[0] === 'string' && /^[a-z]:$/i.test(file[0]);
            const fileUNC = !fileDrive &&
                file[0] === '' &&
                file[1] === '' &&
                file[2] === '?' &&
                /^[a-z]:$/i.test(file[3]);
            const patternDrive = typeof pattern[0] === 'string' && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC = !patternDrive &&
                pattern[0] === '' &&
                pattern[1] === '' &&
                pattern[2] === '?' &&
                typeof pattern[3] === 'string' &&
                /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === 'number' && typeof pdi === 'number') {
                const [fd, pd] = [file[fdi], pattern[pdi]];
                if (fd.toLowerCase() === pd.toLowerCase()) {
                    pattern[pdi] = fd;
                    if (pdi > fdi) {
                        pattern = pattern.slice(pdi);
                    }
                    else if (fdi > pdi) {
                        file = file.slice(fdi);
                    }
                }
            }
        }
        // resolve and reduce . and .. portions in the file as well.
        // dont' need to do the second phase, because it's only one string[]
        const { optimizationLevel = 1 } = this.options;
        if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
        }
        this.debug('matchOne', this, { file, pattern });
        this.debug('matchOne', file.length, pattern.length);
        for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
            this.debug('matchOne loop');
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            // should be impossible.
            // some invalid regexp stuff in the set.
            /* c8 ignore start */
            if (p === false) {
                return false;
            }
            /* c8 ignore stop */
            if (p === exports.GLOBSTAR) {
                this.debug('GLOBSTAR', [pattern, p, f]);
                // "**"
                // a/**/b/**/c would match the following:
                // a/b/x/y/z/c
                // a/x/y/z/b/c
                // a/b/x/b/x/c
                // a/b/c
                // To do this, take the rest of the pattern after
                // the **, and see if it would match the file remainder.
                // If so, return success.
                // If not, the ** "swallows" a segment, and try again.
                // This is recursively awful.
                //
                // a/**/b/**/c matching a/b/x/y/z/c
                // - a matches a
                // - doublestar
                //   - matchOne(b/x/y/z/c, b/**/c)
                //     - b matches b
                //     - doublestar
                //       - matchOne(x/y/z/c, c) -> no
                //       - matchOne(y/z/c, c) -> no
                //       - matchOne(z/c, c) -> no
                //       - matchOne(c, c) yes, hit
                var fr = fi;
                var pr = pi + 1;
                if (pr === pl) {
                    this.debug('** at the end');
                    // a ** at the end will just swallow the rest.
                    // We have found a match.
                    // however, it will not swallow /.x, unless
                    // options.dot is set.
                    // . and .. are *never* matched by **, for explosively
                    // exponential reasons.
                    for (; fi < fl; fi++) {
                        if (file[fi] === '.' ||
                            file[fi] === '..' ||
                            (!options.dot && file[fi].charAt(0) === '.'))
                            return false;
                    }
                    return true;
                }
                // ok, let's see if we can swallow whatever we can.
                while (fr < fl) {
                    var swallowee = file[fr];
                    this.debug('\nglobstar while', file, fr, pattern, pr, swallowee);
                    // XXX remove this slice.  Just pass the start index.
                    if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                        this.debug('globstar found match!', fr, fl, swallowee);
                        // found a match.
                        return true;
                    }
                    else {
                        // can't swallow "." or ".." ever.
                        // can only swallow ".foo" when explicitly asked.
                        if (swallowee === '.' ||
                            swallowee === '..' ||
                            (!options.dot && swallowee.charAt(0) === '.')) {
                            this.debug('dot detected!', file, fr, pattern, pr);
                            break;
                        }
                        // ** swallows a segment, and continue.
                        this.debug('globstar swallow a segment, and continue');
                        fr++;
                    }
                }
                // no match was found.
                // However, in partial mode, we can't say this is necessarily over.
                /* c8 ignore start */
                if (partial) {
                    // ran out of file
                    this.debug('\n>>> no match, partial?', file, fr, pattern, pr);
                    if (fr === fl) {
                        return true;
                    }
                }
                /* c8 ignore stop */
                return false;
            }
            // something other than **
            // non-magic patterns just have to match exactly
            // patterns with magic have been turned into regexps.
            let hit;
            if (typeof p === 'string') {
                hit = f === p;
                this.debug('string match', p, f, hit);
            }
            else {
                hit = p.test(f);
                this.debug('pattern match', p, f, hit);
            }
            if (!hit)
                return false;
        }
        // Note: ending in / means that we'll get a final ""
        // at the end of the pattern.  This can only match a
        // corresponding "" at the end of the file.
        // If the file ends in /, then it can only match a
        // a pattern that ends in /, unless the pattern just
        // doesn't have any more for it. But, a/b/ should *not*
        // match "a/b/*", even though "" matches against the
        // [^/]*? pattern, except in partial mode, where it might
        // simply not be reached yet.
        // However, a/b/ should still satisfy a/*
        // now either we fell off the end of the pattern, or we're done.
        if (fi === fl && pi === pl) {
            // ran out of pattern and filename at the same time.
            // an exact hit!
            return true;
        }
        else if (fi === fl) {
            // ran out of file, but still had pattern left.
            // this is ok if we're doing the match as part of
            // a glob fs traversal.
            return partial;
        }
        else if (pi === pl) {
            // ran out of pattern, still have file left.
            // this is only acceptable if we're on the very last
            // empty segment of a file with a trailing slash.
            // a/* should match a/b/
            return fi === fl - 1 && file[fi] === '';
            /* c8 ignore start */
        }
        else {
            // should be unreachable.
            throw new Error('wtf?');
        }
        /* c8 ignore stop */
    }
    braceExpand() {
        return (0, exports.braceExpand)(this.pattern, this.options);
    }
    parse(pattern) {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        const options = this.options;
        // shortcuts
        if (pattern === '**')
            return exports.GLOBSTAR;
        if (pattern === '')
            return '';
        // far and away, the most common glob pattern parts are
        // *, *.*, and *.<ext>  Add a fast check method for those.
        let m;
        let fastTest = null;
        if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
        }
        else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? starDotExtTestNocaseDot
                    : starDotExtTestNocase
                : options.dot
                    ? starDotExtTestDot
                    : starDotExtTest)(m[1]);
        }
        else if ((m = pattern.match(qmarksRE))) {
            fastTest = (options.nocase
                ? options.dot
                    ? qmarksTestNocaseDot
                    : qmarksTestNocase
                : options.dot
                    ? qmarksTestDot
                    : qmarksTest)(m);
        }
        else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
        }
        else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
        }
        const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
        if (fastTest && typeof re === 'object') {
            // Avoids overriding in frozen environments
            Reflect.defineProperty(re, 'test', { value: fastTest });
        }
        return re;
    }
    makeRe() {
        if (this.regexp || this.regexp === false)
            return this.regexp;
        // at this point, this.set is a 2d array of partial
        // pattern strings, or "**".
        //
        // It's better to use .match().  This function shouldn't
        // be used, really, but it's pretty convenient sometimes,
        // when you just want to work with a regex.
        const set = this.set;
        if (!set.length) {
            this.regexp = false;
            return this.regexp;
        }
        const options = this.options;
        const twoStar = options.noglobstar
            ? star
            : options.dot
                ? twoStarDot
                : twoStarNoDot;
        const flags = new Set(options.nocase ? ['i'] : []);
        // regexpify non-globstar patterns
        // if ** is only item, then we just do one twoStar
        // if ** is first, and there are more, prepend (\/|twoStar\/)? to next
        // if ** is last, append (\/twoStar|) to previous
        // if ** is in the middle, append (\/|\/twoStar\/) to previous
        // then filter out GLOBSTAR symbols
        let re = set
            .map(pattern => {
            const pp = pattern.map(p => {
                if (p instanceof RegExp) {
                    for (const f of p.flags.split(''))
                        flags.add(f);
                }
                return typeof p === 'string'
                    ? regExpEscape(p)
                    : p === exports.GLOBSTAR
                        ? exports.GLOBSTAR
                        : p._src;
            });
            pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                    return;
                }
                if (prev === undefined) {
                    if (next !== undefined && next !== exports.GLOBSTAR) {
                        pp[i + 1] = '(?:\\/|' + twoStar + '\\/)?' + next;
                    }
                    else {
                        pp[i] = twoStar;
                    }
                }
                else if (next === undefined) {
                    pp[i - 1] = prev + '(?:\\/|' + twoStar + ')?';
                }
                else if (next !== exports.GLOBSTAR) {
                    pp[i - 1] = prev + '(?:\\/|\\/' + twoStar + '\\/)' + next;
                    pp[i + 1] = exports.GLOBSTAR;
                }
            });
            return pp.filter(p => p !== exports.GLOBSTAR).join('/');
        })
            .join('|');
        // need to wrap in parens if we had more than one thing with |,
        // otherwise only the first will be anchored to ^ and the last to $
        const [open, close] = set.length > 1 ? ['(?:', ')'] : ['', ''];
        // must match entire pattern
        // ending in a * or ** will make it less strict.
        re = '^' + open + re + close + '$';
        // can match anything, as long as it's not this.
        if (this.negate)
            re = '^(?!' + re + ').+$';
        try {
            this.regexp = new RegExp(re, [...flags].join(''));
            /* c8 ignore start */
        }
        catch (ex) {
            // should be impossible
            this.regexp = false;
        }
        /* c8 ignore stop */
        return this.regexp;
    }
    slashSplit(p) {
        // if p starts with // on windows, we preserve that
        // so that UNC paths aren't broken.  Otherwise, any number of
        // / characters are coalesced into one, unless
        // preserveMultipleSlashes is set to true.
        if (this.preserveMultipleSlashes) {
            return p.split('/');
        }
        else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            // add an extra '' for the one we lose
            return ['', ...p.split(/\/+/)];
        }
        else {
            return p.split(/\/+/);
        }
    }
    match(f, partial = this.partial) {
        this.debug('match', f, this.pattern);
        // short-circuit in the case of busted things.
        // comments, etc.
        if (this.comment) {
            return false;
        }
        if (this.empty) {
            return f === '';
        }
        if (f === '/' && partial) {
            return true;
        }
        const options = this.options;
        // windows: need to use /, not \
        if (this.isWindows) {
            f = f.split('\\').join('/');
        }
        // treat the test path as a set of pathparts.
        const ff = this.slashSplit(f);
        this.debug(this.pattern, 'split', ff);
        // just ONE of the pattern sets in this.set needs to match
        // in order for it to be valid.  If negating, then just one
        // match means that we have failed.
        // Either way, return on the first hit.
        const set = this.set;
        this.debug(this.pattern, 'set', set);
        // Find the basename of the path by looking for the last non-empty segment
        let filename = ff[ff.length - 1];
        if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
                filename = ff[i];
            }
        }
        for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
                file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
                if (options.flipNegate) {
                    return true;
                }
                return !this.negate;
            }
        }
        // didn't get any hits.  this is success if it's a negative
        // pattern, failure otherwise.
        if (options.flipNegate) {
            return false;
        }
        return this.negate;
    }
    static defaults(def) {
        return exports.minimatch.defaults(def).Minimatch;
    }
}
exports.Minimatch = Minimatch;
/* c8 ignore start */
var ast_js_2 = __webpack_require__(130);
Object.defineProperty(exports, "AST", ({ enumerable: true, get: function () { return ast_js_2.AST; } }));
var escape_js_2 = __webpack_require__(133);
Object.defineProperty(exports, "escape", ({ enumerable: true, get: function () { return escape_js_2.escape; } }));
var unescape_js_2 = __webpack_require__(132);
Object.defineProperty(exports, "unescape", ({ enumerable: true, get: function () { return unescape_js_2.unescape; } }));
/* c8 ignore stop */
exports.minimatch.AST = ast_js_1.AST;
exports.minimatch.Minimatch = Minimatch;
exports.minimatch.escape = escape_js_1.escape;
exports.minimatch.unescape = unescape_js_1.unescape;
//# sourceMappingURL=index.js.map

/***/ }),
/* 127 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var balanced = __webpack_require__(128);

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m) return [str];

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  if (/\$$/.test(m.pre)) {    
    for (var k = 0; k < post.length; k++) {
      var expansion = pre+ '{' + m.body + '}' + post[k];
      expansions.push(expansion);
    }
  } else {
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(',') >= 0;
    if (!isSequence && !isOptions) {
      // {a},b}
      if (m.post.match(/,(?!,).*\}/)) {
        str = m.pre + '{' + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }

    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        // x{{a,b}}y ==> x{a}y x{b}y
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }

    // at this point, n is the parts, and we know it's not a comma set
    // with a single entry.
    var N;

    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length)
      var incr = n.length == 3
        ? Math.abs(numeric(n[2]))
        : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);

      N = [];

      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === '\\')
            c = '';
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join('0');
              if (i < 0)
                c = '-' + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = [];

      for (var j = 0; j < n.length; j++) {
        N.push.apply(N, expand(n[j], false));
      }
    }

    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
  }

  return expansions;
}



/***/ }),
/* 128 */
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    if(a===b) {
      return [ai, bi];
    }
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),
/* 129 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.assertValidPattern = void 0;
const MAX_PATTERN_LENGTH = 1024 * 64;
const assertValidPattern = (pattern) => {
    if (typeof pattern !== 'string') {
        throw new TypeError('invalid pattern');
    }
    if (pattern.length > MAX_PATTERN_LENGTH) {
        throw new TypeError('pattern is too long');
    }
};
exports.assertValidPattern = assertValidPattern;
//# sourceMappingURL=assert-valid-pattern.js.map

/***/ }),
/* 130 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

// parse a single path portion
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AST = void 0;
const brace_expressions_js_1 = __webpack_require__(131);
const unescape_js_1 = __webpack_require__(132);
const types = new Set(['!', '?', '+', '*', '@']);
const isExtglobType = (c) => types.has(c);
// Patterns that get prepended to bind to the start of either the
// entire string, or just a single path portion, to prevent dots
// and/or traversal patterns, when needed.
// Exts don't need the ^ or / bit, because the root binds that already.
const startNoTraversal = '(?!(?:^|/)\\.\\.?(?:$|/))';
const startNoDot = '(?!\\.)';
// characters that indicate a start of pattern needs the "no dots" bit,
// because a dot *might* be matched. ( is not in the list, because in
// the case of a child extglob, it will handle the prevention itself.
const addPatternStart = new Set(['[', '.']);
// cases where traversal is A-OK, no dot prevention needed
const justDots = new Set(['..', '.']);
const reSpecials = new Set('().*{}+?[]^$\\!');
const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// any single thing other than /
const qmark = '[^/]';
// * => any number of characters
const star = qmark + '*?';
// use + when we need to ensure that *something* matches, because the * is
// the only thing in the path portion.
const starNoEmpty = qmark + '+?';
// remove the \ chars that we added if we end up doing a nonmagic compare
// const deslash = (s: string) => s.replace(/\\(.)/g, '$1')
class AST {
    type;
    #root;
    #hasMagic;
    #uflag = false;
    #parts = [];
    #parent;
    #parentIndex;
    #negs;
    #filledNegs = false;
    #options;
    #toString;
    // set to true if it's an extglob with no children
    // (which really means one child of '')
    #emptyExt = false;
    constructor(type, parent, options = {}) {
        this.type = type;
        // extglobs are inherently magical
        if (type)
            this.#hasMagic = true;
        this.#parent = parent;
        this.#root = this.#parent ? this.#parent.#root : this;
        this.#options = this.#root === this ? options : this.#root.#options;
        this.#negs = this.#root === this ? [] : this.#root.#negs;
        if (type === '!' && !this.#root.#filledNegs)
            this.#negs.push(this);
        this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
    }
    get hasMagic() {
        /* c8 ignore start */
        if (this.#hasMagic !== undefined)
            return this.#hasMagic;
        /* c8 ignore stop */
        for (const p of this.#parts) {
            if (typeof p === 'string')
                continue;
            if (p.type || p.hasMagic)
                return (this.#hasMagic = true);
        }
        // note: will be undefined until we generate the regexp src and find out
        return this.#hasMagic;
    }
    // reconstructs the pattern
    toString() {
        if (this.#toString !== undefined)
            return this.#toString;
        if (!this.type) {
            return (this.#toString = this.#parts.map(p => String(p)).join(''));
        }
        else {
            return (this.#toString =
                this.type + '(' + this.#parts.map(p => String(p)).join('|') + ')');
        }
    }
    #fillNegs() {
        /* c8 ignore start */
        if (this !== this.#root)
            throw new Error('should only call on root');
        if (this.#filledNegs)
            return this;
        /* c8 ignore stop */
        // call toString() once to fill this out
        this.toString();
        this.#filledNegs = true;
        let n;
        while ((n = this.#negs.pop())) {
            if (n.type !== '!')
                continue;
            // walk up the tree, appending everthing that comes AFTER parentIndex
            let p = n;
            let pp = p.#parent;
            while (pp) {
                for (let i = p.#parentIndex + 1; !pp.type && i < pp.#parts.length; i++) {
                    for (const part of n.#parts) {
                        /* c8 ignore start */
                        if (typeof part === 'string') {
                            throw new Error('string part in extglob AST??');
                        }
                        /* c8 ignore stop */
                        part.copyIn(pp.#parts[i]);
                    }
                }
                p = pp;
                pp = p.#parent;
            }
        }
        return this;
    }
    push(...parts) {
        for (const p of parts) {
            if (p === '')
                continue;
            /* c8 ignore start */
            if (typeof p !== 'string' && !(p instanceof AST && p.#parent === this)) {
                throw new Error('invalid part: ' + p);
            }
            /* c8 ignore stop */
            this.#parts.push(p);
        }
    }
    toJSON() {
        const ret = this.type === null
            ? this.#parts.slice().map(p => (typeof p === 'string' ? p : p.toJSON()))
            : [this.type, ...this.#parts.map(p => p.toJSON())];
        if (this.isStart() && !this.type)
            ret.unshift([]);
        if (this.isEnd() &&
            (this === this.#root ||
                (this.#root.#filledNegs && this.#parent?.type === '!'))) {
            ret.push({});
        }
        return ret;
    }
    isStart() {
        if (this.#root === this)
            return true;
        // if (this.type) return !!this.#parent?.isStart()
        if (!this.#parent?.isStart())
            return false;
        if (this.#parentIndex === 0)
            return true;
        // if everything AHEAD of this is a negation, then it's still the "start"
        const p = this.#parent;
        for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === '!')) {
                return false;
            }
        }
        return true;
    }
    isEnd() {
        if (this.#root === this)
            return true;
        if (this.#parent?.type === '!')
            return true;
        if (!this.#parent?.isEnd())
            return false;
        if (!this.type)
            return this.#parent?.isEnd();
        // if not root, it'll always have a parent
        /* c8 ignore start */
        const pl = this.#parent ? this.#parent.#parts.length : 0;
        /* c8 ignore stop */
        return this.#parentIndex === pl - 1;
    }
    copyIn(part) {
        if (typeof part === 'string')
            this.push(part);
        else
            this.push(part.clone(this));
    }
    clone(parent) {
        const c = new AST(this.type, parent);
        for (const p of this.#parts) {
            c.copyIn(p);
        }
        return c;
    }
    static #parseAST(str, ast, pos, opt) {
        let escaping = false;
        let inBrace = false;
        let braceStart = -1;
        let braceNeg = false;
        if (ast.type === null) {
            // outside of a extglob, append until we find a start
            let i = pos;
            let acc = '';
            while (i < str.length) {
                const c = str.charAt(i++);
                // still accumulate escapes at this point, but we do ignore
                // starts that are escaped
                if (escaping || c === '\\') {
                    escaping = !escaping;
                    acc += c;
                    continue;
                }
                if (inBrace) {
                    if (i === braceStart + 1) {
                        if (c === '^' || c === '!') {
                            braceNeg = true;
                        }
                    }
                    else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                        inBrace = false;
                    }
                    acc += c;
                    continue;
                }
                else if (c === '[') {
                    inBrace = true;
                    braceStart = i;
                    braceNeg = false;
                    acc += c;
                    continue;
                }
                if (!opt.noext && isExtglobType(c) && str.charAt(i) === '(') {
                    ast.push(acc);
                    acc = '';
                    const ext = new AST(c, ast);
                    i = AST.#parseAST(str, ext, i, opt);
                    ast.push(ext);
                    continue;
                }
                acc += c;
            }
            ast.push(acc);
            return i;
        }
        // some kind of extglob, pos is at the (
        // find the next | or )
        let i = pos + 1;
        let part = new AST(null, ast);
        const parts = [];
        let acc = '';
        while (i < str.length) {
            const c = str.charAt(i++);
            // still accumulate escapes at this point, but we do ignore
            // starts that are escaped
            if (escaping || c === '\\') {
                escaping = !escaping;
                acc += c;
                continue;
            }
            if (inBrace) {
                if (i === braceStart + 1) {
                    if (c === '^' || c === '!') {
                        braceNeg = true;
                    }
                }
                else if (c === ']' && !(i === braceStart + 2 && braceNeg)) {
                    inBrace = false;
                }
                acc += c;
                continue;
            }
            else if (c === '[') {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
            }
            if (isExtglobType(c) && str.charAt(i) === '(') {
                part.push(acc);
                acc = '';
                const ext = new AST(c, part);
                part.push(ext);
                i = AST.#parseAST(str, ext, i, opt);
                continue;
            }
            if (c === '|') {
                part.push(acc);
                acc = '';
                parts.push(part);
                part = new AST(null, ast);
                continue;
            }
            if (c === ')') {
                if (acc === '' && ast.#parts.length === 0) {
                    ast.#emptyExt = true;
                }
                part.push(acc);
                acc = '';
                ast.push(...parts, part);
                return i;
            }
            acc += c;
        }
        // unfinished extglob
        // if we got here, it was a malformed extglob! not an extglob, but
        // maybe something else in there.
        ast.type = null;
        ast.#hasMagic = undefined;
        ast.#parts = [str.substring(pos - 1)];
        return i;
    }
    static fromGlob(pattern, options = {}) {
        const ast = new AST(null, undefined, options);
        AST.#parseAST(pattern, ast, 0, options);
        return ast;
    }
    // returns the regular expression if there's magic, or the unescaped
    // string if not.
    toMMPattern() {
        // should only be called on root
        /* c8 ignore start */
        if (this !== this.#root)
            return this.#root.toMMPattern();
        /* c8 ignore stop */
        const glob = this.toString();
        const [re, body, hasMagic, uflag] = this.toRegExpSource();
        // if we're in nocase mode, and not nocaseMagicOnly, then we do
        // still need a regular expression if we have to case-insensitively
        // match capital/lowercase characters.
        const anyMagic = hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
                !this.#options.nocaseMagicOnly &&
                glob.toUpperCase() !== glob.toLowerCase());
        if (!anyMagic) {
            return body;
        }
        const flags = (this.#options.nocase ? 'i' : '') + (uflag ? 'u' : '');
        return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
        });
    }
    get options() {
        return this.#options;
    }
    // returns the string match, the regexp source, whether there's magic
    // in the regexp (so a regular expression is required) and whether or
    // not the uflag is needed for the regular expression (for posix classes)
    // TODO: instead of injecting the start/end at this point, just return
    // the BODY of the regexp, along with the start/end portions suitable
    // for binding the start/end in either a joined full-path makeRe context
    // (where we bind to (^|/), or a standalone matchPart context (where
    // we bind to ^, and not /).  Otherwise slashes get duped!
    //
    // In part-matching mode, the start is:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: ^(?!\.\.?$)
    // - if dots allowed or not possible: ^
    // - if dots possible and not allowed: ^(?!\.)
    // end is:
    // - if not isEnd(): nothing
    // - else: $
    //
    // In full-path matching mode, we put the slash at the START of the
    // pattern, so start is:
    // - if first pattern: same as part-matching mode
    // - if not isStart(): nothing
    // - if traversal possible, but not allowed: /(?!\.\.?(?:$|/))
    // - if dots allowed or not possible: /
    // - if dots possible and not allowed: /(?!\.)
    // end is:
    // - if last pattern, same as part-matching mode
    // - else nothing
    //
    // Always put the (?:$|/) on negated tails, though, because that has to be
    // there to bind the end of the negated pattern portion, and it's easier to
    // just stick it in now rather than try to inject it later in the middle of
    // the pattern.
    //
    // We can just always return the same end, and leave it up to the caller
    // to know whether it's going to be used joined or in parts.
    // And, if the start is adjusted slightly, can do the same there:
    // - if not isStart: nothing
    // - if traversal possible, but not allowed: (?:/|^)(?!\.\.?$)
    // - if dots allowed or not possible: (?:/|^)
    // - if dots possible and not allowed: (?:/|^)(?!\.)
    //
    // But it's better to have a simpler binding without a conditional, for
    // performance, so probably better to return both start options.
    //
    // Then the caller just ignores the end if it's not the first pattern,
    // and the start always gets applied.
    //
    // But that's always going to be $ if it's the ending pattern, or nothing,
    // so the caller can just attach $ at the end of the pattern when building.
    //
    // So the todo is:
    // - better detect what kind of start is needed
    // - return both flavors of starting pattern
    // - attach $ at the end of the pattern when creating the actual RegExp
    //
    // Ah, but wait, no, that all only applies to the root when the first pattern
    // is not an extglob. If the first pattern IS an extglob, then we need all
    // that dot prevention biz to live in the extglob portions, because eg
    // +(*|.x*) can match .xy but not .yx.
    //
    // So, return the two flavors if it's #root and the first child is not an
    // AST, otherwise leave it to the child AST to handle it, and there,
    // use the (?:^|/) style of start binding.
    //
    // Even simplified further:
    // - Since the start for a join is eg /(?!\.) and the start for a part
    // is ^(?!\.), we can just prepend (?!\.) to the pattern (either root
    // or start or whatever) and prepend ^ or / at the Regexp construction.
    toRegExpSource(allowDot) {
        const dot = allowDot ?? !!this.#options.dot;
        if (this.#root === this)
            this.#fillNegs();
        if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
                .map(p => {
                const [re, _, hasMagic, uflag] = typeof p === 'string'
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
            })
                .join('');
            let start = '';
            if (this.isStart()) {
                if (typeof this.#parts[0] === 'string') {
                    // this is the string that will match the start of the pattern,
                    // so we need to protect against dots and such.
                    // '.' and '..' cannot match unless the pattern is that exactly,
                    // even if it starts with . or dot:true is set.
                    const dotTravAllowed = this.#parts.length === 1 && justDots.has(this.#parts[0]);
                    if (!dotTravAllowed) {
                        const aps = addPatternStart;
                        // check if we have a possibility of matching . or ..,
                        // and prevent that.
                        const needNoTrav = 
                        // dots are allowed, and the pattern starts with [ or .
                        (dot && aps.has(src.charAt(0))) ||
                            // the pattern starts with \., and then [ or .
                            (src.startsWith('\\.') && aps.has(src.charAt(2))) ||
                            // the pattern starts with \.\., and then [ or .
                            (src.startsWith('\\.\\.') && aps.has(src.charAt(4)));
                        // no need to prevent dots if it can't match a dot, or if a
                        // sub-pattern will be preventing it anyway.
                        const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                        start = needNoTrav ? startNoTraversal : needNoDot ? startNoDot : '';
                    }
                }
            }
            // append the "end of path portion" pattern to negation tails
            let end = '';
            if (this.isEnd() &&
                this.#root.#filledNegs &&
                this.#parent?.type === '!') {
                end = '(?:$|\\/)';
            }
            const final = start + src + end;
            return [
                final,
                (0, unescape_js_1.unescape)(src),
                (this.#hasMagic = !!this.#hasMagic),
                this.#uflag,
            ];
        }
        // We need to calculate the body *twice* if it's a repeat pattern
        // at the start, once in nodot mode, then again in dot mode, so a
        // pattern like *(?) can match 'x.y'
        const repeated = this.type === '*' || this.type === '+';
        // some kind of extglob
        const start = this.type === '!' ? '(?:(?!(?:' : '(?:';
        let body = this.#partsToRegExp(dot);
        if (this.isStart() && this.isEnd() && !body && this.type !== '!') {
            // invalid extglob, has to at least be *something* present, if it's
            // the entire path portion.
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [s, (0, unescape_js_1.unescape)(this.toString()), false, false];
        }
        // XXX abstract out this map method
        let bodyDotAllowed = !repeated || allowDot || dot || !startNoDot
            ? ''
            : this.#partsToRegExp(true);
        if (bodyDotAllowed === body) {
            bodyDotAllowed = '';
        }
        if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
        }
        // an empty !() is exactly equivalent to a starNoEmpty
        let final = '';
        if (this.type === '!' && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : '') + starNoEmpty;
        }
        else {
            const close = this.type === '!'
                ? // !() must match something,but !(x) can match ''
                    '))' +
                        (this.isStart() && !dot && !allowDot ? startNoDot : '') +
                        star +
                        ')'
                : this.type === '@'
                    ? ')'
                    : this.type === '?'
                        ? ')?'
                        : this.type === '+' && bodyDotAllowed
                            ? ')'
                            : this.type === '*' && bodyDotAllowed
                                ? `)?`
                                : `)${this.type}`;
            final = start + body + close;
        }
        return [
            final,
            (0, unescape_js_1.unescape)(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
        ];
    }
    #partsToRegExp(dot) {
        return this.#parts
            .map(p => {
            // extglob ASTs should only contain parent ASTs
            /* c8 ignore start */
            if (typeof p === 'string') {
                throw new Error('string type in extglob ast??');
            }
            /* c8 ignore stop */
            // can ignore hasMagic, because extglobs are already always magic
            const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
            this.#uflag = this.#uflag || uflag;
            return re;
        })
            .filter(p => !(this.isStart() && this.isEnd()) || !!p)
            .join('|');
    }
    static #parseGlob(glob, hasMagic, noEmpty = false) {
        let escaping = false;
        let re = '';
        let uflag = false;
        for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
                escaping = false;
                re += (reSpecials.has(c) ? '\\' : '') + c;
                continue;
            }
            if (c === '\\') {
                if (i === glob.length - 1) {
                    re += '\\\\';
                }
                else {
                    escaping = true;
                }
                continue;
            }
            if (c === '[') {
                const [src, needUflag, consumed, magic] = (0, brace_expressions_js_1.parseClass)(glob, i);
                if (consumed) {
                    re += src;
                    uflag = uflag || needUflag;
                    i += consumed - 1;
                    hasMagic = hasMagic || magic;
                    continue;
                }
            }
            if (c === '*') {
                if (noEmpty && glob === '*')
                    re += starNoEmpty;
                else
                    re += star;
                hasMagic = true;
                continue;
            }
            if (c === '?') {
                re += qmark;
                hasMagic = true;
                continue;
            }
            re += regExpEscape(c);
        }
        return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
    }
}
exports.AST = AST;
//# sourceMappingURL=ast.js.map

/***/ }),
/* 131 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

// translate the various posix character classes into unicode properties
// this works across all unicode locales
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseClass = void 0;
// { <posix class>: [<translation>, /u flag required, negated]
const posixClasses = {
    '[:alnum:]': ['\\p{L}\\p{Nl}\\p{Nd}', true],
    '[:alpha:]': ['\\p{L}\\p{Nl}', true],
    '[:ascii:]': ['\\x' + '00-\\x' + '7f', false],
    '[:blank:]': ['\\p{Zs}\\t', true],
    '[:cntrl:]': ['\\p{Cc}', true],
    '[:digit:]': ['\\p{Nd}', true],
    '[:graph:]': ['\\p{Z}\\p{C}', true, true],
    '[:lower:]': ['\\p{Ll}', true],
    '[:print:]': ['\\p{C}', true],
    '[:punct:]': ['\\p{P}', true],
    '[:space:]': ['\\p{Z}\\t\\r\\n\\v\\f', true],
    '[:upper:]': ['\\p{Lu}', true],
    '[:word:]': ['\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}', true],
    '[:xdigit:]': ['A-Fa-f0-9', false],
};
// only need to escape a few things inside of brace expressions
// escapes: [ \ ] -
const braceEscape = (s) => s.replace(/[[\]\\-]/g, '\\$&');
// escape all regexp magic characters
const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
// everything has already been escaped, we just have to join
const rangesToString = (ranges) => ranges.join('');
// takes a glob string at a posix brace expression, and returns
// an equivalent regular expression source, and boolean indicating
// whether the /u flag needs to be applied, and the number of chars
// consumed to parse the character class.
// This also removes out of order ranges, and returns ($.) if the
// entire class just no good.
const parseClass = (glob, position) => {
    const pos = position;
    /* c8 ignore start */
    if (glob.charAt(pos) !== '[') {
        throw new Error('not in a brace expression');
    }
    /* c8 ignore stop */
    const ranges = [];
    const negs = [];
    let i = pos + 1;
    let sawStart = false;
    let uflag = false;
    let escaping = false;
    let negate = false;
    let endPos = pos;
    let rangeStart = '';
    WHILE: while (i < glob.length) {
        const c = glob.charAt(i);
        if ((c === '!' || c === '^') && i === pos + 1) {
            negate = true;
            i++;
            continue;
        }
        if (c === ']' && sawStart && !escaping) {
            endPos = i + 1;
            break;
        }
        sawStart = true;
        if (c === '\\') {
            if (!escaping) {
                escaping = true;
                i++;
                continue;
            }
            // escaped \ char, fall through and treat like normal char
        }
        if (c === '[' && !escaping) {
            // either a posix class, a collation equivalent, or just a [
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
                if (glob.startsWith(cls, i)) {
                    // invalid, [a-[] is fine, but not [a-[:alpha]]
                    if (rangeStart) {
                        return ['$.', false, glob.length - pos, true];
                    }
                    i += cls.length;
                    if (neg)
                        negs.push(unip);
                    else
                        ranges.push(unip);
                    uflag = uflag || u;
                    continue WHILE;
                }
            }
        }
        // now it's just a normal character, effectively
        escaping = false;
        if (rangeStart) {
            // throw this range away if it's not valid, but others
            // can still match.
            if (c > rangeStart) {
                ranges.push(braceEscape(rangeStart) + '-' + braceEscape(c));
            }
            else if (c === rangeStart) {
                ranges.push(braceEscape(c));
            }
            rangeStart = '';
            i++;
            continue;
        }
        // now might be the start of a range.
        // can be either c-d or c-] or c<more...>] or c] at this point
        if (glob.startsWith('-]', i + 1)) {
            ranges.push(braceEscape(c + '-'));
            i += 2;
            continue;
        }
        if (glob.startsWith('-', i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
        }
        // not the start of a range, just a single character
        ranges.push(braceEscape(c));
        i++;
    }
    if (endPos < i) {
        // didn't see the end of the class, not a valid class,
        // but might still be valid as a literal match.
        return ['', false, 0, false];
    }
    // if we got no ranges and no negates, then we have a range that
    // cannot possibly match anything, and that poisons the whole glob
    if (!ranges.length && !negs.length) {
        return ['$.', false, glob.length - pos, true];
    }
    // if we got one positive range, and it's a single character, then that's
    // not actually a magic pattern, it's just that one literal character.
    // we should not treat that as "magic", we should just return the literal
    // character. [_] is a perfectly valid way to escape glob magic chars.
    if (negs.length === 0 &&
        ranges.length === 1 &&
        /^\\?.$/.test(ranges[0]) &&
        !negate) {
        const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
        return [regexpEscape(r), false, endPos - pos, false];
    }
    const sranges = '[' + (negate ? '^' : '') + rangesToString(ranges) + ']';
    const snegs = '[' + (negate ? '' : '^') + rangesToString(negs) + ']';
    const comb = ranges.length && negs.length
        ? '(' + sranges + '|' + snegs + ')'
        : ranges.length
            ? sranges
            : snegs;
    return [comb, uflag, endPos - pos, true];
};
exports.parseClass = parseClass;
//# sourceMappingURL=brace-expressions.js.map

/***/ }),
/* 132 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.unescape = void 0;
/**
 * Un-escape a string that has been escaped with {@link escape}.
 *
 * If the {@link windowsPathsNoEscape} option is used, then square-brace
 * escapes are removed, but not backslash escapes.  For example, it will turn
 * the string `'[*]'` into `*`, but it will not turn `'\\*'` into `'*'`,
 * becuase `\` is a path separator in `windowsPathsNoEscape` mode.
 *
 * When `windowsPathsNoEscape` is not set, then both brace escapes and
 * backslash escapes are removed.
 *
 * Slashes (and backslashes in `windowsPathsNoEscape` mode) cannot be escaped
 * or unescaped.
 */
const unescape = (s, { windowsPathsNoEscape = false, } = {}) => {
    return windowsPathsNoEscape
        ? s.replace(/\[([^\/\\])\]/g, '$1')
        : s.replace(/((?!\\).|^)\[([^\/\\])\]/g, '$1$2').replace(/\\([^\/])/g, '$1');
};
exports.unescape = unescape;
//# sourceMappingURL=unescape.js.map

/***/ }),
/* 133 */
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.escape = void 0;
/**
 * Escape all magic characters in a glob pattern.
 *
 * If the {@link windowsPathsNoEscape | GlobOptions.windowsPathsNoEscape}
 * option is used, then characters are escaped by wrapping in `[]`, because
 * a magic character wrapped in a character class can only be satisfied by
 * that exact character.  In this mode, `\` is _not_ escaped, because it is
 * not interpreted as a magic character, but instead as a path separator.
 */
const escape = (s, { windowsPathsNoEscape = false, } = {}) => {
    // don't need to escape +@! because we escape the parens
    // that make those magic, and escaping ! as [!] isn't valid,
    // because [!]] is a valid glob class meaning not ']'.
    return windowsPathsNoEscape
        ? s.replace(/[?*()[\]]/g, '[$&]')
        : s.replace(/[?*()[\]\\]/g, '\\$&');
};
exports.escape = escape;
//# sourceMappingURL=escape.js.map

/***/ }),
/* 134 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);

/**
 * 跨平台路径处理工具类
 * 统一使用正斜杠作为内部路径格式，避免Windows和Unix系统的路径分隔符差异
 */
class PathUtils {
    /**
     * 标准化路径格式，统一使用正斜杠
     * @param {string} pathStr - 原始路径字符串
     * @returns {string} 标准化后的路径
     */
    static normalizePath(pathStr) {
        if (!pathStr) return '';
        return path.normalize(pathStr).replace(/\\/g, '/');
    }

    /**
     * 标准化目录路径，确保以正斜杠结尾
     * @param {string} dirPath - 目录路径
     * @returns {string} 标准化的目录路径，以 '/' 结尾
     */
    static normalizeDirPath(dirPath) {
        if (!dirPath) return '';
        const normalized = this.normalizePath(dirPath);
        return normalized.endsWith('/') ? normalized : normalized + '/';
    }

    /**
     * 获取文件的父目录路径，标准化格式
     * @param {string} filePath - 文件路径
     * @returns {string} 父目录路径，以 '/' 结尾
     */
    static getParentDir(filePath) {
        if (!filePath) return '';
        return this.normalizeDirPath(path.dirname(filePath));
    }

    /**
     * 检查是否为根目录
     * @param {string} dirPath - 目录路径
     * @returns {boolean} 是否为根目录
     */
    static isRootDir(dirPath) {
        if (!dirPath) return false;
        const normalized = this.normalizePath(dirPath);
        return normalized === '.' || normalized === '';
    }

    /**
     * 检查是否为当前目录格式
     * @param {string} dirPath - 目录路径
     * @returns {boolean} 是否为当前目录格式（如 './' 或 '.\'）
     */
    static isCurrentDir(dirPath) {
        if (!dirPath) return false;
        const normalized = this.normalizePath(dirPath);
        return normalized === './' || normalized === '.';
    }

    /**
     * 计算路径深度（目录层级数）
     * @param {string} pathStr - 路径字符串
     * @returns {number} 路径深度
     */
    static getPathDepth(pathStr) {
        if (!pathStr) return 0;
        const normalized = this.normalizePath(pathStr);
        if (this.isRootDir(normalized)) return 0;
        return normalized.split('/').filter(part => part !== '' && part !== '.').length;
    }

    /**
     * 获取路径的父目录（不包含末尾分隔符）
     * @param {string} dirPath - 目录路径（以 '/' 结尾）
     * @returns {string} 父目录路径
     */
    static getParentOfDir(dirPath) {
        if (!dirPath || this.isCurrentDir(dirPath)) return '';
        
        // 移除末尾的斜杠
        const cleanPath = dirPath.replace(/\/$/, '');
        if (!cleanPath || cleanPath === '.') return '';
        
        const parentPath = this.normalizePath(path.dirname(cleanPath));
        return this.normalizeDirPath(parentPath);
    }

    /**
     * 检查路径是否相等（忽略平台差异）
     * @param {string} path1 - 路径1
     * @param {string} path2 - 路径2
     * @returns {boolean} 路径是否相等
     */
    static pathEquals(path1, path2) {
        return this.normalizePath(path1) === this.normalizePath(path2);
    }
}

module.exports = PathUtils;

/***/ }),
/* 135 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);

/**
 * 文件类型检测工具类
 * 用于检测二进制文件和文本文件编码
 */
class FileTypeDetector {
    constructor() {
        // 常见二进制文件扩展名
        this.binaryExtensions = new Set([
            '.exe', '.dll', '.so', '.dylib', '.app',  // 可执行文件
            '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.ico', '.svg', '.webp',  // 图片
            '.mp3', '.wav', '.mp4', '.avi', '.mov', '.mkv', '.flv',  // 音视频
            '.zip', '.rar', '.7z', '.tar', '.gz', '.bz2', '.xz',  // 压缩文件
            '.pdf', '.doc', '.docx', '.xls', '.xlsx', '.ppt', '.pptx',  // 办公文档
            '.bin', '.dat', '.db', '.sqlite', '.mdb',  // 数据库/二进制数据
            '.ttf', '.otf', '.woff', '.woff2',  // 字体文件
            '.class', '.jar', '.pyc', '.o', '.obj',  // 编译文件
        ]);

        // 常见文本文件扩展名
        this.textExtensions = new Set([
            '.txt', '.md', '.json', '.xml', '.html', '.htm', '.css', '.js', '.ts',
            '.py', '.java', '.c', '.cpp', '.h', '.hpp', '.cs', '.php', '.rb',
            '.go', '.rs', '.swift', '.kt', '.scala', '.sh', '.bat', '.ps1',
            '.yaml', '.yml', '.toml', '.ini', '.cfg', '.conf', '.log',
            '.sql', '.r', '.m', '.pl', '.lua', '.vim', '.dockerfile'
        ]);

        // 常见文件魔数（前几个字节的特征）
        this.binarySignatures = [
            [0x89, 0x50, 0x4E, 0x47],  // PNG
            [0xFF, 0xD8, 0xFF],         // JPEG
            [0x47, 0x49, 0x46, 0x38],  // GIF
            [0x25, 0x50, 0x44, 0x46],  // PDF
            [0x50, 0x4B, 0x03, 0x04],  // ZIP
            [0x50, 0x4B, 0x05, 0x06],  // ZIP (empty)
            [0x50, 0x4B, 0x07, 0x08],  // ZIP (spanned)
            [0x52, 0x61, 0x72, 0x21],  // RAR
            [0x7F, 0x45, 0x4C, 0x46],  // ELF (Linux执行文件)
            [0x4D, 0x5A],               // Windows PE执行文件
            [0xCA, 0xFE, 0xBA, 0xBE],  // Java class文件
        ];
    }

    /**
     * 检测文件是否为二进制文件
     * @param {Buffer} buffer 文件内容缓冲区
     * @param {string} filePath 文件路径（用于扩展名检测）
     * @returns {boolean} 是否为二进制文件
     */
    isBinaryFile(buffer, filePath = '') {
        // 1. 根据扩展名快速判断
        const ext = this._getFileExtension(filePath).toLowerCase();
        if (this.binaryExtensions.has(ext)) {
            return true;
        }
        if (this.textExtensions.has(ext)) {
            return false;
        }

        // 2. 检查文件魔数
        if (this._hasBinarySignature(buffer)) {
            return true;
        }

        // 3. 检查是否包含空字节（null字符）
        // 大多数二进制文件包含空字节，而文本文件很少有
        const sampleSize = Math.min(8192, buffer.length);  // 检查前8KB
        const sample = buffer.slice(0, sampleSize);
        
        // 检查空字节
        if (sample.includes(0)) {
            return true;
        }

        // 4. 检查不可打印字符的比例
        let nonPrintableCount = 0;
        for (let i = 0; i < sampleSize; i++) {
            const byte = sample[i];
            // 不可打印的ASCII字符（除了常见的空白字符）
            if (byte < 9 || (byte > 13 && byte < 32) || byte === 127) {
                nonPrintableCount++;
            }
        }

        // 如果不可打印字符超过30%，认为是二进制文件
        const nonPrintableRatio = nonPrintableCount / sampleSize;
        if (nonPrintableRatio > 0.3) {
            return true;
        }

        // 5. 检查UTF-8编码的有效性
        try {
            buffer.toString('utf8');
            // 如果能成功转换为UTF-8且没有太多不可打印字符，认为是文本文件
            return false;
        } catch (error) {
            // 如果不能转换为有效的UTF-8，可能是二进制文件
            return true;
        }
    }

    /**
     * 检测文本文件的编码
     * @param {Buffer} buffer 文件内容缓冲区
     * @returns {string|null} 检测到的编码，如果检测失败返回null
     */
    detectEncoding(buffer) {
        // 检查BOM（字节顺序标记）
        if (buffer.length >= 3) {
            // UTF-8 BOM
            if (buffer[0] === 0xEF && buffer[1] === 0xBB && buffer[2] === 0xBF) {
                return 'utf8';
            }
        }
        
        if (buffer.length >= 2) {
            // UTF-16 LE BOM
            if (buffer[0] === 0xFF && buffer[1] === 0xFE) {
                return 'utf16le';
            }
            // UTF-16 BE BOM
            if (buffer[0] === 0xFE && buffer[1] === 0xFF) {
                return 'utf16be';
            }
        }

        // 尝试UTF-8检测
        if (this._isValidUTF8(buffer)) {
            return 'utf8';
        }

        // 简单的ASCII检测
        if (this._isAscii(buffer)) {
            return 'ascii';
        }

        // 如果无法确定，返回null让调用者决定
        return null;
    }

    /**
     * 读取文件内容并返回详细信息
     * @param {Buffer} buffer 文件内容缓冲区
     * @param {string} filePath 文件路径
     * @returns {Object} 文件信息对象
     */
    analyzeFile(buffer, filePath = '') {
        const isBinary = this.isBinaryFile(buffer, filePath);
        
        if (isBinary) {
            return {
                content: null,
                hash: crypto.createHash('sha256').update(buffer).digest('hex'),
                isBinary: true,
                encoding: null,
                size: buffer.length
            };
        } else {
            const encoding = this.detectEncoding(buffer) || 'utf8';
            let content;
            
            try {
                content = buffer.toString(encoding);
            } catch (error) {
                // 如果编码转换失败，退回到utf8
                try {
                    content = buffer.toString('utf8');
                } catch (utf8Error) {
                    // 如果连utf8都失败，可能是二进制文件被误判
                    return {
                        content: null,
                        hash: crypto.createHash('sha256').update(buffer).digest('hex'),
                        isBinary: true,
                        encoding: null,
                        size: buffer.length,
                        error: 'Encoding conversion failed'
                    };
                }
            }
            
            return {
                content: content,
                hash: crypto.createHash('sha256').update(buffer).digest('hex'),
                isBinary: false,
                encoding: encoding,
                size: buffer.length
            };
        }
    }

    /**
     * 获取文件扩展名
     * @private
     */
    _getFileExtension(filePath) {
        const lastDot = filePath.lastIndexOf('.');
        return lastDot === -1 ? '' : filePath.substring(lastDot);
    }

    /**
     * 检查是否有二进制文件魔数
     * @private
     */
    _hasBinarySignature(buffer) {
        if (buffer.length < 4) return false;
        
        for (const signature of this.binarySignatures) {
            if (this._matchesSignature(buffer, signature)) {
                return true;
            }
        }
        return false;
    }

    /**
     * 检查缓冲区是否匹配特定的魔数
     * @private
     */
    _matchesSignature(buffer, signature) {
        if (buffer.length < signature.length) return false;
        
        for (let i = 0; i < signature.length; i++) {
            if (buffer[i] !== signature[i]) {
                return false;
            }
        }
        return true;
    }

    /**
     * 检查是否为有效的UTF-8编码
     * @private
     */
    _isValidUTF8(buffer) {
        try {
            const str = buffer.toString('utf8');
            // 检查转换后的字符串是否包含Unicode替换字符
            // 这通常表明原始数据不是有效的UTF-8
            return !str.includes('\uFFFD');
        } catch (error) {
            return false;
        }
    }

    /**
     * 检查是否为纯ASCII编码
     * @private
     */
    _isAscii(buffer) {
        for (let i = 0; i < buffer.length; i++) {
            if (buffer[i] > 127) {
                return false;
            }
        }
        return true;
    }
}

module.exports = FileTypeDetector;

/***/ }),
/* 136 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);

/**
 * 智能文件筛选器
 * 专门识别和处理有价值的源代码文件
 * 彻底排除第三方依赖、构建产物等无关文件
 */
class IntelligentFileFilter {
    constructor() {
        // 🎯 有价值的源代码文件扩展名
        this.valuableExtensions = new Set([
            // Web前端
            '.js', '.jsx', '.ts', '.tsx', '.vue', '.svelte',
            '.css', '.scss', '.sass', '.less', '.styl',
            '.html', '.htm',
            
            // 后端语言
            '.py', '.rb', '.php', '.java', '.c', '.cpp', '.cc', '.cxx',
            '.cs', '.go', '.rs', '.kt', '.scala', '.clj', '.cljs',
            '.sh', '.bash', '.zsh', '.ps1',
            
            // 移动开发
            '.swift', '.m', '.mm', '.dart',
            
            // 数据和配置（选择性）
            '.sql', '.graphql', '.yaml', '.yml',
            
            // 脚本和自动化
            '.lua', '.pl', '.r'
        ]);

        // 🚫 应该处理但需要特别注意的文件（通常是用户配置）
        this.conditionalExtensions = new Set([
            '.json', '.xml', '.toml', '.ini', '.conf'
        ]);

        // 🎯 有价值的文件名模式（即使扩展名不在列表中）
        this.valuableFilePatterns = [
            /^Dockerfile$/i,
            /^Makefile$/i,
            /^CMakeLists\.txt$/i,
            /^\.env\.example$/i,
            /^\.gitignore$/i,
            /^\.eslintrc$/i,
            /^\.prettierrc$/i,
            /^webpack\.config\./i,
            /^rollup\.config\./i,
            /^vite\.config\./i
        ];

        // 🚫 明确排除的目录（性能优化）
        this.excludedDirectories = new Set([
            'node_modules', 'bower_components', 'vendor', 'packages',
            '.git', '.svn', '.hg', 'CVS',
            'dist', 'build', 'out', 'output', 'public', 'bin', 'obj',
            'coverage', '.nyc_output', 'htmlcov',
            '__pycache__', '.pytest_cache', '.tox', 'venv', 'env', '.env',
            '.cache', '.vector-cache', 'tmp', 'temp', '.tmp',
            '.vscode', '.idea', '.vs'
        ]);

        // 🚫 明确排除的文件名
        this.excludedFileNames = new Set([
            '.ds_store', 'thumbs.db', 'desktop.ini',
            'license', 'license.txt', 'license.md',
            'changelog', 'changelog.txt', 'changelog.md',
            'readme', 'readme.txt', 'readme.md',
            'contributing', 'contributing.md',
            'code_of_conduct.md', 'security.md',
            'authors', 'contributors', 'maintainers'
        ]);
    }

    /**
     * 🎯 判断文件是否值得处理
     * @param {string} filePath - 文件路径
     * @returns {boolean} 是否应该处理该文件
     */
    isValuableFile(filePath) {
        const fileName = path.basename(filePath).toLowerCase();
        const ext = path.extname(filePath).toLowerCase();
        const nameWithoutExt = path.basename(filePath, ext).toLowerCase();

        // 1. 检查是否在排除的文件名列表中
        if (this.excludedFileNames.has(fileName) || 
            this.excludedFileNames.has(nameWithoutExt)) {
            return false;
        }

        // 2. 检查是否是有价值的文件模式
        for (const pattern of this.valuableFilePatterns) {
            if (pattern.test(path.basename(filePath))) {
                return true;
            }
        }

        // 3. 检查文件扩展名
        if (this.valuableExtensions.has(ext)) {
            return true;
        }

        // 4. 有条件的扩展名需要进一步检查
        if (this.conditionalExtensions.has(ext)) {
            return this._isValuableConfigFile(filePath);
        }

        // 5. 默认不处理
        return false;
    }

    /**
     * 🎯 检查路径是否包含应该排除的目录
     * @param {string} filePath - 文件路径
     * @returns {boolean} 是否应该排除
     */
    containsExcludedDirectory(filePath) {
        const pathSegments = filePath.split(path.sep);
        return pathSegments.some(segment => this.excludedDirectories.has(segment));
    }

    /**
     * 🎯 判断配置文件是否有价值
     * @param {string} filePath - 文件路径
     * @returns {boolean} 是否有价值
     */
    _isValuableConfigFile(filePath) {
        const fileName = path.basename(filePath).toLowerCase();
        
        // 项目级配置文件通常有价值
        const valuableConfigPatterns = [
            /^package\.json$/,
            /^composer\.json$/,
            /^requirements\.txt$/,
            /^pipfile$/,
            /^cargo\.toml$/,
            /^go\.mod$/,
            /^pom\.xml$/,
            /^build\.gradle$/,
            /^project\.clj$/,
            /^mix\.exs$/,
            /^.*\.config\.(js|ts|json)$/,
            /^.*rc\.(js|ts|json|yaml|yml)$/,
            /^tsconfig\.json$/,
            /^jsconfig\.json$/
        ];

        return valuableConfigPatterns.some(pattern => pattern.test(fileName));
    }

    /**
     * 🎯 获取文件价值评分
     * @param {string} filePath - 文件路径
     * @returns {number} 价值评分 (0-100)
     */
    getFileValueScore(filePath) {
        if (this.containsExcludedDirectory(filePath)) {
            return 0;
        }

        if (!this.isValuableFile(filePath)) {
            return 0;
        }

        const ext = path.extname(filePath).toLowerCase();
        const fileName = path.basename(filePath);

        // 核心源代码文件最高分
        const coreLanguages = ['.js', '.jsx', '.ts', '.tsx', '.py', '.java', '.c', '.cpp', '.cs', '.go', '.rs'];
        if (coreLanguages.includes(ext)) {
            return 100;
        }

        // 前端文件高分
        const frontendFiles = ['.vue', '.svelte', '.css', '.scss', '.sass', '.less'];
        if (frontendFiles.includes(ext)) {
            return 90;
        }

        // 脚本和配置文件中等分
        const scriptFiles = ['.sh', '.bash', '.ps1', '.sql'];
        if (scriptFiles.includes(ext)) {
            return 80;
        }

        // 特殊文件中等分
        for (const pattern of this.valuableFilePatterns) {
            if (pattern.test(fileName)) {
                return 75;
            }
        }

        // 配置文件较低分
        if (this.conditionalExtensions.has(ext)) {
            return 60;
        }

        return 50;
    }

    /**
     * 🎯 生成处理建议
     * @param {string[]} filePaths - 文件路径列表
     * @returns {Object} 处理建议
     */
    generateProcessingSuggestion(filePaths) {
        const analysis = {
            total: filePaths.length,
            valuable: 0,
            excluded: 0,
            byType: {},
            suggestions: []
        };

        for (const filePath of filePaths) {
            const score = this.getFileValueScore(filePath);
            const ext = path.extname(filePath).toLowerCase() || 'no-ext';

            if (score === 0) {
                analysis.excluded++;
            } else {
                analysis.valuable++;
            }

            if (!analysis.byType[ext]) {
                analysis.byType[ext] = { count: 0, avgScore: 0, totalScore: 0 };
            }
            analysis.byType[ext].count++;
            analysis.byType[ext].totalScore += score;
            analysis.byType[ext].avgScore = analysis.byType[ext].totalScore / analysis.byType[ext].count;
        }

        // 生成建议
        const reductionRate = ((analysis.excluded / analysis.total) * 100).toFixed(1);
        analysis.suggestions.push(`可以跳过 ${analysis.excluded} 个文件 (${reductionRate}%)，专注处理 ${analysis.valuable} 个有价值的文件`);

        if (analysis.excluded > analysis.valuable) {
            analysis.suggestions.push('🎯 建议：启用智能文件筛选可以显著提升处理效率');
        }

        return analysis;
    }
}

module.exports = IntelligentFileFilter; 

/***/ }),
/* 137 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);
const BaseParser = __webpack_require__(138);
const AstParser = __webpack_require__(139);
const ReadlineParser = __webpack_require__(142);
const FilenameParser = __webpack_require__(143);

class ParserSelector {
    constructor(config) {
        this.config = config;
        this.parsers = new Map();
        this._initializeParsers();
    }

    _initializeParsers() {
        // 初始化所有可用的解析器
        this.parsers.set('ast', new AstParser(this.config));
        this.parsers.set('readline', new ReadlineParser(this.config));
        this.parsers.set('filename', new FilenameParser(this.config));
    }

    selectParser(filePath) {
        const extension = path.extname(filePath).toLowerCase();
        const languageMapping = this.config.languageMapping || {
            '.py': 'python',
            '.js': 'javascript',
            '.ts': 'typescript'
        };

        const language = languageMapping[extension];
        if (!language) {
            return this.parsers.get('readline'); // 默认使用行解析器
        }

        // 根据语言选择适当的解析器
        if (['python', 'javascript', 'typescript'].includes(language)) {
            return this.parsers.get('ast');
        }

        return this.parsers.get('readline');
    }
}

module.exports = ParserSelector; 

/***/ }),
/* 138 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);

class BaseParser {
    constructor(config, workspacePath = null) {
        this.config = config || {};
        this.workspacePath = workspacePath;
        this.linesPerChunk = this.config.linesPerChunk || 15;
        this.maxChunkSize = 9 * 1024;
    }

    async parse(filePath) {
        // 抽象方法，子类需要实现
        throw new Error('parse method must be implemented by subclass');
    }

    generateChunkId(filePath, startLine, endLine) {
        const identifier = `${filePath}:${startLine}:${endLine}`;
        return crypto.createHash('sha256').update(identifier).digest('hex');
    }

    _createChunk(content, startLine, endLine, filePath = 'unknown', language = 'unknown', type = 'default') {
        return {
            chunkId: this.generateChunkId(filePath, startLine, endLine),    
            filePath: filePath,
            language: language,
            startLine: startLine,
            endLine: endLine,
            content: content,
            parser: this.constructor.name.toLowerCase().replace('parser', '') + '_parser',
            type: type
        };
    }

    _splitIntoChunks(content, filePath = 'unknown', language = 'unknown') {
        const lines = content.split('\n');
        const chunks = [];
        
        let currentLines = [];
        let currentStartLine = 1;
        
        // 调试信息：记录文件的基本信息

        
        // 检查是否有空行在文件末尾
        const lastLine = lines[lines.length - 1];
        if (lastLine === '' || lastLine.trim() === '') {

        }
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // 跳过空行，避免创建空内容代码块
            if (line.trim() === '' && currentLines.length === 0) {

                currentStartLine = i + 2; // 更新起始行号
                continue;
            }
            
            currentLines.push(line);
            
            const shouldEnd = currentLines.length >= this.linesPerChunk ||
                             Buffer.byteLength(currentLines.join('\n'), 'utf8') >= this.maxChunkSize;
            
            if (shouldEnd || i === lines.length - 1) {
                const chunkContent = currentLines.join('\n');
                const contentSize = Buffer.byteLength(chunkContent, 'utf8');
                
                if (contentSize > this.maxChunkSize && currentLines.length > 1) {
                    const midPoint = Math.floor(currentLines.length / 2);
                    const firstHalf = currentLines.slice(0, midPoint);
                    const secondHalf = currentLines.slice(midPoint);
                    
                    chunks.push(this._createChunk(
                        firstHalf.join('\n'),
                        currentStartLine,
                        currentStartLine + firstHalf.length - 1,
                        filePath,
                        language,
                        'default'   
                    ));
                    
                    currentLines = secondHalf;
                    currentStartLine = currentStartLine + firstHalf.length;
                    i--;
                } else {
                    // 检查内容是否为空，避免创建空内容代码块
                    if (!chunkContent || chunkContent.trim() === '') {
        
                        console.log(`   内容: "${chunkContent}"`);
                        console.log(`   行数组: ${JSON.stringify(currentLines)}`);
                        
                        // 跳过这个空代码块，但继续处理
                        currentStartLine = currentStartLine + currentLines.length;
                        currentLines = [];
                        continue;
                    }
                    
                    const chunk = this._createChunk(
                        chunkContent,
                        currentStartLine,
                        currentStartLine + currentLines.length - 1,
                        filePath,
                        language,
                        'default'
                    );
                    
                    chunks.push(chunk);
                    
                    // 修复Bug: 正确计算下一个代码块的起始行号
                    currentStartLine = currentStartLine + currentLines.length;
                    currentLines = [];
                }
            }
        }
        

        
        return chunks;
    }
}

module.exports = BaseParser; 

/***/ }),
/* 139 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Parser = __webpack_require__(140);
const Python = __webpack_require__(141);
const BaseParser = __webpack_require__(138);
const crypto = __webpack_require__(8);
const path = __webpack_require__(4);

class AstParser extends BaseParser {
    constructor(config) {
        super(config);
        // 静态语言解析器池
        this.languageParserPool = {};
        this.languageDict = {
            python: PythonParser
        };
        // 10KB限制（留1KB余量）
        this.maxChunkSize = 9 * 1024;
        this._initializeParsers();
    }

    _initializeParsers() {
        try {
            // 预初始化支持的语言解析器
            for (const [lang, parserClass] of Object.entries(this.languageDict)) {
                if (!this.languageParserPool[lang]) {
                    this.languageParserPool[lang] = new parserClass(this.config);
                }
            }
        } catch (error) {
            console.warn('Warning: tree-sitter initialization failed. AST parsing may not be available:', error);
        }
    }

    getParserForLanguage(language) {
        // 检查语言是否支持
        if (!this.languageDict[language]) {
            throw new Error(`Unsupported language: ${language}`);
        }

        // 检查池中是否有该语言的解析器
        if (!this.languageParserPool[language]) {
            const parserClass = this.languageDict[language];
            this.languageParserPool[language] = new parserClass(this.config);
        }

        return this.languageParserPool[language];
    }

    async parse(filePath, content = null, language = null) {
        // 如果没有提供内容，读取文件
        if (!content) {
            const fs = (__webpack_require__(5).promises);
            content = await fs.readFile(filePath, 'utf-8');
        }

        if (!language) {
            // 尝试从文件扩展名确定语言
            const ext = path.extname(filePath);
            const langMapping = this.config.languageMapping || {
                '.py': 'python',
                '.js': 'javascript',
                '.ts': 'typescript'
            };
            language = langMapping[ext] || 'unknown';
        }

        try {
            if (!this.languageDict[language]) {
                // 如果语言不支持，使用父类的智能分割方法
                return this._splitIntoChunks(content, filePath, language);
            }

            // 获取适当的语言解析器
            const langParser = this.getParserForLanguage(language);
            
            // 使用语言特定的解析器解析内容
            const chunks = await langParser.parseContent(content, filePath);
            
            // 检查并分割过大的块
            return this._ensureChunkSizeLimit(chunks);

        } catch (error) {
            console.error(`Error parsing file ${filePath}:`, error);
            return [];
        }
    }

    // 确保所有块都在大小限制内
    _ensureChunkSizeLimit(chunks) {
        const result = [];
        
        for (const chunk of chunks) {
            const chunkSize = Buffer.byteLength(chunk.content, 'utf8');
            
            if (chunkSize <= this.maxChunkSize) {
                result.push(chunk);
            } else {
                // 分割过大的块
                const splitChunks = this._splitLargeChunk(chunk);
                result.push(...splitChunks);
            }
        }
        
        return result;
    }

    // 分割过大的代码块
    _splitLargeChunk(chunk) {
        const lines = chunk.content.split('\n');
        const chunks = [];
        let currentLines = [];
        let currentStartLine = chunk.startLine;
        
        for (let i = 0; i < lines.length; i++) {
            currentLines.push(lines[i]);
            const currentContent = currentLines.join('\n');
            const currentSize = Buffer.byteLength(currentContent, 'utf8');
            
            // 如果达到大小限制或是最后一行
            if (currentSize >= this.maxChunkSize || i === lines.length - 1) {
                if (currentSize > this.maxChunkSize && currentLines.length > 1) {
                    // 移除最后一行，保存当前块
                    currentLines.pop();
                    const finalContent = currentLines.join('\n');
                    
                    chunks.push({
                        ...chunk,
                        content: finalContent,
                        startLine: currentStartLine,
                        endLine: currentStartLine + currentLines.length - 1,
                        chunkId: this.generateChunkId(chunk.filePath, currentStartLine, currentStartLine + currentLines.length - 1)
                    });
                    
                    // 从当前行重新开始 - 修复Bug: 应该基于处理的行数更新起始行号
                    const processedLines = currentLines.length;
                    currentLines = [lines[i]];
                    currentStartLine = currentStartLine + processedLines;
                } else {
                    // 保存当前块
                    chunks.push({
                        ...chunk,
                        content: currentContent,
                        startLine: currentStartLine,
                        endLine: currentStartLine + currentLines.length - 1,
                        chunkId: this.generateChunkId(chunk.filePath, currentStartLine, currentStartLine + currentLines.length - 1)
                    });
                    
                    // 重置 - 修复Bug: 在重置currentLines之前先保存长度
                    const processedLines = currentLines.length;
                    currentLines = [];
                    currentStartLine = currentStartLine + processedLines;
                }
            }
        }
        
        return chunks;
    }

    generateChunkId(filePath, startLine, endLine) {
        const identifier = `${filePath}:${startLine}:${endLine}`;
        return crypto.createHash('sha256').update(identifier).digest('hex');
    }
}

class PythonParser extends BaseParser {
    constructor(config) {
        super(config);
        // 节点类型分类
        this.nodeTypes = {
            import: ['import_statement', 'import_from_statement'],
            class: ['class_definition'],
            function: ['function_definition'],
            variable: ['expression_statement', 'assignment']
        };
        
        // 初始化tree-sitter Python解析器
        this.parser = new Parser();
        this.parser.setLanguage(Python);
        
        // 10KB限制（留1KB余量）
        this.maxChunkSize = 9 * 1024;
    }

    // 修复多字节字符处理问题的辅助方法
    _extractNodeCode(code, startByte, endByte) {
        // 将字符串转换为Buffer，使用字节索引进行切片，然后转换回字符串
        const buffer = Buffer.from(code, 'utf-8');
        return buffer.slice(startByte, endByte).toString('utf-8');
    }

    async parseContent(content, filePath = null) {
        try {
            // 验证输入内容
            if (!content || typeof content !== 'string') {
                console.warn(`Invalid content for Python parsing in file: ${filePath || 'unknown'}`);
                return [];
            }

            // 检查内容是否为空或过大
            if (content.length === 0) {
                console.warn(`Empty content for Python parsing in file: ${filePath || 'unknown'}`);
                return [];
            }

            if (content.length > 10 * 1024 * 1024) { // 10MB限制
                console.warn(`Content too large for Python parsing in file: ${filePath || 'unknown'} (${content.length} bytes)`);
                return [];
            }

            // 清理可能导致解析器问题的字符
            let cleanContent = content.replace(/\0/g, ''); // 移除null字符
            
            // 如果文件很大，先尝试截取前面部分进行解析
            if (cleanContent.length > 1024 * 1024) { // 1MB
                console.warn(`Large Python file detected: ${filePath || 'unknown'} (${cleanContent.length} bytes), truncating for parsing`);
                cleanContent = cleanContent.substring(0, 1024 * 1024); // 截取前1MB
            }

            // 尝试解析AST，使用更强的错误处理
            let tree;
            try {
                tree = this.parser.parse(cleanContent);
            } catch (parseError) {
                console.warn(`Direct parsing failed for ${filePath || 'unknown'}: ${parseError.message}`);
                
                // 尝试进一步清理内容
                cleanContent = cleanContent
                    .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F]/g, '') // 移除控制字符
                    .replace(/\r\n/g, '\n') // 标准化换行符
                    .replace(/\r/g, '\n');
                
                try {
                    tree = this.parser.parse(cleanContent);
                } catch (secondError) {
                    console.warn(`Second parsing attempt failed for ${filePath || 'unknown'}: ${secondError.message}`);
                    
                    // 最后尝试：只解析前几行
                    const lines = cleanContent.split('\n').slice(0, 100); // 只取前100行
                    const truncatedContent = lines.join('\n');
                    try {
                        tree = this.parser.parse(truncatedContent);
                        console.warn(`Successfully parsed truncated version of ${filePath || 'unknown'} (first 100 lines)`);
                    } catch (finalError) {
                        console.error(`All parsing attempts failed for ${filePath || 'unknown'}: ${finalError.message}`);
                        return [];
                    }
                }
            }
            
            // 检查解析结果
            if (!tree || !tree.rootNode) {
                console.warn(`Failed to parse AST for file: ${filePath || 'unknown'}`);
                return [];
            }

            const relativePath = filePath ? path.basename(filePath) : 'unknown';

            // 提取不同类型的代码块
            const imports = this._extractImports(tree, cleanContent);
            const classes = this._extractClasses(tree, cleanContent);
            const functions = this._extractFunctions(tree, cleanContent);
            const variables = this._extractVariables(tree, cleanContent);
            const other = this._extractOther(tree, cleanContent);

            // 合并所有chunks并按类型合并相邻的chunks
            const allChunks = [...imports, ...classes, ...functions, ...variables, ...other];
            const mergedChunks = this._mergeAdjacentChunks(allChunks);

            // 格式化chunks
            return mergedChunks.map(chunk => ({
                chunkId: this.generateChunkId(relativePath, chunk.startLine, chunk.endLine),
                filePath: relativePath,
                language: 'python',
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                content: chunk.content,
                parser: 'python_parser',
                type: chunk.type,
                ...(chunk.name && { name: chunk.name })
            }));

        } catch (error) {
            console.error(`Error parsing Python content in file: ${filePath || 'unknown'}:`, error);
            // 返回空数组而不是抛出错误，让处理继续进行
            return [];
        }
    }

    _extractImports(tree, code) {
        const imports = [];
        
        for (const child of tree.rootNode.children) {
            if (this.nodeTypes.import.includes(child.type)) {
                // 使用字节索引和Buffer进行正确的多字节字符处理
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                imports.push({
                    type: 'import',
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return imports;
    }

    _extractClasses(tree, code) {
        const classes = [];
        
        for (const child of tree.rootNode.children) {
            if (this.nodeTypes.class.includes(child.type)) {
                const className = this._getDefinitionName(child);
                // 使用字节索引和Buffer进行正确的多字节字符处理
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                
                classes.push({
                    type: 'class',
                    name: className,
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return classes;
    }

    _extractFunctions(tree, code) {
        const functions = [];
        
        for (const child of tree.rootNode.children) {
            if (this.nodeTypes.function.includes(child.type)) {
                const funcName = this._getDefinitionName(child);
                // 使用字节索引和Buffer进行正确的多字节字符处理
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                
                functions.push({
                    type: 'function',
                    name: funcName,
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return functions;
    }

    _extractVariables(tree, code) {
        const variables = [];
        
        for (const child of tree.rootNode.children) {
            if (this.nodeTypes.variable.includes(child.type)) {
                // 使用字节索引和Buffer进行正确的多字节字符处理
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                
                variables.push({
                    type: 'variable',
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return variables;
    }

    _extractOther(tree, code) {
        const other = [];
        // 获取所有已定义的节点类型
        const allDefinedTypes = Object.values(this.nodeTypes).flat();
        
        for (const child of tree.rootNode.children) {
            if (!allDefinedTypes.includes(child.type)) {
                // 使用字节索引和Buffer进行正确的多字节字符处理
                const nodeCode = this._extractNodeCode(code, child.startIndex, child.endIndex);
                
                other.push({
                    type: 'other',
                    content: nodeCode,
                    startLine: child.startPosition.row + 1,
                    endLine: child.endPosition.row + 1
                });
            }
        }
        
        return other;
    }

    _mergeAdjacentChunks(chunks) {
        if (!chunks.length) return [];

        // 按起始行排序
        const sortedChunks = chunks.sort((a, b) => a.startLine - b.startLine);
        const merged = [];
        let current = sortedChunks[0];

        for (let i = 1; i < sortedChunks.length; i++) {
            const next = sortedChunks[i];
            
            // 如果是相同类型且相邻或非常接近（最多1行间隔）
            if (current.type === next.type && next.startLine <= current.endLine + 2) {
                // 合并chunks
                let content = current.content;
                if (next.startLine > current.endLine) {
                    content += '\n'.repeat(next.startLine - current.endLine);
                }
                content += next.content;

                current = {
                    type: current.type,
                    content: content,
                    startLine: current.startLine,
                    endLine: next.endLine,
                    ...(current.name && { name: current.name }),
                    ...(next.name && !current.name && { name: next.name })
                };
            } else {
                merged.push(current);
                current = next;
            }
        }
        
        merged.push(current);
        return merged;
    }

    _getDefinitionName(node) {
        for (const child of node.children) {
            if (child.type === 'identifier') {
                return child.text;
            }
        }
        return '';
    }

    generateChunkId(filePath, startLine, endLine) {
        const identifier = `${filePath}:${startLine}:${endLine}`;
        return crypto.createHash('sha256').update(identifier).digest('hex');
    }
}

module.exports = AstParser;

/***/ }),
/* 140 */
/***/ ((module) => {

"use strict";
module.exports = require("tree-sitter");

/***/ }),
/* 141 */
/***/ ((module) => {

"use strict";
module.exports = require("tree-sitter-python");

/***/ }),
/* 142 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BaseParser = __webpack_require__(138);
const path = __webpack_require__(4);

class ReadlineParser extends BaseParser {
    constructor(config, workspacePath = null) {
        super(config, workspacePath);
        // 确保使用更小的行数以避免10KB限制
        this.linesPerChunk = this.config.linesPerChunk || 15;
    }

    async parse(filePath, content) {
        if (!content || content.trim().length === 0) {
            return [];
        }

        // 使用父类的智能分割方法，自动处理大小限制
        return this._splitIntoChunks(content, filePath, this._detectLanguage(filePath));
    }

    _detectLanguage(filePath) {
        const ext = filePath.split('.').pop()?.toLowerCase();
        const languageMap = {
            'py': 'python',
            'js': 'javascript',
            'ts': 'typescript',
            'cs': 'csharp',
            'java': 'java',
            'cpp': 'cpp',
            'c': 'c',
            'h': 'c',
            'hpp': 'cpp'
        };
        return languageMap[ext] || 'unknown';
    }
}

module.exports = ReadlineParser; 

/***/ }),
/* 143 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const BaseParser = __webpack_require__(138);
const path = __webpack_require__(4);

class FilenameParser extends BaseParser {
    async parse(filePath, content = null) {
        // 如果没有提供内容，读取文件
        if (!content) {
            const fs = (__webpack_require__(5).promises);
            content = await fs.readFile(filePath, 'utf-8');
        }
        
        // 从文件扩展名推断语言
        const ext = path.extname(filePath);
        const langMapping = this.config.languageMapping || {
            '.py': 'python',
            '.js': 'javascript',
            '.ts': 'typescript',
            '.java': 'java',
            '.cpp': 'cpp',
            '.c': 'c'
        };
        const language = langMapping[ext] || 'unknown';
        const relativePath = path.basename(filePath);
        const lineCount = content.split('\n').length;
        
        return [this._createChunk(content, 1, lineCount, relativePath, language, 'file')];
    }
}

module.exports = FilenameParser; 

/***/ }),
/* 144 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const { Worker } = __webpack_require__(145);
const ParserSelector = __webpack_require__(137);

class Dispatcher {
    constructor(config) {
        this.config = config;
        // 更激进地降低最大Worker数量，默认禁用Worker
        this.maxWorkers = Math.min(config.maxWorkers || 1, 1); // 最多1个Worker
        this.workspacePath = config.workspacePath;
        this.progressTracker = config.progressTracker;
        
        // 默认禁用Worker模式，优先使用同步处理避免内存问题
        this.useWorkers = false; // 改为默认禁用
        
        // 添加Worker统计
        this.activeWorkers = 0;
        this.maxActiveWorkers = 0;
        this.workerFailures = 0;
        
        // 添加内存监控
        this.memoryThreshold = 0.7; // 70%内存使用率时停止Worker
        this.processedFiles = 0;
        this.maxFilesPerBatch = 100; // 每批最多处理100个文件
    }

    log(message) {
        console.log(`[Dispatcher] ${message}`);
    }

    error(message) {
        console.error(`[Dispatcher] ${message}`);
    }

    warn(message) {
        console.warn(`[Dispatcher] ${message}`);
    }

    async processFiles(fileList, parserSelector) {
        this.log('fileList:', fileList);
        const chunks = [];

        for (const file of fileList) {
            if (!file || !file.path) {
                this.warn('Invalid file entry:', file);
                continue;
            }
            try {
                const fullPath = path.join(this.workspacePath, file.path);
                const content = await fs.readFile(fullPath, 'utf8');
                const parser = parserSelector.selectParser(file.path);
                // 修复：使用正确的参数顺序 parse(filePath, content)
                const fileChunks = await parser.parse(fullPath, content);
                
                // 为同步方法手动设置chunk属性（因为没有worker处理）
                fileChunks.forEach((chunk, index) => {
                    // 生成唯一的chunk ID，包含路径哈希确保唯一性
                    const crypto = __webpack_require__(8);
                    const pathHash = crypto.createHash('md5').update(file.path).digest('hex').substring(0, 8);
                    const timestamp = Date.now().toString(36);
                    chunk.id = `${path.basename(file.path, path.extname(file.path))}_${pathHash}_${chunk.startLine || index}-${chunk.endLine || index}_${timestamp}_${index}`;
                    chunk.filePath = file.path;
                    
                    // 注册 chunk 到 ProgressTracker
                    if (this.progressTracker) {
                        this.progressTracker.registerChunk(chunk.id, {
                            filePath: chunk.filePath,
                            startLine: chunk.startLine,
                            endLine: chunk.endLine,
                            content: chunk.content,
                            parser: chunk.parser,
                            type: chunk.type,
                            language: chunk.language
                        });
                    }
                });
                
                chunks.push(...fileChunks);
            } catch (error) {
                this.error(`Error processing file ${file && file.path}:`, error);
            }
        }

        return chunks;
    }

    async processFilesConcurrently(fileList, parserSelector) {
        const chunks = [];
        const validFiles = fileList.filter(file => file && file.path);
        
        if (validFiles.length === 0) {
            this.warn('No valid files to process');
            return chunks;
        }

        // 检查内存使用情况
        const memUsage = this.checkMemoryUsage();
        this.log(`当前内存使用率: ${(memUsage * 100).toFixed(2)}%`);

        // 对于大型项目，分批处理以避免内存问题
        if (validFiles.length > this.maxFilesPerBatch) {
            this.warn(`文件数量过多 (${validFiles.length})，分批处理以避免内存问题`);
            
            const batches = [];
            for (let i = 0; i < validFiles.length; i += this.maxFilesPerBatch) {
                batches.push(validFiles.slice(i, i + this.maxFilesPerBatch));
            }
            
            for (let i = 0; i < batches.length; i++) {
                this.log(`处理批次 ${i + 1}/${batches.length} (${batches[i].length} 个文件)`);
                
                const batchChunks = await this.processFiles(batches[i], parserSelector);
                chunks.push(...batchChunks);
                
                // 批次间检查内存并强制垃圾回收
                this.checkMemoryUsage();
                if (global.gc) {
                    global.gc();
                }
                
                // 批次间小延迟，释放资源
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            return chunks;
        }

        // 如果worker不可用或文件数量适中，使用同步处理
        if (!this.useWorkers) {
            this.log('使用同步处理模式 (Worker已禁用或不可用)');
            return await this.processFiles(validFiles, parserSelector);
        }

        try {
            // 使用批处理方式控制并发数量
            const batchSize = this.maxWorkers;
            const batches = [];
            
            for (let i = 0; i < validFiles.length; i += batchSize) {
                batches.push(validFiles.slice(i, i + batchSize));
            }

            // 按批次处理文件
            for (const batch of batches) {
                const batchPromises = batch.map(file => this._createWorkerPromise(file, chunks, parserSelector));
                
                // 等待当前批次的所有 worker 完成
                const results = await Promise.allSettled(batchPromises);
                
                // 记录任何失败的任务
                results.forEach((result, index) => {
                    if (result.status === 'rejected') {
                        this.error(`Batch processing failed for file ${batch[index].path}:`, result.reason);
                    }
                });
                
                // 批次间检查内存
                this.checkMemoryUsage();
            }
        } catch (error) {
            this.error('Worker processing failed, switching to synchronous mode:', error);
            this.useWorkers = false;
            return await this.processFiles(validFiles, parserSelector);
        }

        return chunks;
    }

    /**
     * 创建Worker Promise，负责协调worker的执行
     * 注意：chunk的id和filePath属性由worker.js负责设置，此方法只负责ProgressTracker注册
     */
    _createWorkerPromise(file, chunks, parserSelector) {
        return new Promise((resolve, reject) => {
            let worker;
            
            // 检查Worker失败率，如果太高就直接使用同步处理
            if (this.workerFailures > 10) {
                this.warn(`Worker失败次数过多(${this.workerFailures})，切换到同步处理模式`);
                this.useWorkers = false;
                this._processSingleFileSync(file, chunks, parserSelector)
                    .then(resolve)
                    .catch(reject);
                return;
            }
            
            try {
                worker = this._createWorker(file);
                this.activeWorkers++;
                this.maxActiveWorkers = Math.max(this.maxActiveWorkers, this.activeWorkers);
            } catch (error) {
                this.workerFailures++;
                this.error(`Failed to create worker for file ${file.path} (失败次数: ${this.workerFailures}):`, error);
                // 回退到同步处理单个文件
                this._processSingleFileSync(file, chunks, parserSelector)
                    .then(resolve)
                    .catch(reject);
                return;
            }

            // 设置超时处理（防止worker卡死）
            const timeout = setTimeout(() => {
                if (worker) {
                    worker.terminate();
                }
                reject(new Error(`Worker timeout for file ${file.path}`));
            }, 30000); // 30秒超时

            worker.on('message', (result) => {
                clearTimeout(timeout);
                this.activeWorkers--;
                
                if (result.chunks) {
                    // chunk的id和filePath已经在worker中设置，这里只需要进行ProgressTracker注册
                    result.chunks.forEach(chunk => {
                        // 验证worker是否正确设置了必要属性
                        if (!chunk.id || !chunk.filePath) {
                            this.warn(`Missing chunk properties from worker for file ${file.path}:`, {
                                hasId: !!chunk.id,
                                hasFilePath: !!chunk.filePath
                            });
                        }
                        
                        // 注册 chunk 到 ProgressTracker
                        if (this.progressTracker && chunk.id) {
                            this.progressTracker.registerChunk(chunk.id, {
                                filePath: chunk.filePath,
                                startLine: chunk.startLine,
                                endLine: chunk.endLine,
                                content: chunk.content,
                                parser: chunk.parser,
                                type: chunk.type,
                                language: chunk.language
                            });
                        }
                    });
                    chunks.push(...result.chunks);
                }
                resolve(result);
            });

            worker.on('error', (error) => {
                clearTimeout(timeout);
                this.activeWorkers--;
                this.workerFailures++;
                this.error(`Worker error for file ${file.path} (失败次数: ${this.workerFailures}):`, error);
                
                // 回退到同步处理
                this._processSingleFileSync(file, chunks, parserSelector)
                    .then(() => resolve({ chunks: [] }))
                    .catch(reject);
            });

            worker.on('exit', (code) => {
                clearTimeout(timeout);
                this.activeWorkers--;
                if (code !== 0) {
                    this.workerFailures++;
                    const error = new Error(`Worker stopped with exit code ${code}`);
                    this.error(`Worker exit error for file ${file.path} (失败次数: ${this.workerFailures}):`, error);
                    
                    // 回退到同步处理
                    this._processSingleFileSync(file, chunks, parserSelector)
                        .then(() => resolve({ chunks: [] }))
                        .catch(reject);
                } else {
                    resolve();
                }
            });
        });
    }

    /**
     * 同步处理单个文件（回退方案）
     */
    async _processSingleFileSync(file, chunks, parserSelector) {
        try {
            const fullPath = path.join(this.workspacePath, file.path);
            const content = await fs.readFile(fullPath, 'utf8');
            const parser = parserSelector.selectParser(file.path);
            const fileChunks = await parser.parse(fullPath, content);
            
            // 设置chunk属性
            fileChunks.forEach((chunk, index) => {
                const crypto = __webpack_require__(8);
                const pathHash = crypto.createHash('md5').update(file.path).digest('hex').substring(0, 8);
                const timestamp = Date.now().toString(36);
                chunk.id = `${path.basename(file.path, path.extname(file.path))}_${pathHash}_${chunk.startLine || index}-${chunk.endLine || index}_${timestamp}_${index}`;
                chunk.filePath = file.path;
                
                // 注册 chunk 到 ProgressTracker
                if (this.progressTracker) {
                    this.progressTracker.registerChunk(chunk.id, {
                        filePath: chunk.filePath,
                        startLine: chunk.startLine,
                        endLine: chunk.endLine,
                        content: chunk.content,
                        parser: chunk.parser,
                        type: chunk.type,
                        language: chunk.language
                    });
                }
            });
            
            chunks.push(...fileChunks);
            this.log(`Processed file synchronously: ${file.path} (${fileChunks.length} chunks)`);
        } catch (error) {
            this.error(`Error in sync processing for file ${file.path}:`, error);
        }
    }

    _createWorker(file) {
        // 尝试多个可能的worker路径
        const possiblePaths = [
            path.join(__dirname, 'worker.js'),
            path.resolve(__dirname, 'worker.js'),
            path.join(process.cwd(), 'code-chunker', 'src', 'worker.js'),
            path.join(process.cwd(), 'src', 'worker.js')
        ];

        let workerPath = null;
        for (const p of possiblePaths) {
            if (fs.existsSync(p)) {
                workerPath = p;
                break;
            }
        }

        if (!workerPath) {
            throw new Error(`Worker script not found at any of these paths: ${possiblePaths.join(', ')}`);
        }

        const worker = new Worker(workerPath, {
            workerData: {
                file,
                workspacePath: this.workspacePath,
                config: this.config
            }
        });

        return worker;
    }

    /**
     * 获取Worker统计信息
     */
    getWorkerStats() {
        return {
            maxWorkers: this.maxWorkers,
            activeWorkers: this.activeWorkers,
            maxActiveWorkers: this.maxActiveWorkers,
            workerFailures: this.workerFailures,
            useWorkers: this.useWorkers
        };
    }

    /**
     * 重置Worker统计
     */
    resetWorkerStats() {
        this.activeWorkers = 0;
        this.maxActiveWorkers = 0;
        this.workerFailures = 0;
        this.useWorkers = false;
    }

    // 检查内存使用情况
    checkMemoryUsage() {
        const memUsage = process.memoryUsage();
        const totalMem = (__webpack_require__(146).totalmem)();
        const usedPercentage = memUsage.heapUsed / totalMem;
        
        if (usedPercentage > this.memoryThreshold) {
            this.warn(`高内存使用率检测到: ${(usedPercentage * 100).toFixed(2)}%，切换到同步模式`);
            this.useWorkers = false;
            
            // 强制垃圾回收（如果可用）
            if (global.gc) {
                global.gc();
            }
        }
        
        return usedPercentage;
    }
}

module.exports = Dispatcher; 

/***/ }),
/* 145 */
/***/ ((module) => {

"use strict";
module.exports = require("worker_threads");

/***/ }),
/* 146 */
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),
/* 147 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const axios = __webpack_require__(148);
const ProgressTracker = __webpack_require__(220);
const VectorManager = __webpack_require__(221);
const EmbeddingClient = __webpack_require__(231);
const config = __webpack_require__(123);

class Sender {
    constructor(senderConfig, progressTracker, externalVectorManager = null, performanceAnalyzer = null) {
        // 支持传入配置对象或使用全局配置
        this.config = senderConfig || config.getAll();
        this.progressTracker = progressTracker;
        this.performanceAnalyzer = performanceAnalyzer;
        
        // 确保必要的API锁定配置存在
        this.config.userId = this.config.userId || "user123";
        this.config.deviceId = this.config.deviceId || "device123";
        this.config.workspacePath = this.config.workspacePath || process.cwd();
        
        // 初始化嵌入客户端
        this.embeddingClient = new EmbeddingClient({
            apiEndpoint: this.config.apiEndpoint,
            token: this.config.token,
            timeout: this.config.timeout,
            batchSize: this.config.batchSize,
            maxRetries: this.config.maxRetries,
            retryDelay: this.config.retryDelay
        });
        
        // 传递性能分析器给EmbeddingClient
        if (this.performanceAnalyzer) {
            this.embeddingClient.performanceAnalyzer = this.performanceAnalyzer;
        }
        
        this.stats = {
            totalChunks: 0,
            successfulChunks: 0,
            failedChunks: 0,
            totalEmbeddings: 0,
            processingTime: 0
        };
        
        this.batchSize = this.config.batchSize || 10;
        this.retryAttempts = this.config.retryAttempts || 3;
        this.retryDelay = this.config.retryDelay || 1000;
        this.asyncTimeout = this.config.asyncTimeout || 60000; // 异步处理超时时间
        this.pendingAsyncResults = new Map(); // 跟踪待处理的异步结果
        
        // API锁定机制管理
        this.lockedTasks = new Map(); // 跟踪被锁定的任务: key -> timestamp
        this.lockDuration = 30000; // 30秒锁定时间
        
        // 启动定期清理过期锁定
        this.lockCleanupInterval = setInterval(() => {
            this._cleanupExpiredLocks();
        }, 10000); // 每10秒清理一次
        
        // 使用外部传入的VectorManager，避免重复初始化
        if (externalVectorManager) {
            this.vectorManager = externalVectorManager;
        } else if (this.config.vectorManager?.enabled) {
            this.vectorManager = new VectorManager(this.config.vectorManager);
            this.vectorManager.initialize().catch(error => {
                console.error('Failed to initialize VectorManager:', error);
            });
        }
    }

    async _sendBatch(batch) {
        try {
            // 为每个chunk预设置状态为processing
            if (this.progressTracker) {
                for (const chunk of batch) {
                    this.progressTracker.updateChunkStatus(chunk.id, 'processing', {
                        batchSize: batch.length,
                        startTime: new Date().toISOString()
                    });
                }
            }

            // 准备代码块数据 - 不过滤空内容，让问题暴露出来
            const codeChunks = batch.map(chunk => ({
                chunkId: chunk.id,
                filePath: chunk.filePath,
                language: chunk.language || 'unknown',
                startLine: chunk.startLine,
                endLine: chunk.endLine,
                content: chunk.content,
                parser: chunk.parser || 'tree_sitter'
            }));

            // 记录空内容代码块但不过滤，让问题暴露
            codeChunks.forEach((chunk, index) => {
                if (!chunk.content || chunk.content.trim().length === 0) {
                    console.warn(`🚨 发现空内容代码块 ${index + 1}: ${chunk.chunkId} (行号: ${chunk.startLine}-${chunk.endLine})`);
                    console.warn(`   文件路径: ${chunk.filePath}`);
                    console.warn(`   内容长度: ${chunk.content ? chunk.content.length : 'null/undefined'}`);
                }
            });

           

            // 使用新的EmbeddingClient发送请求
            const embeddingOptions = {
                uniqueId: `${this.config.userId}-${this.config.deviceId}-${Date.now()}`,
                parserVersion: '1.0.0',
                processingMode: 'sync', // 优先使用同步模式
                autoPolling: true,
                onProgress: (progress) => {
                    // 处理进度更新
                }
            };
            
            // 记录网络请求开始时间
            const networkStartTime = Date.now();
            const result = await this.embeddingClient.embedCodeBlocks(codeChunks, embeddingOptions);
            const networkEndTime = Date.now();
            
            // 记录网络请求性能
            if (this.performanceAnalyzer) {
                this.performanceAnalyzer.recordNetworkRequest('embedding', networkEndTime - networkStartTime, true);
                this.performanceAnalyzer.updatePeakMemory();
            }
            
            // 处理结果并更新状态
            const processedResults = await this._processEmbeddingResults(result, batch);
            await this._saveDataToLocal(processedResults, batch);
            return {
                status: 'completed',
                results: processedResults,
                batchId: this._generateBatchId(batch),
                processingMode: result.processingMode,
                totalProcessingTimeMs: result.totalProcessingTimeMs
            };

        } catch (error) {
            console.error('❌ 批次发送失败:', error.message);
            console.error('❌ 错误详情:', {
                name: error.name,
                message: error.message,
                stack: error.stack,
                embeddingError: error.embeddingError
            });

            // 更新所有chunk状态为失败
            if (this.progressTracker) {
                for (const chunk of batch) {
                    this.progressTracker.updateChunkStatus(chunk.id, 'failed', {
                        error: error.message,
                        errorType: error.embeddingError?.type || 'ProcessingError',
                        timestamp: new Date().toISOString()
                    });
                }
            }

            throw error;
        }
    }

    async _saveDataToLocal(codeChunks, originalBatch) {
        try {
            // 参数验证
            if (!codeChunks || !Array.isArray(codeChunks)) {
                console.warn('Invalid codeChunks parameter for _saveDataToLocal:', codeChunks);
                codeChunks = []; // 使用空数组作为默认值
            }
            
            if (!originalBatch || !Array.isArray(originalBatch)) {
                console.warn('Invalid originalBatch parameter for _saveDataToLocal:', originalBatch);
                originalBatch = []; // 使用空数组作为默认值
            }
            
            const fs = (__webpack_require__(5).promises);
            const path = __webpack_require__(4);
            
            // 创建本地数据目录
            const dataDir = path.join(process.cwd(), 'local_data', 'send_logs');
            await fs.mkdir(dataDir, { recursive: true });
            
            // 生成时间戳和批次ID
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const batchId = this._generateBatchId(originalBatch);
            
            // 准备保存的数据
            const saveData = {
                batchInfo: {
                    batchId: batchId,
                    timestamp: new Date().toISOString(),
                    chunkCount: codeChunks.length,
                    userId: this.config.userId || 'unknown',
                    deviceId: this.config.deviceId || 'unknown'
                },
                embeddingOptions: {
                    uniqueId: `${this.config.userId || 'unknown'}-${this.config.deviceId || 'unknown'}-${Date.now()}`,
                    parserVersion: '1.0.0',
                    processingMode: 'sync'
                },
                codeChunks: codeChunks,
                originalChunkData: originalBatch.map(chunk => ({
                    id: chunk?.id || 'unknown',
                    filePath: chunk?.filePath || 'unknown',
                    fileName: chunk?.fileName || null,
                    type: chunk?.type || 'unknown',
                    contentPreview: chunk?.content ? chunk.content.substring(0, 200) + '...' : 'No content'
                }))
            };
            
            // 保存完整数据到JSON文件
            const fileName = `batch_${batchId}_${timestamp}.json`;
            const filePath = path.join(dataDir, fileName);
            
            await fs.writeFile(filePath, JSON.stringify(saveData, null, 2), 'utf8');
            
            // 同时保存一份简化的摘要信息
            const summaryData = {
                batchId: batchId,
                timestamp: new Date().toISOString(),
                chunkCount: codeChunks.length,
                files: [...new Set(codeChunks.map(chunk => chunk?.filePath || 'unknown').filter(path => path !== 'unknown'))],
                languages: [...new Set(codeChunks.map(chunk => chunk?.language || 'unknown').filter(lang => lang !== 'unknown'))],
                totalLines: codeChunks.reduce((sum, chunk) => {
                    const startLine = chunk?.startLine || 0;
                    const endLine = chunk?.endLine || 0;
                    return sum + (endLine > startLine ? endLine - startLine + 1 : 0);
                }, 0)
            };
            
            const summaryFileName = `summary_${batchId}_${timestamp}.json`;
            const summaryFilePath = path.join(dataDir, summaryFileName);
            await fs.writeFile(summaryFilePath, JSON.stringify(summaryData, null, 2), 'utf8');
            
        } catch (error) {
            console.warn('保存本地数据失败:', error.message);
            console.warn('错误详情:', error.stack);
            // 不抛出错误，允许继续处理
        }
    }

    async _processEmbeddingResults(embeddingResult, originalBatch) {
        // 参数验证
        if (!embeddingResult || !embeddingResult.results || !Array.isArray(embeddingResult.results)) {
            console.warn('Invalid embedding result format:', embeddingResult);
            return []; // 返回空数组避免后续错误
        }
        
        const processedResults = []; // 收集处理结果
        
        // 处理每个嵌入结果
        for (const result of embeddingResult.results) {
            try {
                
                if (result.status === 'success' && (result.vector || result.compressedVector)) {
                    // 存储向量到VectorManager (支持压缩向量)
                    const stored = await this._storeEmbeddingVector(result, originalBatch);
                    
                    // 构建处理结果，支持压缩向量格式
                    const processedResult = {
                        chunkId: result.chunkId,
                        status: 'success',
                        vector: result.vector,
                        compressedVector: result.compressedVector,
                        isCompressed: result.isCompressed || false,
                        vectorDimension: result.vectorDimension || (result.vector ? result.vector.length : 0),
                        stored: stored,
                        filePath: result.filePath || 'unknown',
                        startLine: result.startLine || 0,
                        endLine: result.endLine || 0,
                        language: result.language || 'unknown',
                        processingMode: 'embedding_success',
                        modelVersion: result.modelVersion
                    };
                    
                    processedResults.push(processedResult);
                    
                    if (stored) {
                        // 更新进度：成功
                        if (this.progressTracker) {
                            this.progressTracker.updateChunkStatus(result.chunkId, 'completed', {
                                vectorStored: true,
                                vectorDimension: result.vectorDimension || (result.vector ? result.vector.length : 0),
                                isCompressed: result.isCompressed || false,
                                processingMode: 'embedding_success'
                            });
                        }
                    } else {
                        // 存储失败（可能因为VectorManager关闭），但不算作错误
                        console.warn(`Vector storage failed for chunk ${result.chunkId}, marking as completed anyway`);
                        if (this.progressTracker) {
                            this.progressTracker.updateChunkStatus(result.chunkId, 'completed', {
                                vectorStored: false,
                                vectorDimension: result.vectorDimension || (result.vector ? result.vector.length : 0),
                                isCompressed: result.isCompressed || false,
                                processingMode: 'embedding_success_storage_skipped',
                                warning: 'Vector storage skipped (VectorManager unavailable)'
                            });
                        }
                    }
                } else {
                    // 嵌入失败
                    console.warn(`嵌入生成失败: ${result.chunkId} - ${result.error || 'Unknown error'}`);
                    
                    // 构建失败结果
                    const failedResult = {
                        chunkId: result.chunkId,
                        status: 'failed',
                        error: result.error || 'Embedding generation failed',
                        filePath: result.filePath || 'unknown',
                        startLine: result.startLine || 0,
                        endLine: result.endLine || 0,
                        language: result.language || 'unknown',
                        processingMode: 'embedding_failure'
                    };
                    
                    processedResults.push(failedResult);
                    
                    if (this.progressTracker) {
                        this.progressTracker.updateChunkStatus(result.chunkId, 'failed', {
                            error: result.error || 'Embedding generation failed',
                            processingMode: 'embedding_failure'
                        });
                    }
                }
            } catch (error) {
                console.error(`处理代码块 ${result.status} ${result.chunkId} ${result.startLine || 'unknown'}-${result.endLine || 'unknown'} ${result.chunkId.substring(0, 8)} ${result.vectorDimension || 0} 结果时出错:`, error);
                
                // 构建错误结果
                const errorResult = {
                    chunkId: result.chunkId || 'unknown',
                    status: 'error',
                    error: error.message,
                    filePath: 'unknown',
                    startLine: 0,
                    endLine: 0,
                    language: 'unknown',
                    processingMode: 'embedding_processing_error'
                };
                
                processedResults.push(errorResult);
                
                // 更新进度：处理错误
                if (this.progressTracker) {
                    this.progressTracker.updateChunkStatus(result.chunkId, 'failed', {
                        error: error.message,
                        processingMode: 'embedding_processing_error'
                    });
                }
                
                // 不重新抛出错误，继续处理其他结果
            }
        }
        

        return processedResults; // 返回处理结果数组
    }

    async _setupAsyncResultHandling(responseData, originalBatch) {
        const requestId = responseData.requestId;
        const estimatedTime = responseData.estimatedProcessingTimeMs || 30000;
        
        if (!requestId) {
            throw new Error('Missing requestId in async response');
        }

        // 为批次中的每个chunk设置异步等待状态
        if (this.progressTracker) {
            for (const chunk of originalBatch) {
                this.progressTracker.updateChunkStatus(chunk.id, 'async_pending', {
                    requestId: requestId,
                    estimatedTime: estimatedTime,
                    submittedAt: new Date().toISOString()
                });
            }
        }

        // 存储异步请求信息
        this.pendingAsyncResults.set(requestId, {
            batch: originalBatch,
            submittedAt: Date.now(),
            estimatedTime: estimatedTime,
            callbackUrl: responseData.callbackUrl
        });

        // 启动轮询或设置回调
        if (responseData.callbackUrl) {
            // 如果有回调URL，可以设置webhook处理
    
        } else {
            // 启动轮询检查结果
            this._startPollingForResult(requestId, estimatedTime);
        }

        return {
            requestId: requestId,
            status: 'pending',
            estimatedTime: estimatedTime,
            chunkCount: originalBatch.length
        };
    }

    async _startPollingForResult(requestId, estimatedTime) {
        // 等待估计时间的80%后开始轮询
        const initialDelay = estimatedTime * 0.8;
        setTimeout(async () => {
            await this._pollAsyncResult(requestId);
        }, initialDelay);
    }

    async _pollAsyncResult(requestId, attempt = 1) {
        const maxPollingAttempts = 10;
        const pollingInterval = 5000; // 5秒间隔

        try {
            const response = await axios.get(`${this.config.endpoint}/results/${requestId}`, {
                headers: {
                    'Authorization': `Bearer ${this.config.token}`
                },
                timeout: 15000
            });

            if (response.status === 200 && response.data.status === 'completed') {
                // 异步处理完成
                const pendingInfo = this.pendingAsyncResults.get(requestId);
                if (pendingInfo) {
                    await this._processSyncEmbeddingResults(response.data, pendingInfo.batch);
                    this.pendingAsyncResults.delete(requestId);
        
                }
            } else if (response.status === 200 && response.data.status === 'processing') {
                // 仍在处理中，继续轮询
                if (attempt < maxPollingAttempts) {
                    setTimeout(() => {
                        this._pollAsyncResult(requestId, attempt + 1);
                    }, pollingInterval);
                } else {
                    console.error(`Polling timeout for requestId: ${requestId}`);
                    this._handleAsyncTimeout(requestId);
                }
            } else {
                console.error(`Async processing failed for requestId: ${requestId}`, response.data);
                this._handleAsyncFailure(requestId, response.data.error);
            }
        } catch (error) {
            console.error(`Error polling async result for ${requestId}:`, error);
            if (attempt < maxPollingAttempts) {
                setTimeout(() => {
                    this._pollAsyncResult(requestId, attempt + 1);
                }, pollingInterval);
            } else {
                this._handleAsyncTimeout(requestId);
            }
        }
    }

    async _storeEmbeddingVector(result, originalBatch) {
        const maxRetries = 2; // 最多重试2次
        let lastError = null;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                // 获取对应的原始chunk信息
                const originalChunk = originalBatch.find(chunk => chunk.id === result.chunkId);
                if (!originalChunk) {
                    console.warn(`Original chunk not found for ${result.chunkId}`);
                    return false;
                }

                // 生成锁定键：基于snippet_id + user_id + device_id
                const lockKey = `${result.chunkId}_${this.config.userId}_${this.config.deviceId}`;
                
                // 检查是否在锁定期内
                if (this.lockedTasks.has(lockKey)) {
                    const lockTime = this.lockedTasks.get(lockKey);
                    const timeElapsed = Date.now() - lockTime;
                    
                    if (timeElapsed < this.lockDuration) {
                        const waitTime = this.lockDuration - timeElapsed;
        
                        await new Promise(resolve => setTimeout(resolve, waitTime));
                        
                        // 清除锁定记录
                        this.lockedTasks.delete(lockKey);
                    } else {
                        // 锁定已过期，清除记录
                        this.lockedTasks.delete(lockKey);
                    }
                }

                // 直接使用EmbeddingClient的upsert API接口
                try {
                    // 准备文档数据，支持压缩向量格式
                    const documents = [{
                        snippet_id: result.chunkId,
                        user_id: this.config.userId,
                        device_id: this.config.deviceId,
                        workspace_path: this.config.workspacePath,
                        file_path: originalChunk.filePath || 'unknown',
                        start_line: originalChunk.startLine || 1,
                        end_line: originalChunk.endLine || 1,
                        code: originalChunk.content || '',
                        vector: result.isCompressed ? null : result.vector,
                        compressedVector: result.isCompressed ? result.compressedVector : null,
                        isCompressed: result.isCompressed || false,
                        vector_model: result.modelVersion || "CoCoSoDa-v1.0",
                        compressionFormat: 'base64',
                        originalDimensions: 768,
                    }];

                    // 生成请求ID
                    const requestId = `req-store-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                    
                    // 准备upsert请求数据
                    const upsertData = {
                        requestId: requestId,
                        database: this.config.database || 'codebase_db',
                        collection: this.config.collection || 'code_vectors1',  // 使用配置中的collection名称，默认为code_vectors1
                        documents: documents,
                        buildIndex: true
                    };

                    // ===== 详细请求日志 =====
                    console.log(`\n🔍 ===== UPSERT API 请求详情 =====`);
                    console.log(`📡 URL: POST /api/v1/codebase/upsert`);
                    console.log(`🆔 Request ID: ${requestId}`);
                    console.log(`📦 Chunk ID: ${result.chunkId}`);
                    console.log(`📊 请求体大小: ${JSON.stringify(upsertData).length} 字符`);
                    console.log(`📋 完整请求体:`, JSON.stringify(upsertData, null, 2));
                    
                    // 分析向量数据
                    const doc = documents[0];
                    if (doc.isCompressed) {
                        console.log(`🗜️ 压缩向量信息:`);
                        console.log(`   - 压缩格式: ${doc.compressionFormat}`);
                        console.log(`   - 原始维度: ${doc.originalDimensions}`);
                        console.log(`   - 压缩数据长度: ${doc.compressedVector ? doc.compressedVector.length : 'null'}`);
                    } else {
                        console.log(`🎯 标准向量信息:`);
                        console.log(`   - 向量维度: ${doc.vector ? doc.vector.length : 'null'}`);
                        console.log(`   - 向量类型: ${Array.isArray(doc.vector) ? 'Array' : typeof doc.vector}`);
                    }
                    
                    console.log(`📄 文档信息:`);
                    console.log(`   - 文件路径: ${doc.file_path}`);
                    console.log(`   - 行号范围: ${doc.start_line}-${doc.end_line}`);
                    console.log(`   - 代码长度: ${doc.code.length} 字符`);
                    console.log(`   - 向量模型: ${doc.vector_model}`);
                    console.log(`🔍 ================================\n`);
    
                    // 直接调用API接口
                    const response = await this.embeddingClient._makeRequest('POST', '/api/v1/codebase/upsert', upsertData);
                    
                    // ===== 详细响应日志 =====
                    console.log(`\n📥 ===== UPSERT API 响应详情 =====`);
                    console.log(`🆔 Request ID: ${requestId}`);
                    console.log(`📦 Chunk ID: ${result.chunkId}`);
                    console.log(`📊 响应体大小: ${JSON.stringify(response).length} 字符`);
                    console.log(`📋 完整响应体:`, JSON.stringify(response, null, 2));
                    
                    // 分析响应状态
                    const status = response.status || response['status:'];
                    const hasStatusField = 'status' in response;
                    const hasStatusColonField = 'status:' in response;
                    
                    console.log(`📊 状态字段分析:`);
                    console.log(`   - 'status' 字段存在: ${hasStatusField}`);
                    console.log(`   - 'status:' 字段存在: ${hasStatusColonField}`);
                    console.log(`   - 最终状态值: "${status}"`);
                    console.log(`   - 状态类型: ${typeof status}`);
                    
                    if (response.error) {
                        console.log(`❌ 错误信息: ${response.error}`);
                    }
                    
                    console.log(`📥 ================================\n`);
                    
                    // 兼容后端返回的字段名错误：支持 "status:" 和 "status"
                    
                    if (status === 'success') {
                        console.log(`✅ API存储成功 - Chunk: ${result.chunkId}`);
                        // 成功时清除可能存在的锁定记录
                        this.lockedTasks.delete(lockKey);
                        return true;
                    } else {
                        const errorMsg = response.error || 'Unknown API error';
                        // 增强错误日志，显示完整的响应信息
                        console.warn(`❌ API storage failed for chunk ${result.chunkId} (attempt ${attempt}/${maxRetries}): ${errorMsg}`);
                        console.warn(`📋 完整错误响应:`, JSON.stringify(response, null, 2));
                        
                        // 如果是锁定相关的错误，记录锁定时间并继续重试
                        if (errorMsg.includes('任务正在执行') || 
                            errorMsg.includes('锁定') ||
                            errorMsg.includes('locked') ||
                            errorMsg.includes('busy')) {
                            
                            this.lockedTasks.set(lockKey, Date.now());
                            lastError = new Error(`API locked: ${errorMsg}`);
                            
                            // 如果不是最后一次尝试，继续重试
                            if (attempt < maxRetries) {
                                continue;
                            }
                        } else {
                            // 非锁定错误，不重试
                            lastError = new Error(`API error: ${errorMsg}`);
                            break;
                        }
                    }
                    
                } catch (apiError) {
                    // ===== 详细异常日志 =====
                    console.error(`\n💥 ===== UPSERT API 异常详情 =====`);
                    console.error(`🆔 Request ID: ${requestId}`);
                    console.error(`📦 Chunk ID: ${result.chunkId}`);
                    console.error(`🔢 尝试次数: ${attempt}/${maxRetries}`);
                    console.error(`❌ 异常类型: ${apiError.constructor.name}`);
                    console.error(`📝 异常消息: ${apiError.message}`);
                    console.error(`📚 异常堆栈:`, apiError.stack);
                    
                    // 如果有响应相关的信息
                    if (apiError.response) {
                        console.error(`📡 HTTP状态码: ${apiError.response.status}`);
                        console.error(`📋 响应头:`, apiError.response.headers);
                        console.error(`📄 响应体:`, apiError.response.data);
                    }
                    
                    // 如果有请求相关的信息
                    if (apiError.request) {
                        console.error(`📤 请求配置:`, {
                            method: apiError.request.method,
                            url: apiError.request.url,
                            headers: apiError.request.headers,
                            timeout: apiError.request.timeout
                        });
                    }
                    
                    console.error(`💥 ================================\n`);
                    
                    console.error(`❌ API storage failed for chunk ${result.chunkId} (attempt ${attempt}/${maxRetries}): ${apiError.message}`);
                    lastError = apiError;
                    
                    // 网络错误也可能导致锁定，记录锁定时间
                    if (apiError.message.includes('timeout') || 
                        apiError.message.includes('ECONNRESET') ||
                        apiError.message.includes('ETIMEDOUT')) {
                        
                        this.lockedTasks.set(lockKey, Date.now());
                        
                        // 网络错误时继续重试
                        if (attempt < maxRetries) {
                            continue;
                        }
                    } else {
                        // 非网络错误，不重试
                        break;
                    }
                }

            } catch (error) {
                console.error(`Failed to store vector for chunk ${result.chunkId} (attempt ${attempt}/${maxRetries}):`, error);
                lastError = error;
                break; // 致命错误，不重试
            }
        }
        
        // 所有重试都失败了
        console.error(`Failed to store vector for chunk ${result.chunkId} after ${maxRetries} attempts. Last error:`, lastError?.message);
        return false;
    }

    async _handleBatchAsPartialFailure(batch, reason) {
        const results = [];
        for (const chunk of batch) {
            if (this.progressTracker) {
                this.progressTracker.updateChunkStatus(chunk.id, 'failed', {
                    error: reason,
                    processingMode: 'batch_failure'
                });
            }
            results.push({
                chunkId: chunk.id,
                status: 'failed',
                error: reason
            });
        }
        return results;
    }

    async _handleAsyncTimeout(requestId) {
        const pendingInfo = this.pendingAsyncResults.get(requestId);
        if (pendingInfo && this.progressTracker) {
            for (const chunk of pendingInfo.batch) {
                this.progressTracker.updateChunkStatus(chunk.id, 'timeout', {
                    requestId: requestId,
                    message: 'Async processing timeout'
                });
            }
        }
        this.pendingAsyncResults.delete(requestId);
    }

    async _handleAsyncFailure(requestId, error) {
        const pendingInfo = this.pendingAsyncResults.get(requestId);
        if (pendingInfo && this.progressTracker) {
            for (const chunk of pendingInfo.batch) {
                this.progressTracker.updateChunkStatus(chunk.id, 'failed', {
                    requestId: requestId,
                    error: error,
                    processingMode: 'async_failure'
                });
            }
        }
        this.pendingAsyncResults.delete(requestId);
    }

    _generateBatchId(batch) {
        const crypto = __webpack_require__(8);
        
        // 参数验证
        if (!batch || !Array.isArray(batch) || batch.length === 0) {
            console.warn('Invalid batch parameter for _generateBatchId:', batch);
            // 为空批次生成默认ID
            return crypto.createHash('md5').update(`empty_batch_${Date.now()}`).digest('hex').substring(0, 8);
        }
        
        try {
            const chunkIds = batch.map(chunk => chunk?.id || 'unknown').sort().join('|');
            return crypto.createHash('md5').update(chunkIds).digest('hex').substring(0, 8);
        } catch (error) {
            console.warn('Error generating batch ID:', error.message);
            // 生成后备ID
            return crypto.createHash('md5').update(`fallback_batch_${Date.now()}`).digest('hex').substring(0, 8);
        }
    }

    _generateRequestId() {
        const crypto = __webpack_require__(8);
        return crypto.randomUUID();
    }

    _calculateVectorNorm(vector) {
        return Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));
    }

    _extractFileName(filePath) {
        const path = __webpack_require__(4);
        return path.basename(filePath);
    }

    async sendChunks(chunks, merkleRootHash) {
        // 注意：merkleRootHash参数已不再使用，保留仅为向后兼容
        
        // 开始计时：Sender初始化和准备
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.startModuleTimer('sender', 'initTime');
            this.performanceAnalyzer.recordMemoryUsage('sender_start');
        }
        
        // 检查是否为测试模式，跳过网络请求
        if (process.env.NODE_ENV === 'development' && this.config.testMode !== false) {
            
            // 更新进度跟踪器状态
            if (this.progressTracker) {
                chunks.forEach(chunk => {
                    this.progressTracker.updateChunkStatus(chunk.id, 'completed', {
                        testMode: true,
                        skippedNetworkRequest: true,
                        timestamp: new Date().toISOString()
                    });
                });
            }
            
            return {
                totalBatches: Math.ceil(chunks.length / this.batchSize),
                successful: Math.ceil(chunks.length / this.batchSize),
                failed: 0,
                asyncPending: 0,
                completedImmediately: Math.ceil(chunks.length / this.batchSize),
                testMode: true,
                results: []
            };
        }
        
        // 开始计时：数据准备
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('sender', 'initTime');
            this.performanceAnalyzer.startModuleTimer('sender', 'prepareTime');
        }
        
        const batches = [];
        for (let i = 0; i < chunks.length; i += this.batchSize) {
            batches.push(chunks.slice(i, i + this.batchSize));
        }
        
        // 结束数据准备，开始发送
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('sender', 'prepareTime');
            this.performanceAnalyzer.startModuleTimer('sender', 'sendTime');
        }

        // 并发发送所有批次，但控制并发数
        const maxConcurrentBatches = this.config.maxConcurrentBatches || 3;
        const results = [];
        
        for (let i = 0; i < batches.length; i += maxConcurrentBatches) {
            const currentBatches = batches.slice(i, i + maxConcurrentBatches);
            const batchPromises = currentBatches.map(batch => this._sendBatch(batch));
            const batchResults = await Promise.allSettled(batchPromises);
            results.push(...batchResults);
        }

        // 统计结果
        const successfulBatches = results.filter(r => r.status === 'fulfilled');
        const failedBatches = results.filter(r => r.status === 'rejected');
        const asyncBatches = successfulBatches.filter(r => r.value.status === 'accepted');
        const completedBatches = successfulBatches.filter(r => r.value.status === 'completed');



        if (failedBatches.length > 0) {
            console.warn(`${failedBatches.length} batches failed to send`);
            failedBatches.forEach((failure, index) => {
                console.error(`🔥 Batch ${index} failure:`, failure.reason?.message || failure.reason);
                console.error(`🔥 Batch ${index} detailed error:`, {
                    name: failure.reason?.name,
                    message: failure.reason?.message,
                    stack: failure.reason?.stack,
                    embeddingError: failure.reason?.embeddingError
                });
            });
        }

        // 结束发送计时，开始批处理计时
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('sender', 'sendTime');
            this.performanceAnalyzer.startModuleTimer('sender', 'batchTime');
        }

        // 记录embedding生成完成统计
        if (this.performanceAnalyzer) {
            const totalRequests = batches.length;
            const successRequests = successfulBatches.length;
            const failedRequests = failedBatches.length;
            this.performanceAnalyzer.endEmbeddingGeneration(totalRequests, successRequests, failedRequests);
        }

        // 数据已直接发送到向量数据库，无需额外持久化
        
        // 结束批处理计时
        if (this.performanceAnalyzer) {
            this.performanceAnalyzer.endModuleTimer('sender', 'batchTime');
            this.performanceAnalyzer.recordMemoryUsage('sender_end');
        }

        return {
            totalBatches: batches.length,
            successful: successfulBatches.length,
            failed: failedBatches.length,
            asyncPending: asyncBatches.length,
            completedImmediately: completedBatches.length,
            pendingAsyncRequests: Array.from(this.pendingAsyncResults.keys()),
            results: results
        };
    }

    async getPendingAsyncResults() {
        return Array.from(this.pendingAsyncResults.entries()).map(([requestId, info]) => ({
            requestId,
            chunkCount: info.batch.length,
            submittedAt: new Date(info.submittedAt).toISOString(),
            estimatedTime: info.estimatedTime,
            callbackUrl: info.callbackUrl
        }));
    }

    async shutdown() {
        // 等待所有异步结果完成或超时
        if (this.pendingAsyncResults.size > 0) {
            const timeout = this.asyncTimeout;
            const startTime = Date.now();
            
            while (this.pendingAsyncResults.size > 0 && (Date.now() - startTime) < timeout) {
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            if (this.pendingAsyncResults.size > 0) {
                console.warn(`Shutdown with ${this.pendingAsyncResults.size} pending async results remaining`);
            }
        }

        // 停止锁定清理定时器
        if (this.lockCleanupInterval) {
            clearInterval(this.lockCleanupInterval);
            this.lockCleanupInterval = null;
        }

        if (this.vectorManager) {
            await this.vectorManager.shutdown();
        }
    }

    /**
     * 清理过期的锁定记录
     */
    _cleanupExpiredLocks() {
        const now = Date.now();
        const expiredKeys = [];
        
        for (const [key, timestamp] of this.lockedTasks) {
            if (now - timestamp >= this.lockDuration) {
                expiredKeys.push(key);
            }
        }
        
        expiredKeys.forEach(key => {
            this.lockedTasks.delete(key);
        });
        

    }

    /**
     * 获取当前锁定状态
     */
    getLockStatus() {
        const now = Date.now();
        const activeLocks = [];
        
        for (const [key, timestamp] of this.lockedTasks) {
            const timeElapsed = now - timestamp;
            if (timeElapsed < this.lockDuration) {
                const remainingTime = this.lockDuration - timeElapsed;
                activeLocks.push({
                    key: key,
                    remainingSeconds: Math.round(remainingTime / 1000)
                });
            }
        }
        
        return {
            totalLocks: activeLocks.length,
            locks: activeLocks
        };
    }

    /**
     * 手动清除特定任务的锁定
     */
    clearLock(chunkId) {
        const lockKey = `${chunkId}_${this.config.userId}_${this.config.deviceId}`;
        const wasLocked = this.lockedTasks.has(lockKey);
        this.lockedTasks.delete(lockKey);
        

        
        return wasLocked;
    }
}

module.exports = Sender;

/***/ }),
/* 148 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*! Axios v1.10.0 Copyright (c) 2025 Matt Zabriskie and contributors */


const FormData$1 = __webpack_require__(149);
const crypto = __webpack_require__(8);
const url = __webpack_require__(154);
const proxyFromEnv = __webpack_require__(205);
const http = __webpack_require__(152);
const https = __webpack_require__(153);
const util = __webpack_require__(20);
const followRedirects = __webpack_require__(206);
const zlib = __webpack_require__(218);
const stream = __webpack_require__(18);
const events = __webpack_require__(219);

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const FormData__default = /*#__PURE__*/_interopDefaultLegacy(FormData$1);
const crypto__default = /*#__PURE__*/_interopDefaultLegacy(crypto);
const url__default = /*#__PURE__*/_interopDefaultLegacy(url);
const proxyFromEnv__default = /*#__PURE__*/_interopDefaultLegacy(proxyFromEnv);
const http__default = /*#__PURE__*/_interopDefaultLegacy(http);
const https__default = /*#__PURE__*/_interopDefaultLegacy(https);
const util__default = /*#__PURE__*/_interopDefaultLegacy(util);
const followRedirects__default = /*#__PURE__*/_interopDefaultLegacy(followRedirects);
const zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
const stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);

function bind(fn, thisArg) {
  return function wrap() {
    return fn.apply(thisArg, arguments);
  };
}

// utils is a library of generic helper functions non-specific to axios

const {toString} = Object.prototype;
const {getPrototypeOf} = Object;
const {iterator, toStringTag} = Symbol;

const kindOf = (cache => thing => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(Object.create(null));

const kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type
};

const typeOfTest = type => thing => typeof thing === type;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 *
 * @returns {boolean} True if value is an Array, otherwise false
 */
const {isArray} = Array;

/**
 * Determine if a value is undefined
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if the value is undefined, otherwise false
 */
const isUndefined = typeOfTest('undefined');

/**
 * Determine if a value is a Buffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Buffer, otherwise false
 */
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
    && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
const isArrayBuffer = kindOfTest('ArrayBuffer');


/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  let result;
  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
    result = ArrayBuffer.isView(val);
  } else {
    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a String, otherwise false
 */
const isString = typeOfTest('string');

/**
 * Determine if a value is a Function
 *
 * @param {*} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
const isFunction = typeOfTest('function');

/**
 * Determine if a value is a Number
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Number, otherwise false
 */
const isNumber = typeOfTest('number');

/**
 * Determine if a value is an Object
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an Object, otherwise false
 */
const isObject = (thing) => thing !== null && typeof thing === 'object';

/**
 * Determine if a value is a Boolean
 *
 * @param {*} thing The value to test
 * @returns {boolean} True if value is a Boolean, otherwise false
 */
const isBoolean = thing => thing === true || thing === false;

/**
 * Determine if a value is a plain Object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a plain Object, otherwise false
 */
const isPlainObject = (val) => {
  if (kindOf(val) !== 'object') {
    return false;
  }

  const prototype = getPrototypeOf(val);
  return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
};

/**
 * Determine if a value is a Date
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Date, otherwise false
 */
const isDate = kindOfTest('Date');

/**
 * Determine if a value is a File
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFile = kindOfTest('File');

/**
 * Determine if a value is a Blob
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Blob, otherwise false
 */
const isBlob = kindOfTest('Blob');

/**
 * Determine if a value is a FileList
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a File, otherwise false
 */
const isFileList = kindOfTest('FileList');

/**
 * Determine if a value is a Stream
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a Stream, otherwise false
 */
const isStream = (val) => isObject(val) && isFunction(val.pipe);

/**
 * Determine if a value is a FormData
 *
 * @param {*} thing The value to test
 *
 * @returns {boolean} True if value is an FormData, otherwise false
 */
const isFormData = (thing) => {
  let kind;
  return thing && (
    (typeof FormData === 'function' && thing instanceof FormData) || (
      isFunction(thing.append) && (
        (kind = kindOf(thing)) === 'formdata' ||
        // detect form-data instance
        (kind === 'object' && isFunction(thing.toString) && thing.toString() === '[object FormData]')
      )
    )
  )
};

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
const isURLSearchParams = kindOfTest('URLSearchParams');

const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 *
 * @returns {String} The String freed of excess whitespace
 */
const trim = (str) => str.trim ?
  str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 *
 * @param {Boolean} [allOwnKeys = false]
 * @returns {any}
 */
function forEach(obj, fn, {allOwnKeys = false} = {}) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  let i;
  let l;

  // Force an array if not already something iterable
  if (typeof obj !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;

    for (i = 0; i < len; i++) {
      key = keys[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}

function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i = keys.length;
  let _key;
  while (i-- > 0) {
    _key = keys[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}

const _global = (() => {
  /*eslint no-undef:0*/
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
})();

const isContextDefined = (context) => !isUndefined(context) && context !== _global;

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 *
 * @returns {Object} Result of all merge properties
 */
function merge(/* obj1, obj2, obj3, ... */) {
  const {caseless} = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };

  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 *
 * @param {Boolean} [allOwnKeys]
 * @returns {Object} The resulting value of object a
 */
const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
  forEach(b, (val, key) => {
    if (thisArg && isFunction(val)) {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  }, {allOwnKeys});
  return a;
};

/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 *
 * @returns {string} content value without BOM
 */
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }
  return content;
};

/**
 * Inherit the prototype methods from one constructor into another
 * @param {function} constructor
 * @param {function} superConstructor
 * @param {object} [props]
 * @param {object} [descriptors]
 *
 * @returns {void}
 */
const inherits = (constructor, superConstructor, props, descriptors) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, 'super', {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};

/**
 * Resolve object with deep prototype chain to a flat object
 * @param {Object} sourceObj source object
 * @param {Object} [destObj]
 * @param {Function|Boolean} [filter]
 * @param {Function} [propFilter]
 *
 * @returns {Object}
 */
const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};

  destObj = destObj || {};
  // eslint-disable-next-line no-eq-null,eqeqeq
  if (sourceObj == null) return destObj;

  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

  return destObj;
};

/**
 * Determines whether a string ends with the characters of a specified string
 *
 * @param {String} str
 * @param {String} searchString
 * @param {Number} [position= 0]
 *
 * @returns {boolean}
 */
const endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === undefined || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};


/**
 * Returns new array from array like object or null if failed
 *
 * @param {*} [thing]
 *
 * @returns {?Array}
 */
const toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};

/**
 * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
 * thing passed in is an instance of Uint8Array
 *
 * @param {TypedArray}
 *
 * @returns {Array}
 */
// eslint-disable-next-line func-names
const isTypedArray = (TypedArray => {
  // eslint-disable-next-line func-names
  return thing => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

/**
 * For each entry in the object, call the function with the key and value.
 *
 * @param {Object<any, any>} obj - The object to iterate over.
 * @param {Function} fn - The function to call for each entry.
 *
 * @returns {void}
 */
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[iterator];

  const _iterator = generator.call(obj);

  let result;

  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};

/**
 * It takes a regular expression and a string, and returns an array of all the matches
 *
 * @param {string} regExp - The regular expression to match against.
 * @param {string} str - The string to search.
 *
 * @returns {Array<boolean>}
 */
const matchAll = (regExp, str) => {
  let matches;
  const arr = [];

  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }

  return arr;
};

/* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
const isHTMLForm = kindOfTest('HTMLFormElement');

const toCamelCase = str => {
  return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
    function replacer(m, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};

/* Creating a function that will check if an object has a property. */
const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

/**
 * Determine if a value is a RegExp object
 *
 * @param {*} val The value to test
 *
 * @returns {boolean} True if value is a RegExp object, otherwise false
 */
const isRegExp = kindOfTest('RegExp');

const reduceDescriptors = (obj, reducer) => {
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};

  forEach(descriptors, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });

  Object.defineProperties(obj, reducedDescriptors);
};

/**
 * Makes all methods read-only
 * @param {Object} obj
 */

const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    // skip restricted props in strict mode
    if (isFunction(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
      return false;
    }

    const value = obj[name];

    if (!isFunction(value)) return;

    descriptor.enumerable = false;

    if ('writable' in descriptor) {
      descriptor.writable = false;
      return;
    }

    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error('Can not rewrite read-only method \'' + name + '\'');
      };
    }
  });
};

const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};

  const define = (arr) => {
    arr.forEach(value => {
      obj[value] = true;
    });
  };

  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

  return obj;
};

const noop = () => {};

const toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};

/**
 * If the thing is a FormData object, return true, otherwise return false.
 *
 * @param {unknown} thing - The thing to check.
 *
 * @returns {boolean}
 */
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
}

const toJSONObject = (obj) => {
  const stack = new Array(10);

  const visit = (source, i) => {

    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }

      if(!('toJSON' in source)) {
        stack[i] = source;
        const target = isArray(source) ? [] : {};

        forEach(source, (value, key) => {
          const reducedValue = visit(value, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });

        stack[i] = undefined;

        return target;
      }
    }

    return source;
  };

  return visit(obj, 0);
};

const isAsyncFn = kindOfTest('AsyncFunction');

const isThenable = (thing) =>
  thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);

// original code
// https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }

  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({source, data}) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);

    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    }
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === 'function',
  isFunction(_global.postMessage)
);

const asap = typeof queueMicrotask !== 'undefined' ?
  queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

// *********************


const isIterable = (thing) => thing != null && isFunction(thing[iterator]);


const utils$1 = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [config] The config.
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 *
 * @returns {Error} The created error.
 */
function AxiosError(message, code, config, request, response) {
  Error.call(this);

  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error()).stack;
  }

  this.message = message;
  this.name = 'AxiosError';
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}

utils$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});

const prototype$1 = AxiosError.prototype;
const descriptors = {};

[
  'ERR_BAD_OPTION_VALUE',
  'ERR_BAD_OPTION',
  'ECONNABORTED',
  'ETIMEDOUT',
  'ERR_NETWORK',
  'ERR_FR_TOO_MANY_REDIRECTS',
  'ERR_DEPRECATED',
  'ERR_BAD_RESPONSE',
  'ERR_BAD_REQUEST',
  'ERR_CANCELED',
  'ERR_NOT_SUPPORT',
  'ERR_INVALID_URL'
// eslint-disable-next-line func-names
].forEach(code => {
  descriptors[code] = {value: code};
});

Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

// eslint-disable-next-line func-names
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype$1);

  utils$1.toFlatObject(error, axiosError, function filter(obj) {
    return obj !== Error.prototype;
  }, prop => {
    return prop !== 'isAxiosError';
  });

  AxiosError.call(axiosError, error.message, code, config, request, response);

  axiosError.cause = error;

  axiosError.name = error.name;

  customProps && Object.assign(axiosError, customProps);

  return axiosError;
};

/**
 * Determines if the given thing is a array or js object.
 *
 * @param {string} thing - The object or array to be visited.
 *
 * @returns {boolean}
 */
function isVisitable(thing) {
  return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
}

/**
 * It removes the brackets from the end of a string
 *
 * @param {string} key - The key of the parameter.
 *
 * @returns {string} the key without the brackets.
 */
function removeBrackets(key) {
  return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
}

/**
 * It takes a path, a key, and a boolean, and returns a string
 *
 * @param {string} path - The path to the current key.
 * @param {string} key - The key of the current object being iterated over.
 * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
 *
 * @returns {string} The path to the current key.
 */
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i) {
    // eslint-disable-next-line no-param-reassign
    token = removeBrackets(token);
    return !dots && i ? '[' + token + ']' : token;
  }).join(dots ? '.' : '');
}

/**
 * If the array is an array and none of its elements are visitable, then it's a flat array.
 *
 * @param {Array<any>} arr - The array to check
 *
 * @returns {boolean}
 */
function isFlatArray(arr) {
  return utils$1.isArray(arr) && !arr.some(isVisitable);
}

const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});

/**
 * Convert a data object to FormData
 *
 * @param {Object} obj
 * @param {?Object} [formData]
 * @param {?Object} [options]
 * @param {Function} [options.visitor]
 * @param {Boolean} [options.metaTokens = true]
 * @param {Boolean} [options.dots = false]
 * @param {?Boolean} [options.indexes = false]
 *
 * @returns {Object}
 **/

/**
 * It converts an object into a FormData object
 *
 * @param {Object<any, any>} obj - The object to convert to form data.
 * @param {string} formData - The FormData object to append to.
 * @param {Object<string, any>} options
 *
 * @returns
 */
function toFormData(obj, formData, options) {
  if (!utils$1.isObject(obj)) {
    throw new TypeError('target must be an object');
  }

  // eslint-disable-next-line no-param-reassign
  formData = formData || new (FormData__default["default"] || FormData)();

  // eslint-disable-next-line no-param-reassign
  options = utils$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    // eslint-disable-next-line no-eq-null,eqeqeq
    return !utils$1.isUndefined(source[option]);
  });

  const metaTokens = options.metaTokens;
  // eslint-disable-next-line no-use-before-define
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
  const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

  if (!utils$1.isFunction(visitor)) {
    throw new TypeError('visitor must be a function');
  }

  function convertValue(value) {
    if (value === null) return '';

    if (utils$1.isDate(value)) {
      return value.toISOString();
    }

    if (utils$1.isBoolean(value)) {
      return value.toString();
    }

    if (!useBlob && utils$1.isBlob(value)) {
      throw new AxiosError('Blob is not supported. Use a Buffer instead.');
    }

    if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
      return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
    }

    return value;
  }

  /**
   * Default visitor.
   *
   * @param {*} value
   * @param {String|Number} key
   * @param {Array<String|Number>} path
   * @this {FormData}
   *
   * @returns {boolean} return true to visit the each prop of the value recursively
   */
  function defaultVisitor(value, key, path) {
    let arr = value;

    if (value && !path && typeof value === 'object') {
      if (utils$1.endsWith(key, '{}')) {
        // eslint-disable-next-line no-param-reassign
        key = metaTokens ? key : key.slice(0, -2);
        // eslint-disable-next-line no-param-reassign
        value = JSON.stringify(value);
      } else if (
        (utils$1.isArray(value) && isFlatArray(value)) ||
        ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
        )) {
        // eslint-disable-next-line no-param-reassign
        key = removeBrackets(key);

        arr.forEach(function each(el, index) {
          !(utils$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
            convertValue(el)
          );
        });
        return false;
      }
    }

    if (isVisitable(value)) {
      return true;
    }

    formData.append(renderKey(path, key, dots), convertValue(value));

    return false;
  }

  const stack = [];

  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });

  function build(value, path) {
    if (utils$1.isUndefined(value)) return;

    if (stack.indexOf(value) !== -1) {
      throw Error('Circular reference detected in ' + path.join('.'));
    }

    stack.push(value);

    utils$1.forEach(value, function each(el, key) {
      const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
        formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
      );

      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });

    stack.pop();
  }

  if (!utils$1.isObject(obj)) {
    throw new TypeError('data must be an object');
  }

  build(obj);

  return formData;
}

/**
 * It encodes a string by replacing all characters that are not in the unreserved set with
 * their percent-encoded equivalents
 *
 * @param {string} str - The string to encode.
 *
 * @returns {string} The encoded string.
 */
function encode$1(str) {
  const charMap = {
    '!': '%21',
    "'": '%27',
    '(': '%28',
    ')': '%29',
    '~': '%7E',
    '%20': '+',
    '%00': '\x00'
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}

/**
 * It takes a params object and converts it to a FormData object
 *
 * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
 * @param {Object<string, any>} options - The options object passed to the Axios constructor.
 *
 * @returns {void}
 */
function AxiosURLSearchParams(params, options) {
  this._pairs = [];

  params && toFormData(params, this, options);
}

const prototype = AxiosURLSearchParams.prototype;

prototype.append = function append(name, value) {
  this._pairs.push([name, value]);
};

prototype.toString = function toString(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode$1);
  } : encode$1;

  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + '=' + _encode(pair[1]);
  }, '').join('&');
};

/**
 * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
 * URI encoded counterparts
 *
 * @param {string} val The value to be encoded.
 *
 * @returns {string} The encoded value.
 */
function encode(val) {
  return encodeURIComponent(val).
    replace(/%3A/gi, ':').
    replace(/%24/g, '$').
    replace(/%2C/gi, ',').
    replace(/%20/g, '+').
    replace(/%5B/gi, '[').
    replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @param {?(object|Function)} options
 *
 * @returns {string} The formatted url
 */
function buildURL(url, params, options) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }
  
  const _encode = options && options.encode || encode;

  if (utils$1.isFunction(options)) {
    options = {
      serialize: options
    };
  } 

  const serializeFn = options && options.serialize;

  let serializedParams;

  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1.isURLSearchParams(params) ?
      params.toString() :
      new AxiosURLSearchParams(params, options).toString(_encode);
  }

  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
}

class InterceptorManager {
  constructor() {
    this.handlers = [];
  }

  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }

  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }

  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }

  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn(h);
      }
    });
  }
}

const InterceptorManager$1 = InterceptorManager;

const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

const URLSearchParams = url__default["default"].URLSearchParams;

const ALPHA = 'abcdefghijklmnopqrstuvwxyz';

const DIGIT = '0123456789';

const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};

const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str = '';
  const {length} = alphabet;
  const randomValues = new Uint32Array(size);
  crypto__default["default"].randomFillSync(randomValues);
  for (let i = 0; i < size; i++) {
    str += alphabet[randomValues[i] % length];
  }

  return str;
};


const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams,
    FormData: FormData__default["default"],
    Blob: typeof Blob !== 'undefined' && Blob || null
  },
  ALPHABET,
  generateString,
  protocols: [ 'http', 'https', 'file', 'data' ]
};

const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

const _navigator = typeof navigator === 'object' && navigator || undefined;

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 *
 * @returns {boolean}
 */
const hasStandardBrowserEnv = hasBrowserEnv &&
  (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

/**
 * Determine if we're running in a standard browser webWorker environment
 *
 * Although the `isStandardBrowserEnv` method indicates that
 * `allows axios to run in a web worker`, the WebWorker will still be
 * filtered out due to its judgment standard
 * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
 * This leads to a problem when axios post `FormData` in webWorker
 */
const hasStandardBrowserWebWorkerEnv = (() => {
  return (
    typeof WorkerGlobalScope !== 'undefined' &&
    // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope &&
    typeof self.importScripts === 'function'
  );
})();

const origin = hasBrowserEnv && window.location.href || 'http://localhost';

const utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  hasBrowserEnv: hasBrowserEnv,
  hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv: hasStandardBrowserEnv,
  navigator: _navigator,
  origin: origin
});

const platform = {
  ...utils,
  ...platform$1
};

function toURLEncodedForm(data, options) {
  return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform.isNode && utils$1.isBuffer(value)) {
        this.append(key, value.toString('base64'));
        return false;
      }

      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

/**
 * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
 *
 * @param {string} name - The name of the property to get.
 *
 * @returns An array of strings.
 */
function parsePropPath(name) {
  // foo[x][y][z]
  // foo.x.y.z
  // foo-x-y-z
  // foo x y z
  return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
    return match[0] === '[]' ? '' : match[1] || match[0];
  });
}

/**
 * Convert an array to an object.
 *
 * @param {Array<any>} arr - The array to convert to an object.
 *
 * @returns An object with the same keys and values as the array.
 */
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i;
  const len = keys.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys[i];
    obj[key] = arr[key];
  }
  return obj;
}

/**
 * It takes a FormData object and returns a JavaScript object
 *
 * @param {string} formData The FormData object to convert to JSON.
 *
 * @returns {Object<string, any> | null} The converted object.
 */
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];

    if (name === '__proto__') return true;

    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils$1.isArray(target) ? target.length : name;

    if (isLast) {
      if (utils$1.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }

      return !isNumericKey;
    }

    if (!target[name] || !utils$1.isObject(target[name])) {
      target[name] = [];
    }

    const result = buildPath(path, value, target[name], index);

    if (result && utils$1.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }

    return !isNumericKey;
  }

  if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
    const obj = {};

    utils$1.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });

    return obj;
  }

  return null;
}

/**
 * It takes a string, tries to parse it, and if it fails, it returns the stringified version
 * of the input
 *
 * @param {any} rawValue - The value to be stringified.
 * @param {Function} parser - A function that parses a string into a JavaScript object.
 * @param {Function} encoder - A function that takes a value and returns a string.
 *
 * @returns {string} A stringified version of the rawValue.
 */
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

const defaults = {

  transitional: transitionalDefaults,

  adapter: ['xhr', 'http', 'fetch'],

  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || '';
    const hasJSONContentType = contentType.indexOf('application/json') > -1;
    const isObjectPayload = utils$1.isObject(data);

    if (isObjectPayload && utils$1.isHTMLForm(data)) {
      data = new FormData(data);
    }

    const isFormData = utils$1.isFormData(data);

    if (isFormData) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
    }

    if (utils$1.isArrayBuffer(data) ||
      utils$1.isBuffer(data) ||
      utils$1.isStream(data) ||
      utils$1.isFile(data) ||
      utils$1.isBlob(data) ||
      utils$1.isReadableStream(data)
    ) {
      return data;
    }
    if (utils$1.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$1.isURLSearchParams(data)) {
      headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
      return data.toString();
    }

    let isFileList;

    if (isObjectPayload) {
      if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }

      if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
        const _FormData = this.env && this.env.FormData;

        return toFormData(
          isFileList ? {'files[]': data} : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }

    if (isObjectPayload || hasJSONContentType ) {
      headers.setContentType('application/json', false);
      return stringifySafely(data);
    }

    return data;
  }],

  transformResponse: [function transformResponse(data) {
    const transitional = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    const JSONRequested = this.responseType === 'json';

    if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
      return data;
    }

    if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
      const silentJSONParsing = transitional && transitional.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;

      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,
  maxBodyLength: -1,

  env: {
    FormData: platform.classes.FormData,
    Blob: platform.classes.Blob
  },

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },

  headers: {
    common: {
      'Accept': 'application/json, text/plain, */*',
      'Content-Type': undefined
    }
  }
};

utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
  defaults.headers[method] = {};
});

const defaults$1 = defaults;

// RawAxiosHeaders whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
const ignoreDuplicateOf = utils$1.toObjectSet([
  'age', 'authorization', 'content-length', 'content-type', 'etag',
  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
  'last-modified', 'location', 'max-forwards', 'proxy-authorization',
  'referer', 'retry-after', 'user-agent'
]);

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} rawHeaders Headers needing to be parsed
 *
 * @returns {Object} Headers parsed into an object
 */
const parseHeaders = rawHeaders => {
  const parsed = {};
  let key;
  let val;
  let i;

  rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
    i = line.indexOf(':');
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();

    if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
      return;
    }

    if (key === 'set-cookie') {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
    }
  });

  return parsed;
};

const $internals = Symbol('internals');

function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}

function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }

  return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
}

function parseTokens(str) {
  const tokens = Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;

  while ((match = tokensRE.exec(str))) {
    tokens[match[1]] = match[2];
  }

  return tokens;
}

const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
  if (utils$1.isFunction(filter)) {
    return filter.call(this, value, header);
  }

  if (isHeaderNameFilter) {
    value = header;
  }

  if (!utils$1.isString(value)) return;

  if (utils$1.isString(filter)) {
    return value.indexOf(filter) !== -1;
  }

  if (utils$1.isRegExp(filter)) {
    return filter.test(value);
  }
}

function formatHeader(header) {
  return header.trim()
    .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
      return char.toUpperCase() + str;
    });
}

function buildAccessors(obj, header) {
  const accessorName = utils$1.toCamelCase(' ' + header);

  ['get', 'set', 'has'].forEach(methodName => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}

class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }

  set(header, valueOrRewrite, rewrite) {
    const self = this;

    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);

      if (!lHeader) {
        throw new Error('header name must be a non-empty string');
      }

      const key = utils$1.findKey(self, lHeader);

      if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
        self[key || _header] = normalizeValue(_value);
      }
    }

    const setHeaders = (headers, _rewrite) =>
      utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

    if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders(header), valueOrRewrite);
    } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils$1.isArray(entry)) {
          throw TypeError('Object iterator must return a key-value pair');
        }

        obj[key = entry[0]] = (dest = obj[key]) ?
          (utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
      }

      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }

    return this;
  }

  get(header, parser) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      if (key) {
        const value = this[key];

        if (!parser) {
          return value;
        }

        if (parser === true) {
          return parseTokens(value);
        }

        if (utils$1.isFunction(parser)) {
          return parser.call(this, value, key);
        }

        if (utils$1.isRegExp(parser)) {
          return parser.exec(value);
        }

        throw new TypeError('parser must be boolean|regexp|function');
      }
    }
  }

  has(header, matcher) {
    header = normalizeHeader(header);

    if (header) {
      const key = utils$1.findKey(this, header);

      return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }

    return false;
  }

  delete(header, matcher) {
    const self = this;
    let deleted = false;

    function deleteHeader(_header) {
      _header = normalizeHeader(_header);

      if (_header) {
        const key = utils$1.findKey(self, _header);

        if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
          delete self[key];

          deleted = true;
        }
      }
    }

    if (utils$1.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }

    return deleted;
  }

  clear(matcher) {
    const keys = Object.keys(this);
    let i = keys.length;
    let deleted = false;

    while (i--) {
      const key = keys[i];
      if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }

    return deleted;
  }

  normalize(format) {
    const self = this;
    const headers = {};

    utils$1.forEach(this, (value, header) => {
      const key = utils$1.findKey(headers, header);

      if (key) {
        self[key] = normalizeValue(value);
        delete self[header];
        return;
      }

      const normalized = format ? formatHeader(header) : String(header).trim();

      if (normalized !== header) {
        delete self[header];
      }

      self[normalized] = normalizeValue(value);

      headers[normalized] = true;
    });

    return this;
  }

  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }

  toJSON(asStrings) {
    const obj = Object.create(null);

    utils$1.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
    });

    return obj;
  }

  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }

  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
  }

  getSetCookie() {
    return this.get("set-cookie") || [];
  }

  get [Symbol.toStringTag]() {
    return 'AxiosHeaders';
  }

  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }

  static concat(first, ...targets) {
    const computed = new this(first);

    targets.forEach((target) => computed.set(target));

    return computed;
  }

  static accessor(header) {
    const internals = this[$internals] = (this[$internals] = {
      accessors: {}
    });

    const accessors = internals.accessors;
    const prototype = this.prototype;

    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);

      if (!accessors[lHeader]) {
        buildAccessors(prototype, _header);
        accessors[lHeader] = true;
      }
    }

    utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

    return this;
  }
}

AxiosHeaders.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

// reserved names hotfix
utils$1.reduceDescriptors(AxiosHeaders.prototype, ({value}, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  }
});

utils$1.freezeMethods(AxiosHeaders);

const AxiosHeaders$1 = AxiosHeaders;

/**
 * Transform the data for a request or a response
 *
 * @param {Array|Function} fns A single function or Array of functions
 * @param {?Object} response The response object
 *
 * @returns {*} The resulting transformed data
 */
function transformData(fns, response) {
  const config = this || defaults$1;
  const context = response || config;
  const headers = AxiosHeaders$1.from(context.headers);
  let data = context.data;

  utils$1.forEach(fns, function transform(fn) {
    data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
  });

  headers.normalize();

  return data;
}

function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

/**
 * A `CanceledError` is an object that is thrown when an operation is canceled.
 *
 * @param {string=} message The message.
 * @param {Object=} config The config.
 * @param {Object=} request The request.
 *
 * @returns {CanceledError} The created error.
 */
function CanceledError(message, config, request) {
  // eslint-disable-next-line no-eq-null,eqeqeq
  AxiosError.call(this, message == null ? 'canceled' : message, AxiosError.ERR_CANCELED, config, request);
  this.name = 'CanceledError';
}

utils$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 *
 * @returns {object} The response.
 */
function settle(resolve, reject, response) {
  const validateStatus = response.config.validateStatus;
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError(
      'Request failed with status code ' + response.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 *
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */
function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 *
 * @returns {string} The combined URL
 */
function combineURLs(baseURL, relativeURL) {
  return relativeURL
    ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
    : baseURL;
}

/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 *
 * @returns {string} The combined full path
 */
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

const VERSION = "1.10.0";

function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || '';
}

const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;

/**
 * Parse data uri to a Buffer or Blob
 *
 * @param {String} uri
 * @param {?Boolean} asBlob
 * @param {?Object} options
 * @param {?Function} options.Blob
 *
 * @returns {Buffer|Blob}
 */
function fromDataURI(uri, asBlob, options) {
  const _Blob = options && options.Blob || platform.classes.Blob;
  const protocol = parseProtocol(uri);

  if (asBlob === undefined && _Blob) {
    asBlob = true;
  }

  if (protocol === 'data') {
    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;

    const match = DATA_URL_PATTERN.exec(uri);

    if (!match) {
      throw new AxiosError('Invalid URL', AxiosError.ERR_INVALID_URL);
    }

    const mime = match[1];
    const isBase64 = match[2];
    const body = match[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');

    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError('Blob is not supported', AxiosError.ERR_NOT_SUPPORT);
      }

      return new _Blob([buffer], {type: mime});
    }

    return buffer;
  }

  throw new AxiosError('Unsupported protocol ' + protocol, AxiosError.ERR_NOT_SUPPORT);
}

const kInternals = Symbol('internals');

class AxiosTransformStream extends stream__default["default"].Transform{
  constructor(options) {
    options = utils$1.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$1.isUndefined(source[prop]);
    });

    super({
      readableHighWaterMark: options.chunkSize
    });

    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };

    this.on('newListener', event => {
      if (event === 'progress') {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }

  _read(size) {
    const internals = this[kInternals];

    if (internals.onReadCallback) {
      internals.onReadCallback();
    }

    return super._read(size);
  }

  _transform(chunk, encoding, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;

    const readableHighWaterMark = this.readableHighWaterMark;

    const timeWindow = internals.timeWindow;

    const divider = 1000 / timeWindow;
    const bytesThreshold = (maxRate / divider);
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;

    const pushChunk = (_chunk, _callback) => {
      const bytes = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes;
      internals.bytes += bytes;

      internals.isCaptured && this.emit('progress', internals.bytesSeen);

      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };

    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;

      if (maxRate) {
        const now = Date.now();

        if (!internals.ts || (passed = (now - internals.ts)) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }

        bytesLeft = bytesThreshold - internals.bytes;
      }

      if (maxRate) {
        if (bytesLeft <= 0) {
          // next time window
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }

        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }

      if (maxChunkSize && chunkSize > maxChunkSize && (chunkSize - maxChunkSize) > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }

      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };

    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }

      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}

const AxiosTransformStream$1 = AxiosTransformStream;

const {asyncIterator} = Symbol;

const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};

const readBlob$1 = readBlob;

const BOUNDARY_ALPHABET = platform.ALPHABET.ALPHA_DIGIT + '-_';

const textEncoder = typeof TextEncoder === 'function' ? new TextEncoder() : new util__default["default"].TextEncoder();

const CRLF = '\r\n';
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;

class FormDataPart {
  constructor(name, value) {
    const {escapeName} = this.constructor;
    const isStringValue = utils$1.isString(value);

    let headers = `Content-Disposition: form-data; name="${escapeName(name)}"${
      !isStringValue && value.name ? `; filename="${escapeName(value.name)}"` : ''
    }${CRLF}`;

    if (isStringValue) {
      value = textEncoder.encode(String(value).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value.type || "application/octet-stream"}${CRLF}`;
    }

    this.headers = textEncoder.encode(headers + CRLF);

    this.contentLength = isStringValue ? value.byteLength : value.size;

    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;

    this.name = name;
    this.value = value;
  }

  async *encode(){
    yield this.headers;

    const {value} = this;

    if(utils$1.isTypedArray(value)) {
      yield value;
    } else {
      yield* readBlob$1(value);
    }

    yield CRLF_BYTES;
  }

  static escapeName(name) {
      return String(name).replace(/[\r\n"]/g, (match) => ({
        '\r' : '%0D',
        '\n' : '%0A',
        '"' : '%22',
      }[match]));
  }
}

const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = 'form-data-boundary',
    size = 25,
    boundary = tag + '-' + platform.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};

  if(!utils$1.isFormData(form)) {
    throw TypeError('FormData instance required');
  }

  if (boundary.length < 1 || boundary.length > 70) {
    throw Error('boundary must be 10-70 characters long')
  }

  const boundaryBytes = textEncoder.encode('--' + boundary + CRLF);
  const footerBytes = textEncoder.encode('--' + boundary + '--' + CRLF);
  let contentLength = footerBytes.byteLength;

  const parts = Array.from(form.entries()).map(([name, value]) => {
    const part = new FormDataPart(name, value);
    contentLength += part.size;
    return part;
  });

  contentLength += boundaryBytes.byteLength * parts.length;

  contentLength = utils$1.toFiniteNumber(contentLength);

  const computedHeaders = {
    'Content-Type': `multipart/form-data; boundary=${boundary}`
  };

  if (Number.isFinite(contentLength)) {
    computedHeaders['Content-Length'] = contentLength;
  }

  headersHandler && headersHandler(computedHeaders);

  return stream.Readable.from((async function *() {
    for(const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }

    yield footerBytes;
  })());
};

const formDataToStream$1 = formDataToStream;

class ZlibHeaderTransformStream extends stream__default["default"].Transform {
  __transform(chunk, encoding, callback) {
    this.push(chunk);
    callback();
  }

  _transform(chunk, encoding, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;

      // Add Default Compression headers if no zlib headers are present
      if (chunk[0] !== 120) { // Hex: 78
        const header = Buffer.alloc(2);
        header[0] = 120; // Hex: 78
        header[1] = 156; // Hex: 9C 
        this.push(header, encoding);
      }
    }

    this.__transform(chunk, encoding, callback);
  }
}

const ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;

const callbackify = (fn, reducer) => {
  return utils$1.isAsyncFn(fn) ? function (...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value) => {
      try {
        reducer ? cb(null, ...reducer(value)) : cb(null, value);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};

const callbackify$1 = callbackify;

/**
 * Calculate data maxRate
 * @param {Number} [samplesCount= 10]
 * @param {Number} [min= 1000]
 * @returns {Function}
 */
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;

  min = min !== undefined ? min : 1000;

  return function push(chunkLength) {
    const now = Date.now();

    const startedAt = timestamps[tail];

    if (!firstSampleTS) {
      firstSampleTS = now;
    }

    bytes[head] = chunkLength;
    timestamps[head] = now;

    let i = tail;
    let bytesCount = 0;

    while (i !== head) {
      bytesCount += bytes[i++];
      i = i % samplesCount;
    }

    head = (head + 1) % samplesCount;

    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }

    if (now - firstSampleTS < min) {
      return;
    }

    const passed = startedAt && now - startedAt;

    return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
  };
}

/**
 * Throttle decorator
 * @param {Function} fn
 * @param {Number} freq
 * @return {Function}
 */
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1000 / freq;
  let lastArgs;
  let timer;

  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };

  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if ( passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };

  const flush = () => lastArgs && invoke(lastArgs);

  return [throttled, flush];
}

const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);

  return throttle(e => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : undefined;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;

    bytesNotified = loaded;

    const data = {
      loaded,
      total,
      progress: total ? (loaded / total) : undefined,
      bytes: progressBytes,
      rate: rate ? rate : undefined,
      estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? 'download' : 'upload']: true
    };

    listener(data);
  }, freq);
};

const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;

  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};

const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

const zlibOptions = {
  flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
  finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
};

const brotliOptions = {
  flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
};

const isBrotliSupported = utils$1.isFunction(zlib__default["default"].createBrotliDecompress);

const {http: httpFollow, https: httpsFollow} = followRedirects__default["default"];

const isHttps = /https:?/;

const supportedProtocols = platform.protocols.map(protocol => {
  return protocol + ':';
});

const flushOnFinish = (stream, [throttled, flush]) => {
  stream
    .on('end', flush)
    .on('error', flush);

  return throttled;
};

/**
 * If the proxy or config beforeRedirects functions are defined, call them with the options
 * object.
 *
 * @param {Object<string, any>} options - The options object that was passed to the request.
 *
 * @returns {Object<string, any>}
 */
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}

/**
 * If the proxy or config afterRedirects functions are defined, call them with the options
 *
 * @param {http.ClientRequestArgs} options
 * @param {AxiosProxyConfig} configProxy configuration from Axios options object
 * @param {string} location
 *
 * @returns {http.ClientRequestArgs}
 */
function setProxy(options, configProxy, location) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv__default["default"].getProxyForUrl(location);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    // Basic proxy authorization
    if (proxy.username) {
      proxy.auth = (proxy.username || '') + ':' + (proxy.password || '');
    }

    if (proxy.auth) {
      // Support proxy auth object form
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || '') + ':' + (proxy.auth.password || '');
      }
      const base64 = Buffer
        .from(proxy.auth, 'utf8')
        .toString('base64');
      options.headers['Proxy-Authorization'] = 'Basic ' + base64;
    }

    options.headers.host = options.hostname + (options.port ? ':' + options.port : '');
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    // Replace 'host' since options is not a URL object
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(':') ? proxy.protocol : `${proxy.protocol}:`;
    }
  }

  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    // Configure proxy for redirected request, passing the original config proxy to apply
    // the exact same logic as if the redirected request was performed by axios directly.
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}

const isHttpAdapterSupported = typeof process !== 'undefined' && utils$1.kindOf(process) === 'process';

// temporary hotfix

const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve, reject) => {
    let onDone;
    let isDone;

    const done = (value, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value, isRejected);
    };

    const _resolve = (value) => {
      done(value);
      resolve(value);
    };

    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };

    asyncExecutor(_resolve, _reject, (onDoneHandler) => (onDone = onDoneHandler)).catch(_reject);
  })
};

const resolveFamily = ({address, family}) => {
  if (!utils$1.isString(address)) {
    throw TypeError('address must be a string');
  }
  return ({
    address,
    family: family || (address.indexOf('.') < 0 ? 6 : 4)
  });
};

const buildAddressEntry = (address, family) => resolveFamily(utils$1.isObject(address) ? address : {address, family});

/*eslint consistent-return:0*/
const httpAdapter = isHttpAdapterSupported && function httpAdapter(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve, reject, onDone) {
    let {data, lookup, family} = config;
    const {responseType, responseEncoding} = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req;

    if (lookup) {
      const _lookup = callbackify$1(lookup, (value) => utils$1.isArray(value) ? value : [value]);
      // hotfix to support opt.all option which is required for node 20.x
      lookup = (hostname, opt, cb) => {
        _lookup(hostname, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }

          const addresses = utils$1.isArray(arg0) ? arg0.map(addr => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];

          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }

    // temporary internal emitter until the AxiosRequest class will be implemented
    const emitter = new events.EventEmitter();

    const onFinished = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort);
      }

      if (config.signal) {
        config.signal.removeEventListener('abort', abort);
      }

      emitter.removeAllListeners();
    };

    onDone((value, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished();
      }
    });

    function abort(reason) {
      emitter.emit('abort', !reason || reason.type ? new CanceledError(null, config, req) : reason);
    }

    emitter.once('abort', reject);

    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort);
      if (config.signal) {
        config.signal.aborted ? abort() : config.signal.addEventListener('abort', abort);
      }
    }

    // Parse url
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    const parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);
    const protocol = parsed.protocol || supportedProtocols[0];

    if (protocol === 'data:') {
      let convertedData;

      if (method !== 'GET') {
        return settle(resolve, reject, {
          status: 405,
          statusText: 'method not allowed',
          headers: {},
          config
        });
      }

      try {
        convertedData = fromDataURI(config.url, responseType === 'blob', {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
      }

      if (responseType === 'text') {
        convertedData = convertedData.toString(responseEncoding);

        if (!responseEncoding || responseEncoding === 'utf8') {
          convertedData = utils$1.stripBOM(convertedData);
        }
      } else if (responseType === 'stream') {
        convertedData = stream__default["default"].Readable.from(convertedData);
      }

      return settle(resolve, reject, {
        data: convertedData,
        status: 200,
        statusText: 'OK',
        headers: new AxiosHeaders$1(),
        config
      });
    }

    if (supportedProtocols.indexOf(protocol) === -1) {
      return reject(new AxiosError(
        'Unsupported protocol ' + protocol,
        AxiosError.ERR_BAD_REQUEST,
        config
      ));
    }

    const headers = AxiosHeaders$1.from(config.headers).normalize();

    // Set User-Agent (required by some servers)
    // See https://github.com/axios/axios/issues/69
    // User-Agent is specified; handle case where no UA header is desired
    // Only set header if it hasn't been set in config
    headers.set('User-Agent', 'axios/' + VERSION, false);

    const {onUploadProgress, onDownloadProgress} = config;
    const maxRate = config.maxRate;
    let maxUploadRate = undefined;
    let maxDownloadRate = undefined;

    // support for spec compliant FormData objects
    if (utils$1.isSpecCompliantForm(data)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);

      data = formDataToStream$1(data, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || undefined
      });
      // support for https://www.npmjs.com/package/form-data api
    } else if (utils$1.isFormData(data) && utils$1.isFunction(data.getHeaders)) {
      headers.set(data.getHeaders());

      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util__default["default"].promisify(data.getLength).call(data);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
          /*eslint no-empty:0*/
        } catch (e) {
        }
      }
    } else if (utils$1.isBlob(data) || utils$1.isFile(data)) {
      data.size && headers.setContentType(data.type || 'application/octet-stream');
      headers.setContentLength(data.size || 0);
      data = stream__default["default"].Readable.from(readBlob$1(data));
    } else if (data && !utils$1.isStream(data)) {
      if (Buffer.isBuffer(data)) ; else if (utils$1.isArrayBuffer(data)) {
        data = Buffer.from(new Uint8Array(data));
      } else if (utils$1.isString(data)) {
        data = Buffer.from(data, 'utf-8');
      } else {
        return reject(new AxiosError(
          'Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }

      // Add Content-Length header if data exists
      headers.setContentLength(data.length, false);

      if (config.maxBodyLength > -1 && data.length > config.maxBodyLength) {
        return reject(new AxiosError(
          'Request body larger than maxBodyLength limit',
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
    }

    const contentLength = utils$1.toFiniteNumber(headers.getContentLength());

    if (utils$1.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }

    if (data && (onUploadProgress || maxUploadRate)) {
      if (!utils$1.isStream(data)) {
        data = stream__default["default"].Readable.from(data, {objectMode: false});
      }

      data = stream__default["default"].pipeline([data, new AxiosTransformStream$1({
        maxRate: utils$1.toFiniteNumber(maxUploadRate)
      })], utils$1.noop);

      onUploadProgress && data.on('progress', flushOnFinish(
        data,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }

    // HTTP basic authentication
    let auth = undefined;
    if (config.auth) {
      const username = config.auth.username || '';
      const password = config.auth.password || '';
      auth = username + ':' + password;
    }

    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ':' + urlPassword;
    }

    auth && headers.delete('authorization');

    let path;

    try {
      path = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, '');
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }

    headers.set(
      'Accept-Encoding',
      'gzip, compress, deflate' + (isBrotliSupported ? ', br' : ''), false
      );

    const options = {
      path,
      method: method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };

    // cacheable-lookup integration hotfix
    !utils$1.isUndefined(lookup) && (options.lookup = lookup);

    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol + '//' + parsed.hostname + (parsed.port ? ':' + parsed.port : '') + options.path);
    }

    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https__default["default"] : http__default["default"];
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }

    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      // follow-redirects does not skip comparison, so it should always succeed for axios -1 unlimited
      options.maxBodyLength = Infinity;
    }

    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }

    // Create the request
    req = transport.request(options, function handleResponse(res) {
      if (req.destroyed) return;

      const streams = [res];

      const responseLength = +res.headers['content-length'];

      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream$1({
          maxRate: utils$1.toFiniteNumber(maxDownloadRate)
        });

        onDownloadProgress && transformStream.on('progress', flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));

        streams.push(transformStream);
      }

      // decompress the response body transparently if required
      let responseStream = res;

      // return the last request in case of redirects
      const lastRequest = res.req || req;

      // if decompress disabled we should not decompress
      if (config.decompress !== false && res.headers['content-encoding']) {
        // if no content, but headers still say that it is encoded,
        // remove the header not confuse downstream operations
        if (method === 'HEAD' || res.statusCode === 204) {
          delete res.headers['content-encoding'];
        }

        switch ((res.headers['content-encoding'] || '').toLowerCase()) {
        /*eslint default-case:0*/
        case 'gzip':
        case 'x-gzip':
        case 'compress':
        case 'x-compress':
          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__default["default"].createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'deflate':
          streams.push(new ZlibHeaderTransformStream$1());

          // add the unzipper to the body stream processing pipeline
          streams.push(zlib__default["default"].createUnzip(zlibOptions));

          // remove the content-encoding in order to not confuse downstream operations
          delete res.headers['content-encoding'];
          break;
        case 'br':
          if (isBrotliSupported) {
            streams.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
            delete res.headers['content-encoding'];
          }
        }
      }

      responseStream = streams.length > 1 ? stream__default["default"].pipeline(streams, utils$1.noop) : streams[0];

      const offListeners = stream__default["default"].finished(responseStream, () => {
        offListeners();
        onFinished();
      });

      const response = {
        status: res.statusCode,
        statusText: res.statusMessage,
        headers: new AxiosHeaders$1(res.headers),
        config,
        request: lastRequest
      };

      if (responseType === 'stream') {
        response.data = responseStream;
        settle(resolve, reject, response);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;

        responseStream.on('data', function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;

          // make sure the content length is not over the maxContentLength if specified
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            // stream.destroy() emit aborted event before calling reject() on Node.js v16
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError('maxContentLength size of ' + config.maxContentLength + ' exceeded',
              AxiosError.ERR_BAD_RESPONSE, config, lastRequest));
          }
        });

        responseStream.on('aborted', function handlerStreamAborted() {
          if (rejected) {
            return;
          }

          const err = new AxiosError(
            'stream has been aborted',
            AxiosError.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });

        responseStream.on('error', function handleStreamError(err) {
          if (req.destroyed) return;
          reject(AxiosError.from(err, null, config, lastRequest));
        });

        responseStream.on('end', function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== 'arraybuffer') {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === 'utf8') {
                responseData = utils$1.stripBOM(responseData);
              }
            }
            response.data = responseData;
          } catch (err) {
            return reject(AxiosError.from(err, null, config, response.request, response));
          }
          settle(resolve, reject, response);
        });
      }

      emitter.once('abort', err => {
        if (!responseStream.destroyed) {
          responseStream.emit('error', err);
          responseStream.destroy();
        }
      });
    });

    emitter.once('abort', err => {
      reject(err);
      req.destroy(err);
    });

    // Handle errors
    req.on('error', function handleRequestError(err) {
      // @todo remove
      // if (req.aborted && err.code !== AxiosError.ERR_FR_TOO_MANY_REDIRECTS) return;
      reject(AxiosError.from(err, null, config, req));
    });

    // set tcp keep alive to prevent drop connection by peer
    req.on('socket', function handleRequestSocket(socket) {
      // default interval of sending ack packet is 1 minute
      socket.setKeepAlive(true, 1000 * 60);
    });

    // Handle request timeout
    if (config.timeout) {
      // This is forcing a int timeout to avoid problems if the `req` interface doesn't handle other types.
      const timeout = parseInt(config.timeout, 10);

      if (Number.isNaN(timeout)) {
        reject(new AxiosError(
          'error trying to parse `config.timeout` to int',
          AxiosError.ERR_BAD_OPTION_VALUE,
          config,
          req
        ));

        return;
      }

      // Sometime, the response will be very slow, and does not respond, the connect event will be block by event loop system.
      // And timer callback will be fired, and abort() will be invoked before connection, then get "socket hang up" and code ECONNRESET.
      // At this time, if we have a large number of request, nodejs will hang up some socket on background. and the number will up and up.
      // And then these socket which be hang up will devouring CPU little by little.
      // ClientRequest.setTimeout will be fired on the specify milliseconds, and can make sure that abort() will be fired after connect.
      req.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';
        const transitional = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          req
        ));
        abort();
      });
    }


    // Send the request
    if (utils$1.isStream(data)) {
      let ended = false;
      let errored = false;

      data.on('end', () => {
        ended = true;
      });

      data.once('error', err => {
        errored = true;
        req.destroy(err);
      });

      data.on('close', () => {
        if (!ended && !errored) {
          abort(new CanceledError('Request stream has been aborted', config, req));
        }
      });

      data.pipe(req);
    } else {
      req.end(data);
    }
  });
};

const isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
  url = new URL(url, platform.origin);

  return (
    origin.protocol === url.protocol &&
    origin.host === url.host &&
    (isMSIE || origin.port === url.port)
  );
})(
  new URL(platform.origin),
  platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
) : () => true;

const cookies = platform.hasStandardBrowserEnv ?

  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + '=' + encodeURIComponent(value)];

      utils$1.isNumber(expires) && cookie.push('expires=' + new Date(expires).toGMTString());

      utils$1.isString(path) && cookie.push('path=' + path);

      utils$1.isString(domain) && cookie.push('domain=' + domain);

      secure === true && cookie.push('secure');

      document.cookie = cookie.join('; ');
    },

    read(name) {
      const match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return (match ? decodeURIComponent(match[3]) : null);
    },

    remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  }

  :

  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {},
    read() {
      return null;
    },
    remove() {}
  };

const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 *
 * @returns {Object} New object resulting from merging config2 to config1
 */
function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  const config = {};

  function getMergedValue(target, source, prop, caseless) {
    if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
      return utils$1.merge.call({caseless}, target, source);
    } else if (utils$1.isPlainObject(source)) {
      return utils$1.merge({}, source);
    } else if (utils$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }

  // eslint-disable-next-line consistent-return
  function mergeDeepProperties(a, b, prop , caseless) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(a, b, prop , caseless);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a, prop , caseless);
    }
  }

  // eslint-disable-next-line consistent-return
  function valueFromConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    }
  }

  // eslint-disable-next-line consistent-return
  function defaultToConfig2(a, b) {
    if (!utils$1.isUndefined(b)) {
      return getMergedValue(undefined, b);
    } else if (!utils$1.isUndefined(a)) {
      return getMergedValue(undefined, a);
    }
  }

  // eslint-disable-next-line consistent-return
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(undefined, a);
    }
  }

  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b , prop) => mergeDeepProperties(headersToObject(a), headersToObject(b),prop, true)
  };

  utils$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge(config1[prop], config2[prop], prop);
    (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
  });

  return config;
}

const resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);

  let {data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth} = newConfig;

  newConfig.headers = headers = AxiosHeaders$1.from(headers);

  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

  // HTTP basic authentication
  if (auth) {
    headers.set('Authorization', 'Basic ' +
      btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
    );
  }

  let contentType;

  if (utils$1.isFormData(data)) {
    if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(undefined); // Let the browser set it
    } else if ((contentType = headers.getContentType()) !== false) {
      // fix semicolon duplication issue for ReactNative FormData implementation
      const [type, ...tokens] = contentType ? contentType.split(';').map(token => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || 'multipart/form-data', ...tokens].join('; '));
    }
  }

  // Add xsrf header
  // This is only done if running in a standard browser environment.
  // Specifically not if we're in a web worker, or react-native.

  if (platform.hasStandardBrowserEnv) {
    withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

    if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
      // Add xsrf header
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }

  return newConfig;
};

const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

const xhrAdapter = isXHRAdapterSupported && function (config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let {responseType, onUploadProgress, onDownloadProgress} = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;

    function done() {
      flushUpload && flushUpload(); // flush events
      flushDownload && flushDownload(); // flush events

      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

      _config.signal && _config.signal.removeEventListener('abort', onCanceled);
    }

    let request = new XMLHttpRequest();

    request.open(_config.method.toUpperCase(), _config.url, true);

    // Set the request timeout in MS
    request.timeout = _config.timeout;

    function onloadend() {
      if (!request) {
        return;
      }
      // Prepare the response
      const responseHeaders = AxiosHeaders$1.from(
        'getAllResponseHeaders' in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
        request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };

      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);

      // Clean up request
      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }

        // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        }
        // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'
        setTimeout(onloadend);
      };
    }

    // Handle browser request cancellation (as opposed to a manual cancellation)
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(new AxiosError('Request aborted', AxiosError.ECONNABORTED, config, request));

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
      const transitional = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request));

      // Clean up request
      request = null;
    };

    // Remove Content-Type if data is undefined
    requestData === undefined && requestHeaders.setContentType(null);

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }

    // Add withCredentials to request if needed
    if (!utils$1.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }

    // Add responseType to request if needed
    if (responseType && responseType !== 'json') {
      request.responseType = _config.responseType;
    }

    // Handle progress if needed
    if (onDownloadProgress) {
      ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
      request.addEventListener('progress', downloadThrottled);
    }

    // Not all browsers support upload events
    if (onUploadProgress && request.upload) {
      ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

      request.upload.addEventListener('progress', uploadThrottled);

      request.upload.addEventListener('loadend', flushUpload);
    }

    if (_config.cancelToken || _config.signal) {
      // Handle cancellation
      // eslint-disable-next-line func-names
      onCanceled = cancel => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
        request.abort();
        request = null;
      };

      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
      }
    }

    const protocol = parseProtocol(_config.url);

    if (protocol && platform.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError('Unsupported protocol ' + protocol + ':', AxiosError.ERR_BAD_REQUEST, config));
      return;
    }


    // Send the request
    request.send(requestData || null);
  });
};

const composeSignals = (signals, timeout) => {
  const {length} = (signals = signals ? signals.filter(Boolean) : []);

  if (timeout || length) {
    let controller = new AbortController();

    let aborted;

    const onabort = function (reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };

    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);

    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach(signal => {
          signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
        });
        signals = null;
      }
    };

    signals.forEach((signal) => signal.addEventListener('abort', onabort));

    const {signal} = controller;

    signal.unsubscribe = () => utils$1.asap(unsubscribe);

    return signal;
  }
};

const composeSignals$1 = composeSignals;

const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;

  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }

  let pos = 0;
  let end;

  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};

const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};

const readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }

  const reader = stream.getReader();
  try {
    for (;;) {
      const {done, value} = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};

const trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream, chunkSize);

  let bytes = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };

  return new ReadableStream({
    async pull(controller) {
      try {
        const {done, value} = await iterator.next();

        if (done) {
         _onFinish();
          controller.close();
          return;
        }

        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  })
};

const isFetchSupported = typeof fetch === 'function' && typeof Request === 'function' && typeof Response === 'function';
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === 'function';

// used only inside the fetch adapter
const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
    ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
    async (str) => new Uint8Array(await new Response(str).arrayBuffer())
);

const test = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false
  }
};

const supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;

  const hasContentType = new Request(platform.origin, {
    body: new ReadableStream(),
    method: 'POST',
    get duplex() {
      duplexAccessed = true;
      return 'half';
    },
  }).headers.has('Content-Type');

  return duplexAccessed && !hasContentType;
});

const DEFAULT_CHUNK_SIZE = 64 * 1024;

const supportsResponseStream = isReadableStreamSupported &&
  test(() => utils$1.isReadableStream(new Response('').body));


const resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};

isFetchSupported && (((res) => {
  ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
    !resolvers[type] && (resolvers[type] = utils$1.isFunction(res[type]) ? (res) => res[type]() :
      (_, config) => {
        throw new AxiosError(`Response type '${type}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
      });
  });
})(new Response));

const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }

  if(utils$1.isBlob(body)) {
    return body.size;
  }

  if(utils$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform.origin, {
      method: 'POST',
      body,
    });
    return (await _request.arrayBuffer()).byteLength;
  }

  if(utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
    return body.byteLength;
  }

  if(utils$1.isURLSearchParams(body)) {
    body = body + '';
  }

  if(utils$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};

const resolveBodyLength = async (headers, body) => {
  const length = utils$1.toFiniteNumber(headers.getContentLength());

  return length == null ? getBodyLength(body) : length;
};

const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = 'same-origin',
    fetchOptions
  } = resolveConfig(config);

  responseType = responseType ? (responseType + '').toLowerCase() : 'text';

  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

  let request;

  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
      composedSignal.unsubscribe();
  });

  let requestContentLength;

  try {
    if (
      onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
      (requestContentLength = await resolveBodyLength(headers, data)) !== 0
    ) {
      let _request = new Request(url, {
        method: 'POST',
        body: data,
        duplex: "half"
      });

      let contentTypeHeader;

      if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
        headers.setContentType(contentTypeHeader);
      }

      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );

        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }

    if (!utils$1.isString(withCredentials)) {
      withCredentials = withCredentials ? 'include' : 'omit';
    }

    // Cloudflare Workers throws when credentials are defined
    // see https://github.com/cloudflare/workerd/issues/902
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : undefined
    });

    let response = await fetch(request, fetchOptions);

    const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

    if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
      const options = {};

      ['status', 'statusText', 'headers'].forEach(prop => {
        options[prop] = response[prop];
      });

      const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];

      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }

    responseType = responseType || 'text';

    let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

    !isStreamResponse && unsubscribe && unsubscribe();

    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    })
  } catch (err) {
    unsubscribe && unsubscribe();

    if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError('Network Error', AxiosError.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      )
    }

    throw AxiosError.from(err, err && err.code, config, request);
  }
});

const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};

utils$1.forEach(knownAdapters, (fn, value) => {
  if (fn) {
    try {
      Object.defineProperty(fn, 'name', {value});
    } catch (e) {
      // eslint-disable-next-line no-empty
    }
    Object.defineProperty(fn, 'adapterName', {value});
  }
});

const renderReason = (reason) => `- ${reason}`;

const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

const adapters = {
  getAdapter: (adapters) => {
    adapters = utils$1.isArray(adapters) ? adapters : [adapters];

    const {length} = adapters;
    let nameOrAdapter;
    let adapter;

    const rejectedReasons = {};

    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters[i];
      let id;

      adapter = nameOrAdapter;

      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

        if (adapter === undefined) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }

      if (adapter) {
        break;
      }

      rejectedReasons[id || '#' + i] = adapter;
    }

    if (!adapter) {

      const reasons = Object.entries(rejectedReasons)
        .map(([id, state]) => `adapter ${id} ` +
          (state === false ? 'is not supported by the environment' : 'is not available in the build')
        );

      let s = length ?
        (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
        'as no adapter specified';

      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s,
        'ERR_NOT_SUPPORT'
      );
    }

    return adapter;
  },
  adapters: knownAdapters
};

/**
 * Throws a `CanceledError` if cancellation has been requested.
 *
 * @param {Object} config The config that is to be used for the request
 *
 * @returns {void}
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }

  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 *
 * @returns {Promise} The Promise to be fulfilled
 */
function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  config.headers = AxiosHeaders$1.from(config.headers);

  // Transform request data
  config.data = transformData.call(
    config,
    config.transformRequest
  );

  if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
    config.headers.setContentType('application/x-www-form-urlencoded', false);
  }

  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );

    response.headers = AxiosHeaders$1.from(response.headers);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }

    return Promise.reject(reason);
  });
}

const validators$1 = {};

// eslint-disable-next-line func-names
['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
  validators$1[type] = function validator(thing) {
    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});

const deprecatedWarnings = {};

/**
 * Transitional option validator
 *
 * @param {function|boolean?} validator - set to false if the transitional option has been removed
 * @param {string?} version - deprecated version / removed since version
 * @param {string?} message - some message with additional info
 *
 * @returns {function}
 */
validators$1.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return '[Axios v' + VERSION + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  }

  // eslint-disable-next-line func-names
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError(
        formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
        AxiosError.ERR_DEPRECATED
      );
    }

    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      // eslint-disable-next-line no-console
      console.warn(
        formatMessage(
          opt,
          ' has been deprecated since v' + version + ' and will be removed in the near future'
        )
      );
    }

    return validator ? validator(value, opt, opts) : true;
  };
};

validators$1.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    // eslint-disable-next-line no-console
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  }
};

/**
 * Assert object's properties type
 *
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 *
 * @returns {object}
 */

function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== 'object') {
    throw new AxiosError('options must be an object', AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i = keys.length;
  while (i-- > 0) {
    const opt = keys[i];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === undefined || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError('option ' + opt + ' must be ' + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError('Unknown option ' + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}

const validator = {
  assertOptions,
  validators: validators$1
};

const validators = validator.validators;

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 *
 * @return {Axios} A new instance of Axios
 */
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }

  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};

        Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

        // slice off the Error: ... line
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
        try {
          if (!err.stack) {
            err.stack = stack;
            // match without the 2 top stack lines
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
            err.stack += '\n' + stack;
          }
        } catch (e) {
          // ignore the case where "stack" is an un-writable property
        }
      }

      throw err;
    }
  }

  _request(configOrUrl, config) {
    /*eslint no-param-reassign:0*/
    // Allow for axios('example/url'[, config]) a la fetch API
    if (typeof configOrUrl === 'string') {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }

    config = mergeConfig(this.defaults, config);

    const {transitional, paramsSerializer, headers} = config;

    if (transitional !== undefined) {
      validator.assertOptions(transitional, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }

    if (paramsSerializer != null) {
      if (utils$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }

    // Set config.allowAbsoluteUrls
    if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }

    validator.assertOptions(config, {
      baseUrl: validators.spelling('baseURL'),
      withXsrfToken: validators.spelling('withXSRFToken')
    }, true);

    // Set config.method
    config.method = (config.method || this.defaults.method || 'get').toLowerCase();

    // Flatten headers
    let contextHeaders = headers && utils$1.merge(
      headers.common,
      headers[config.method]
    );

    headers && utils$1.forEach(
      ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
      (method) => {
        delete headers[method];
      }
    );

    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

    // filter out skipped interceptors
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
        return;
      }

      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });

    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });

    let promise;
    let i = 0;
    let len;

    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), undefined];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;

      promise = Promise.resolve(config);

      while (i < len) {
        promise = promise.then(chain[i++], chain[i++]);
      }

      return promise;
    }

    len = requestInterceptorChain.length;

    let newConfig = config;

    i = 0;

    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }

    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }

    i = 0;
    len = responseInterceptorChain.length;

    while (i < len) {
      promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }

    return promise;
  }

  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}

// Provide aliases for supported request methods
utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});

utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/

  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          'Content-Type': 'multipart/form-data'
        } : {},
        url,
        data
      }));
    };
  }

  Axios.prototype[method] = generateHTTPMethod();

  Axios.prototype[method + 'Form'] = generateHTTPMethod(true);
});

const Axios$1 = Axios;

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @param {Function} executor The executor function.
 *
 * @returns {CancelToken}
 */
class CancelToken {
  constructor(executor) {
    if (typeof executor !== 'function') {
      throw new TypeError('executor must be a function.');
    }

    let resolvePromise;

    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });

    const token = this;

    // eslint-disable-next-line func-names
    this.promise.then(cancel => {
      if (!token._listeners) return;

      let i = token._listeners.length;

      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });

    // eslint-disable-next-line func-names
    this.promise.then = onfulfilled => {
      let _resolve;
      // eslint-disable-next-line func-names
      const promise = new Promise(resolve => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);

      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };

      return promise;
    };

    executor(function cancel(message, config, request) {
      if (token.reason) {
        // Cancellation has already been requested
        return;
      }

      token.reason = new CanceledError(message, config, request);
      resolvePromise(token.reason);
    });
  }

  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }

  /**
   * Subscribe to the cancel signal
   */

  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }

    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }

  /**
   * Unsubscribe from the cancel signal
   */

  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }

  toAbortSignal() {
    const controller = new AbortController();

    const abort = (err) => {
      controller.abort(err);
    };

    this.subscribe(abort);

    controller.signal.unsubscribe = () => this.unsubscribe(abort);

    return controller.signal;
  }

  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}

const CancelToken$1 = CancelToken;

/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 *
 * @returns {Function}
 */
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 *
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */
function isAxiosError(payload) {
  return utils$1.isObject(payload) && (payload.isAxiosError === true);
}

const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511,
};

Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});

const HttpStatusCode$1 = HttpStatusCode;

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 *
 * @returns {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  const context = new Axios$1(defaultConfig);
  const instance = bind(Axios$1.prototype.request, context);

  // Copy axios.prototype to instance
  utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

  // Copy context to instance
  utils$1.extend(instance, context, null, {allOwnKeys: true});

  // Factory for creating new instances
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };

  return instance;
}

// Create the default instance to be exported
const axios = createInstance(defaults$1);

// Expose Axios class to allow class inheritance
axios.Axios = Axios$1;

// Expose Cancel & CancelToken
axios.CanceledError = CanceledError;
axios.CancelToken = CancelToken$1;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData;

// Expose AxiosError class
axios.AxiosError = AxiosError;

// alias for CanceledError for backward compatibility
axios.Cancel = axios.CanceledError;

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = spread;

// Expose isAxiosError
axios.isAxiosError = isAxiosError;

// Expose mergeConfig
axios.mergeConfig = mergeConfig;

axios.AxiosHeaders = AxiosHeaders$1;

axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

axios.getAdapter = adapters.getAdapter;

axios.HttpStatusCode = HttpStatusCode$1;

axios.default = axios;

module.exports = axios;
//# sourceMappingURL=axios.cjs.map


/***/ }),
/* 149 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var CombinedStream = __webpack_require__(150);
var util = __webpack_require__(20);
var path = __webpack_require__(4);
var http = __webpack_require__(152);
var https = __webpack_require__(153);
var parseUrl = (__webpack_require__(154).parse);
var fs = __webpack_require__(5);
var Stream = (__webpack_require__(18).Stream);
var mime = __webpack_require__(155);
var asynckit = __webpack_require__(158);
var setToStringTag = __webpack_require__(168);
var hasOwn = __webpack_require__(202);
var populate = __webpack_require__(204);

/**
 * Create readable "multipart/form-data" streams.
 * Can be used to submit forms
 * and file uploads to other web applications.
 *
 * @constructor
 * @param {object} options - Properties to be added/overriden for FormData and CombinedStream
 */
function FormData(options) {
  if (!(this instanceof FormData)) {
    return new FormData(options);
  }

  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];

  CombinedStream.call(this);

  options = options || {}; // eslint-disable-line no-param-reassign
  for (var option in options) { // eslint-disable-line no-restricted-syntax
    this[option] = options[option];
  }
}

// make it a Stream
util.inherits(FormData, CombinedStream);

FormData.LINE_BREAK = '\r\n';
FormData.DEFAULT_CONTENT_TYPE = 'application/octet-stream';

FormData.prototype.append = function (field, value, options) {
  options = options || {}; // eslint-disable-line no-param-reassign

  // allow filename as single option
  if (typeof options === 'string') {
    options = { filename: options }; // eslint-disable-line no-param-reassign
  }

  var append = CombinedStream.prototype.append.bind(this);

  // all that streamy business can't handle numbers
  if (typeof value === 'number' || value == null) {
    value = String(value); // eslint-disable-line no-param-reassign
  }

  // https://github.com/felixge/node-form-data/issues/38
  if (Array.isArray(value)) {
    /*
     * Please convert your array into string
     * the way web server expects it
     */
    this._error(new Error('Arrays are not supported.'));
    return;
  }

  var header = this._multiPartHeader(field, value, options);
  var footer = this._multiPartFooter();

  append(header);
  append(value);
  append(footer);

  // pass along options.knownLength
  this._trackLength(header, value, options);
};

FormData.prototype._trackLength = function (header, value, options) {
  var valueLength = 0;

  /*
   * used w/ getLengthSync(), when length is known.
   * e.g. for streaming directly from a remote server,
   * w/ a known file a size, and not wanting to wait for
   * incoming file to finish to get its size.
   */
  if (options.knownLength != null) {
    valueLength += Number(options.knownLength);
  } else if (Buffer.isBuffer(value)) {
    valueLength = value.length;
  } else if (typeof value === 'string') {
    valueLength = Buffer.byteLength(value);
  }

  this._valueLength += valueLength;

  // @check why add CRLF? does this account for custom/multiple CRLFs?
  this._overheadLength += Buffer.byteLength(header) + FormData.LINE_BREAK.length;

  // empty or either doesn't have path or not an http response or not a stream
  if (!value || (!value.path && !(value.readable && hasOwn(value, 'httpVersion')) && !(value instanceof Stream))) {
    return;
  }

  // no need to bother with the length
  if (!options.knownLength) {
    this._valuesToMeasure.push(value);
  }
};

FormData.prototype._lengthRetriever = function (value, callback) {
  if (hasOwn(value, 'fd')) {
    // take read range into a account
    // `end` = Infinity –> read file till the end
    //
    // TODO: Looks like there is bug in Node fs.createReadStream
    // it doesn't respect `end` options without `start` options
    // Fix it when node fixes it.
    // https://github.com/joyent/node/issues/7819
    if (value.end != undefined && value.end != Infinity && value.start != undefined) {
      // when end specified
      // no need to calculate range
      // inclusive, starts with 0
      callback(null, value.end + 1 - (value.start ? value.start : 0)); // eslint-disable-line callback-return

      // not that fast snoopy
    } else {
      // still need to fetch file size from fs
      fs.stat(value.path, function (err, stat) {
        if (err) {
          callback(err);
          return;
        }

        // update final size based on the range options
        var fileSize = stat.size - (value.start ? value.start : 0);
        callback(null, fileSize);
      });
    }

    // or http response
  } else if (hasOwn(value, 'httpVersion')) {
    callback(null, Number(value.headers['content-length'])); // eslint-disable-line callback-return

    // or request stream http://github.com/mikeal/request
  } else if (hasOwn(value, 'httpModule')) {
    // wait till response come back
    value.on('response', function (response) {
      value.pause();
      callback(null, Number(response.headers['content-length']));
    });
    value.resume();

    // something else
  } else {
    callback('Unknown stream'); // eslint-disable-line callback-return
  }
};

FormData.prototype._multiPartHeader = function (field, value, options) {
  /*
   * custom header specified (as string)?
   * it becomes responsible for boundary
   * (e.g. to handle extra CRLFs on .NET servers)
   */
  if (typeof options.header === 'string') {
    return options.header;
  }

  var contentDisposition = this._getContentDisposition(value, options);
  var contentType = this._getContentType(value, options);

  var contents = '';
  var headers = {
    // add custom disposition as third element or keep it two elements if not
    'Content-Disposition': ['form-data', 'name="' + field + '"'].concat(contentDisposition || []),
    // if no content type. allow it to be empty array
    'Content-Type': [].concat(contentType || [])
  };

  // allow custom headers.
  if (typeof options.header === 'object') {
    populate(headers, options.header);
  }

  var header;
  for (var prop in headers) { // eslint-disable-line no-restricted-syntax
    if (hasOwn(headers, prop)) {
      header = headers[prop];

      // skip nullish headers.
      if (header == null) {
        continue; // eslint-disable-line no-restricted-syntax, no-continue
      }

      // convert all headers to arrays.
      if (!Array.isArray(header)) {
        header = [header];
      }

      // add non-empty headers.
      if (header.length) {
        contents += prop + ': ' + header.join('; ') + FormData.LINE_BREAK;
      }
    }
  }

  return '--' + this.getBoundary() + FormData.LINE_BREAK + contents + FormData.LINE_BREAK;
};

FormData.prototype._getContentDisposition = function (value, options) { // eslint-disable-line consistent-return
  var filename;

  if (typeof options.filepath === 'string') {
    // custom filepath for relative paths
    filename = path.normalize(options.filepath).replace(/\\/g, '/');
  } else if (options.filename || (value && (value.name || value.path))) {
    /*
     * custom filename take precedence
     * formidable and the browser add a name property
     * fs- and request- streams have path property
     */
    filename = path.basename(options.filename || (value && (value.name || value.path)));
  } else if (value && value.readable && hasOwn(value, 'httpVersion')) {
    // or try http response
    filename = path.basename(value.client._httpMessage.path || '');
  }

  if (filename) {
    return 'filename="' + filename + '"';
  }
};

FormData.prototype._getContentType = function (value, options) {
  // use custom content-type above all
  var contentType = options.contentType;

  // or try `name` from formidable, browser
  if (!contentType && value && value.name) {
    contentType = mime.lookup(value.name);
  }

  // or try `path` from fs-, request- streams
  if (!contentType && value && value.path) {
    contentType = mime.lookup(value.path);
  }

  // or if it's http-reponse
  if (!contentType && value && value.readable && hasOwn(value, 'httpVersion')) {
    contentType = value.headers['content-type'];
  }

  // or guess it from the filepath or filename
  if (!contentType && (options.filepath || options.filename)) {
    contentType = mime.lookup(options.filepath || options.filename);
  }

  // fallback to the default content type if `value` is not simple value
  if (!contentType && value && typeof value === 'object') {
    contentType = FormData.DEFAULT_CONTENT_TYPE;
  }

  return contentType;
};

FormData.prototype._multiPartFooter = function () {
  return function (next) {
    var footer = FormData.LINE_BREAK;

    var lastPart = this._streams.length === 0;
    if (lastPart) {
      footer += this._lastBoundary();
    }

    next(footer);
  }.bind(this);
};

FormData.prototype._lastBoundary = function () {
  return '--' + this.getBoundary() + '--' + FormData.LINE_BREAK;
};

FormData.prototype.getHeaders = function (userHeaders) {
  var header;
  var formHeaders = {
    'content-type': 'multipart/form-data; boundary=' + this.getBoundary()
  };

  for (header in userHeaders) { // eslint-disable-line no-restricted-syntax
    if (hasOwn(userHeaders, header)) {
      formHeaders[header.toLowerCase()] = userHeaders[header];
    }
  }

  return formHeaders;
};

FormData.prototype.setBoundary = function (boundary) {
  if (typeof boundary !== 'string') {
    throw new TypeError('FormData boundary must be a string');
  }
  this._boundary = boundary;
};

FormData.prototype.getBoundary = function () {
  if (!this._boundary) {
    this._generateBoundary();
  }

  return this._boundary;
};

FormData.prototype.getBuffer = function () {
  var dataBuffer = new Buffer.alloc(0); // eslint-disable-line new-cap
  var boundary = this.getBoundary();

  // Create the form content. Add Line breaks to the end of data.
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== 'function') {
      // Add content to the buffer.
      if (Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
      } else {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
      }

      // Add break after content.
      if (typeof this._streams[i] !== 'string' || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData.LINE_BREAK)]);
      }
    }
  }

  // Add the footer and return the Buffer object.
  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
};

FormData.prototype._generateBoundary = function () {
  // This generates a 50 character boundary similar to those used by Firefox.

  // They are optimized for boyer-moore parsing.
  var boundary = '--------------------------';
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }

  this._boundary = boundary;
};

// Note: getLengthSync DOESN'T calculate streams length
// As workaround one can calculate file size manually and add it as knownLength option
FormData.prototype.getLengthSync = function () {
  var knownLength = this._overheadLength + this._valueLength;

  // Don't get confused, there are 3 "internal" streams for each keyval pair so it basically checks if there is any value added to the form
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  // https://github.com/form-data/form-data/issues/40
  if (!this.hasKnownLength()) {
    /*
     * Some async length retrievers are present
     * therefore synchronous length calculation is false.
     * Please use getLength(callback) to get proper length
     */
    this._error(new Error('Cannot calculate proper length in synchronous way.'));
  }

  return knownLength;
};

// Public API to check if length of added values is known
// https://github.com/form-data/form-data/issues/196
// https://github.com/form-data/form-data/issues/262
FormData.prototype.hasKnownLength = function () {
  var hasKnownLength = true;

  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }

  return hasKnownLength;
};

FormData.prototype.getLength = function (cb) {
  var knownLength = this._overheadLength + this._valueLength;

  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }

  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }

  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function (err, values) {
    if (err) {
      cb(err);
      return;
    }

    values.forEach(function (length) {
      knownLength += length;
    });

    cb(null, knownLength);
  });
};

FormData.prototype.submit = function (params, cb) {
  var request;
  var options;
  var defaults = { method: 'post' };

  // parse provided url if it's string or treat it as options object
  if (typeof params === 'string') {
    params = parseUrl(params); // eslint-disable-line no-param-reassign
    /* eslint sort-keys: 0 */
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults);
  } else { // use custom params
    options = populate(params, defaults);
    // if no port provided use default one
    if (!options.port) {
      options.port = options.protocol === 'https:' ? 443 : 80;
    }
  }

  // put that good code in getHeaders to some use
  options.headers = this.getHeaders(params.headers);

  // https if specified, fallback to http in any other case
  if (options.protocol === 'https:') {
    request = https.request(options);
  } else {
    request = http.request(options);
  }

  // get content length and fire away
  this.getLength(function (err, length) {
    if (err && err !== 'Unknown stream') {
      this._error(err);
      return;
    }

    // add content length
    if (length) {
      request.setHeader('Content-Length', length);
    }

    this.pipe(request);
    if (cb) {
      var onResponse;

      var callback = function (error, responce) {
        request.removeListener('error', callback);
        request.removeListener('response', onResponse);

        return cb.call(this, error, responce); // eslint-disable-line no-invalid-this
      };

      onResponse = callback.bind(this, null);

      request.on('error', callback);
      request.on('response', onResponse);
    }
  }.bind(this));

  return request;
};

FormData.prototype._error = function (err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit('error', err);
  }
};

FormData.prototype.toString = function () {
  return '[object FormData]';
};
setToStringTag(FormData, 'FormData');

// Public API
module.exports = FormData;


/***/ }),
/* 150 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var util = __webpack_require__(20);
var Stream = (__webpack_require__(18).Stream);
var DelayedStream = __webpack_require__(151);

module.exports = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};


/***/ }),
/* 151 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stream = (__webpack_require__(18).Stream);
var util = __webpack_require__(20);

module.exports = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util.inherits(DelayedStream, Stream);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.'
  this.emit('error', new Error(message));
};


/***/ }),
/* 152 */
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),
/* 153 */
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),
/* 154 */
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),
/* 155 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */



/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(156)
var extname = (__webpack_require__(4).extname)

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/
var TEXT_TYPE_REGEXP = /^text\//i

/**
 * Module exports.
 * @public
 */

exports.charset = charset
exports.charsets = { lookup: charset }
exports.contentType = contentType
exports.extension = extension
exports.extensions = Object.create(null)
exports.lookup = lookup
exports.types = Object.create(null)

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types)

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)
  var mime = match && db[match[1].toLowerCase()]

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime)
    if (charset) mime += '; charset=' + charset.toLowerCase()
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type)

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()]

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1)

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana']

  Object.keys(db).forEach(function forEachMimeType (type) {
    var mime = db[type]
    var exts = mime.extensions

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i]

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source)
        var to = preference.indexOf(mime.source)

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type
    }
  })
}


/***/ }),
/* 156 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = __webpack_require__(157)


/***/ }),
/* 157 */
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),
/* 158 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports =
{
  parallel      : __webpack_require__(159),
  serial        : __webpack_require__(166),
  serialOrdered : __webpack_require__(167)
};


/***/ }),
/* 159 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(160)
  , initState  = __webpack_require__(164)
  , terminator = __webpack_require__(165)
  ;

// Public API
module.exports = parallel;

/**
 * Runs iterator over provided array elements in parallel
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function parallel(list, iterator, callback)
{
  var state = initState(list);

  while (state.index < (state['keyedList'] || list).length)
  {
    iterate(list, iterator, state, function(error, result)
    {
      if (error)
      {
        callback(error, result);
        return;
      }

      // looks like it's the last one
      if (Object.keys(state.jobs).length === 0)
      {
        callback(null, state.results);
        return;
      }
    });

    state.index++;
  }

  return terminator.bind(state, callback);
}


/***/ }),
/* 160 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var async = __webpack_require__(161)
  , abort = __webpack_require__(163)
  ;

// API
module.exports = iterate;

/**
 * Iterates over each job object
 *
 * @param {array|object} list - array or object (named list) to iterate over
 * @param {function} iterator - iterator to run
 * @param {object} state - current job status
 * @param {function} callback - invoked when all elements processed
 */
function iterate(list, iterator, state, callback)
{
  // store current index
  var key = state['keyedList'] ? state['keyedList'][state.index] : state.index;

  state.jobs[key] = runJob(iterator, key, list[key], function(error, output)
  {
    // don't repeat yourself
    // skip secondary callbacks
    if (!(key in state.jobs))
    {
      return;
    }

    // clean up jobs
    delete state.jobs[key];

    if (error)
    {
      // don't process rest of the results
      // stop still active jobs
      // and reset the list
      abort(state);
    }
    else
    {
      state.results[key] = output;
    }

    // return salvaged results
    callback(error, state.results);
  });
}

/**
 * Runs iterator over provided job element
 *
 * @param   {function} iterator - iterator to invoke
 * @param   {string|number} key - key/index of the element in the list of jobs
 * @param   {mixed} item - job description
 * @param   {function} callback - invoked after iterator is done with the job
 * @returns {function|mixed} - job abort function or something else
 */
function runJob(iterator, key, item, callback)
{
  var aborter;

  // allow shortcut if iterator expects only two arguments
  if (iterator.length == 2)
  {
    aborter = iterator(item, async(callback));
  }
  // otherwise go with full three arguments
  else
  {
    aborter = iterator(item, key, async(callback));
  }

  return aborter;
}


/***/ }),
/* 161 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var defer = __webpack_require__(162);

// API
module.exports = async;

/**
 * Runs provided callback asynchronously
 * even if callback itself is not
 *
 * @param   {function} callback - callback to invoke
 * @returns {function} - augmented callback
 */
function async(callback)
{
  var isAsync = false;

  // check if async happened
  defer(function() { isAsync = true; });

  return function async_callback(err, result)
  {
    if (isAsync)
    {
      callback(err, result);
    }
    else
    {
      defer(function nextTick_callback()
      {
        callback(err, result);
      });
    }
  };
}


/***/ }),
/* 162 */
/***/ ((module) => {

module.exports = defer;

/**
 * Runs provided function on next iteration of the event loop
 *
 * @param {function} fn - function to run
 */
function defer(fn)
{
  var nextTick = typeof setImmediate == 'function'
    ? setImmediate
    : (
      typeof process == 'object' && typeof process.nextTick == 'function'
      ? process.nextTick
      : null
    );

  if (nextTick)
  {
    nextTick(fn);
  }
  else
  {
    setTimeout(fn, 0);
  }
}


/***/ }),
/* 163 */
/***/ ((module) => {

// API
module.exports = abort;

/**
 * Aborts leftover active jobs
 *
 * @param {object} state - current state object
 */
function abort(state)
{
  Object.keys(state.jobs).forEach(clean.bind(state));

  // reset leftover jobs
  state.jobs = {};
}

/**
 * Cleans up leftover job by invoking abort function for the provided job id
 *
 * @this  state
 * @param {string|number} key - job id to abort
 */
function clean(key)
{
  if (typeof this.jobs[key] == 'function')
  {
    this.jobs[key]();
  }
}


/***/ }),
/* 164 */
/***/ ((module) => {

// API
module.exports = state;

/**
 * Creates initial state object
 * for iteration over list
 *
 * @param   {array|object} list - list to iterate over
 * @param   {function|null} sortMethod - function to use for keys sort,
 *                                     or `null` to keep them as is
 * @returns {object} - initial state object
 */
function state(list, sortMethod)
{
  var isNamedList = !Array.isArray(list)
    , initState =
    {
      index    : 0,
      keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
      jobs     : {},
      results  : isNamedList ? {} : [],
      size     : isNamedList ? Object.keys(list).length : list.length
    }
    ;

  if (sortMethod)
  {
    // sort array keys based on it's values
    // sort object's keys just on own merit
    initState.keyedList.sort(isNamedList ? sortMethod : function(a, b)
    {
      return sortMethod(list[a], list[b]);
    });
  }

  return initState;
}


/***/ }),
/* 165 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var abort = __webpack_require__(163)
  , async = __webpack_require__(161)
  ;

// API
module.exports = terminator;

/**
 * Terminates jobs in the attached state context
 *
 * @this  AsyncKitState#
 * @param {function} callback - final callback to invoke after termination
 */
function terminator(callback)
{
  if (!Object.keys(this.jobs).length)
  {
    return;
  }

  // fast forward iteration index
  this.index = this.size;

  // abort jobs
  abort(this);

  // send back results we have so far
  async(callback)(null, this.results);
}


/***/ }),
/* 166 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var serialOrdered = __webpack_require__(167);

// Public API
module.exports = serial;

/**
 * Runs iterator over provided array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serial(list, iterator, callback)
{
  return serialOrdered(list, iterator, null, callback);
}


/***/ }),
/* 167 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var iterate    = __webpack_require__(160)
  , initState  = __webpack_require__(164)
  , terminator = __webpack_require__(165)
  ;

// Public API
module.exports = serialOrdered;
// sorting helpers
module.exports.ascending  = ascending;
module.exports.descending = descending;

/**
 * Runs iterator over provided sorted array elements in series
 *
 * @param   {array|object} list - array or object (named list) to iterate over
 * @param   {function} iterator - iterator to run
 * @param   {function} sortMethod - custom sort function
 * @param   {function} callback - invoked when all elements processed
 * @returns {function} - jobs terminator
 */
function serialOrdered(list, iterator, sortMethod, callback)
{
  var state = initState(list, sortMethod);

  iterate(list, iterator, state, function iteratorHandler(error, result)
  {
    if (error)
    {
      callback(error, result);
      return;
    }

    state.index++;

    // are we there yet?
    if (state.index < (state['keyedList'] || list).length)
    {
      iterate(list, iterator, state, iteratorHandler);
      return;
    }

    // done here
    callback(null, state.results);
  });

  return terminator.bind(state, callback);
}

/*
 * -- Sort methods
 */

/**
 * sort helper to sort array elements in ascending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function ascending(a, b)
{
  return a < b ? -1 : a > b ? 1 : 0;
}

/**
 * sort helper to sort array elements in descending order
 *
 * @param   {mixed} a - an item to compare
 * @param   {mixed} b - an item to compare
 * @returns {number} - comparison result
 */
function descending(a, b)
{
  return -1 * ascending(a, b);
}


/***/ }),
/* 168 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var GetIntrinsic = __webpack_require__(169);

var $defineProperty = GetIntrinsic('%Object.defineProperty%', true);

var hasToStringTag = __webpack_require__(203)();
var hasOwn = __webpack_require__(202);
var $TypeError = __webpack_require__(176);

var toStringTag = hasToStringTag ? Symbol.toStringTag : null;

/** @type {import('.')} */
module.exports = function setToStringTag(object, value) {
	var overrideIfSet = arguments.length > 2 && !!arguments[2] && arguments[2].force;
	var nonConfigurable = arguments.length > 2 && !!arguments[2] && arguments[2].nonConfigurable;
	if (
		(typeof overrideIfSet !== 'undefined' && typeof overrideIfSet !== 'boolean')
		|| (typeof nonConfigurable !== 'undefined' && typeof nonConfigurable !== 'boolean')
	) {
		throw new $TypeError('if provided, the `overrideIfSet` and `nonConfigurable` options must be booleans');
	}
	if (toStringTag && (overrideIfSet || !hasOwn(object, toStringTag))) {
		if ($defineProperty) {
			$defineProperty(object, toStringTag, {
				configurable: !nonConfigurable,
				enumerable: false,
				value: value,
				writable: false
			});
		} else {
			object[toStringTag] = value; // eslint-disable-line no-param-reassign
		}
	}
};


/***/ }),
/* 169 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var undefined;

var $Object = __webpack_require__(170);

var $Error = __webpack_require__(171);
var $EvalError = __webpack_require__(172);
var $RangeError = __webpack_require__(173);
var $ReferenceError = __webpack_require__(174);
var $SyntaxError = __webpack_require__(175);
var $TypeError = __webpack_require__(176);
var $URIError = __webpack_require__(177);

var abs = __webpack_require__(178);
var floor = __webpack_require__(179);
var max = __webpack_require__(180);
var min = __webpack_require__(181);
var pow = __webpack_require__(182);
var round = __webpack_require__(183);
var sign = __webpack_require__(184);

var $Function = Function;

// eslint-disable-next-line consistent-return
var getEvalledConstructor = function (expressionSyntax) {
	try {
		return $Function('"use strict"; return (' + expressionSyntax + ').constructor;')();
	} catch (e) {}
};

var $gOPD = __webpack_require__(186);
var $defineProperty = __webpack_require__(188);

var throwTypeError = function () {
	throw new $TypeError();
};
var ThrowTypeError = $gOPD
	? (function () {
		try {
			// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties
			arguments.callee; // IE 8 does not throw here
			return throwTypeError;
		} catch (calleeThrows) {
			try {
				// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')
				return $gOPD(arguments, 'callee').get;
			} catch (gOPDthrows) {
				return throwTypeError;
			}
		}
	}())
	: throwTypeError;

var hasSymbols = __webpack_require__(189)();

var getProto = __webpack_require__(191);
var $ObjectGPO = __webpack_require__(193);
var $ReflectGPO = __webpack_require__(192);

var $apply = __webpack_require__(200);
var $call = __webpack_require__(198);

var needsEval = {};

var TypedArray = typeof Uint8Array === 'undefined' || !getProto ? undefined : getProto(Uint8Array);

var INTRINSICS = {
	__proto__: null,
	'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,
	'%Array%': Array,
	'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,
	'%ArrayIteratorPrototype%': hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined,
	'%AsyncFromSyncIteratorPrototype%': undefined,
	'%AsyncFunction%': needsEval,
	'%AsyncGenerator%': needsEval,
	'%AsyncGeneratorFunction%': needsEval,
	'%AsyncIteratorPrototype%': needsEval,
	'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,
	'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,
	'%BigInt64Array%': typeof BigInt64Array === 'undefined' ? undefined : BigInt64Array,
	'%BigUint64Array%': typeof BigUint64Array === 'undefined' ? undefined : BigUint64Array,
	'%Boolean%': Boolean,
	'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,
	'%Date%': Date,
	'%decodeURI%': decodeURI,
	'%decodeURIComponent%': decodeURIComponent,
	'%encodeURI%': encodeURI,
	'%encodeURIComponent%': encodeURIComponent,
	'%Error%': $Error,
	'%eval%': eval, // eslint-disable-line no-eval
	'%EvalError%': $EvalError,
	'%Float16Array%': typeof Float16Array === 'undefined' ? undefined : Float16Array,
	'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,
	'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,
	'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,
	'%Function%': $Function,
	'%GeneratorFunction%': needsEval,
	'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,
	'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,
	'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,
	'%isFinite%': isFinite,
	'%isNaN%': isNaN,
	'%IteratorPrototype%': hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined,
	'%JSON%': typeof JSON === 'object' ? JSON : undefined,
	'%Map%': typeof Map === 'undefined' ? undefined : Map,
	'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Map()[Symbol.iterator]()),
	'%Math%': Math,
	'%Number%': Number,
	'%Object%': $Object,
	'%Object.getOwnPropertyDescriptor%': $gOPD,
	'%parseFloat%': parseFloat,
	'%parseInt%': parseInt,
	'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,
	'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,
	'%RangeError%': $RangeError,
	'%ReferenceError%': $ReferenceError,
	'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,
	'%RegExp%': RegExp,
	'%Set%': typeof Set === 'undefined' ? undefined : Set,
	'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols || !getProto ? undefined : getProto(new Set()[Symbol.iterator]()),
	'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,
	'%String%': String,
	'%StringIteratorPrototype%': hasSymbols && getProto ? getProto(''[Symbol.iterator]()) : undefined,
	'%Symbol%': hasSymbols ? Symbol : undefined,
	'%SyntaxError%': $SyntaxError,
	'%ThrowTypeError%': ThrowTypeError,
	'%TypedArray%': TypedArray,
	'%TypeError%': $TypeError,
	'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,
	'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,
	'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,
	'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,
	'%URIError%': $URIError,
	'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,
	'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,
	'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet,

	'%Function.prototype.call%': $call,
	'%Function.prototype.apply%': $apply,
	'%Object.defineProperty%': $defineProperty,
	'%Object.getPrototypeOf%': $ObjectGPO,
	'%Math.abs%': abs,
	'%Math.floor%': floor,
	'%Math.max%': max,
	'%Math.min%': min,
	'%Math.pow%': pow,
	'%Math.round%': round,
	'%Math.sign%': sign,
	'%Reflect.getPrototypeOf%': $ReflectGPO
};

if (getProto) {
	try {
		null.error; // eslint-disable-line no-unused-expressions
	} catch (e) {
		// https://github.com/tc39/proposal-shadowrealm/pull/384#issuecomment-1364264229
		var errorProto = getProto(getProto(e));
		INTRINSICS['%Error.prototype%'] = errorProto;
	}
}

var doEval = function doEval(name) {
	var value;
	if (name === '%AsyncFunction%') {
		value = getEvalledConstructor('async function () {}');
	} else if (name === '%GeneratorFunction%') {
		value = getEvalledConstructor('function* () {}');
	} else if (name === '%AsyncGeneratorFunction%') {
		value = getEvalledConstructor('async function* () {}');
	} else if (name === '%AsyncGenerator%') {
		var fn = doEval('%AsyncGeneratorFunction%');
		if (fn) {
			value = fn.prototype;
		}
	} else if (name === '%AsyncIteratorPrototype%') {
		var gen = doEval('%AsyncGenerator%');
		if (gen && getProto) {
			value = getProto(gen.prototype);
		}
	}

	INTRINSICS[name] = value;

	return value;
};

var LEGACY_ALIASES = {
	__proto__: null,
	'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],
	'%ArrayPrototype%': ['Array', 'prototype'],
	'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],
	'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],
	'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],
	'%ArrayProto_values%': ['Array', 'prototype', 'values'],
	'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],
	'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],
	'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],
	'%BooleanPrototype%': ['Boolean', 'prototype'],
	'%DataViewPrototype%': ['DataView', 'prototype'],
	'%DatePrototype%': ['Date', 'prototype'],
	'%ErrorPrototype%': ['Error', 'prototype'],
	'%EvalErrorPrototype%': ['EvalError', 'prototype'],
	'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],
	'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],
	'%FunctionPrototype%': ['Function', 'prototype'],
	'%Generator%': ['GeneratorFunction', 'prototype'],
	'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],
	'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],
	'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],
	'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],
	'%JSONParse%': ['JSON', 'parse'],
	'%JSONStringify%': ['JSON', 'stringify'],
	'%MapPrototype%': ['Map', 'prototype'],
	'%NumberPrototype%': ['Number', 'prototype'],
	'%ObjectPrototype%': ['Object', 'prototype'],
	'%ObjProto_toString%': ['Object', 'prototype', 'toString'],
	'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],
	'%PromisePrototype%': ['Promise', 'prototype'],
	'%PromiseProto_then%': ['Promise', 'prototype', 'then'],
	'%Promise_all%': ['Promise', 'all'],
	'%Promise_reject%': ['Promise', 'reject'],
	'%Promise_resolve%': ['Promise', 'resolve'],
	'%RangeErrorPrototype%': ['RangeError', 'prototype'],
	'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],
	'%RegExpPrototype%': ['RegExp', 'prototype'],
	'%SetPrototype%': ['Set', 'prototype'],
	'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],
	'%StringPrototype%': ['String', 'prototype'],
	'%SymbolPrototype%': ['Symbol', 'prototype'],
	'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],
	'%TypedArrayPrototype%': ['TypedArray', 'prototype'],
	'%TypeErrorPrototype%': ['TypeError', 'prototype'],
	'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],
	'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],
	'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],
	'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],
	'%URIErrorPrototype%': ['URIError', 'prototype'],
	'%WeakMapPrototype%': ['WeakMap', 'prototype'],
	'%WeakSetPrototype%': ['WeakSet', 'prototype']
};

var bind = __webpack_require__(196);
var hasOwn = __webpack_require__(202);
var $concat = bind.call($call, Array.prototype.concat);
var $spliceApply = bind.call($apply, Array.prototype.splice);
var $replace = bind.call($call, String.prototype.replace);
var $strSlice = bind.call($call, String.prototype.slice);
var $exec = bind.call($call, RegExp.prototype.exec);

/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */
var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
var reEscapeChar = /\\(\\)?/g; /** Used to match backslashes in property paths. */
var stringToPath = function stringToPath(string) {
	var first = $strSlice(string, 0, 1);
	var last = $strSlice(string, -1);
	if (first === '%' && last !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected closing `%`');
	} else if (last === '%' && first !== '%') {
		throw new $SyntaxError('invalid intrinsic syntax, expected opening `%`');
	}
	var result = [];
	$replace(string, rePropName, function (match, number, quote, subString) {
		result[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;
	});
	return result;
};
/* end adaptation */

var getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {
	var intrinsicName = name;
	var alias;
	if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
		alias = LEGACY_ALIASES[intrinsicName];
		intrinsicName = '%' + alias[0] + '%';
	}

	if (hasOwn(INTRINSICS, intrinsicName)) {
		var value = INTRINSICS[intrinsicName];
		if (value === needsEval) {
			value = doEval(intrinsicName);
		}
		if (typeof value === 'undefined' && !allowMissing) {
			throw new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');
		}

		return {
			alias: alias,
			name: intrinsicName,
			value: value
		};
	}

	throw new $SyntaxError('intrinsic ' + name + ' does not exist!');
};

module.exports = function GetIntrinsic(name, allowMissing) {
	if (typeof name !== 'string' || name.length === 0) {
		throw new $TypeError('intrinsic name must be a non-empty string');
	}
	if (arguments.length > 1 && typeof allowMissing !== 'boolean') {
		throw new $TypeError('"allowMissing" argument must be a boolean');
	}

	if ($exec(/^%?[^%]*%?$/, name) === null) {
		throw new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');
	}
	var parts = stringToPath(name);
	var intrinsicBaseName = parts.length > 0 ? parts[0] : '';

	var intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);
	var intrinsicRealName = intrinsic.name;
	var value = intrinsic.value;
	var skipFurtherCaching = false;

	var alias = intrinsic.alias;
	if (alias) {
		intrinsicBaseName = alias[0];
		$spliceApply(parts, $concat([0, 1], alias));
	}

	for (var i = 1, isOwn = true; i < parts.length; i += 1) {
		var part = parts[i];
		var first = $strSlice(part, 0, 1);
		var last = $strSlice(part, -1);
		if (
			(
				(first === '"' || first === "'" || first === '`')
				|| (last === '"' || last === "'" || last === '`')
			)
			&& first !== last
		) {
			throw new $SyntaxError('property names with quotes must have matching quotes');
		}
		if (part === 'constructor' || !isOwn) {
			skipFurtherCaching = true;
		}

		intrinsicBaseName += '.' + part;
		intrinsicRealName = '%' + intrinsicBaseName + '%';

		if (hasOwn(INTRINSICS, intrinsicRealName)) {
			value = INTRINSICS[intrinsicRealName];
		} else if (value != null) {
			if (!(part in value)) {
				if (!allowMissing) {
					throw new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');
				}
				return void undefined;
			}
			if ($gOPD && (i + 1) >= parts.length) {
				var desc = $gOPD(value, part);
				isOwn = !!desc;

				// By convention, when a data property is converted to an accessor
				// property to emulate a data property that does not suffer from
				// the override mistake, that accessor's getter is marked with
				// an `originalValue` property. Here, when we detect this, we
				// uphold the illusion by pretending to see that original data
				// property, i.e., returning the value rather than the getter
				// itself.
				if (isOwn && 'get' in desc && !('originalValue' in desc.get)) {
					value = desc.get;
				} else {
					value = value[part];
				}
			} else {
				isOwn = hasOwn(value, part);
				value = value[part];
			}

			if (isOwn && !skipFurtherCaching) {
				INTRINSICS[intrinsicRealName] = value;
			}
		}
	}
	return value;
};


/***/ }),
/* 170 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Object;


/***/ }),
/* 171 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
module.exports = Error;


/***/ }),
/* 172 */
/***/ ((module) => {

"use strict";


/** @type {import('./eval')} */
module.exports = EvalError;


/***/ }),
/* 173 */
/***/ ((module) => {

"use strict";


/** @type {import('./range')} */
module.exports = RangeError;


/***/ }),
/* 174 */
/***/ ((module) => {

"use strict";


/** @type {import('./ref')} */
module.exports = ReferenceError;


/***/ }),
/* 175 */
/***/ ((module) => {

"use strict";


/** @type {import('./syntax')} */
module.exports = SyntaxError;


/***/ }),
/* 176 */
/***/ ((module) => {

"use strict";


/** @type {import('./type')} */
module.exports = TypeError;


/***/ }),
/* 177 */
/***/ ((module) => {

"use strict";


/** @type {import('./uri')} */
module.exports = URIError;


/***/ }),
/* 178 */
/***/ ((module) => {

"use strict";


/** @type {import('./abs')} */
module.exports = Math.abs;


/***/ }),
/* 179 */
/***/ ((module) => {

"use strict";


/** @type {import('./floor')} */
module.exports = Math.floor;


/***/ }),
/* 180 */
/***/ ((module) => {

"use strict";


/** @type {import('./max')} */
module.exports = Math.max;


/***/ }),
/* 181 */
/***/ ((module) => {

"use strict";


/** @type {import('./min')} */
module.exports = Math.min;


/***/ }),
/* 182 */
/***/ ((module) => {

"use strict";


/** @type {import('./pow')} */
module.exports = Math.pow;


/***/ }),
/* 183 */
/***/ ((module) => {

"use strict";


/** @type {import('./round')} */
module.exports = Math.round;


/***/ }),
/* 184 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $isNaN = __webpack_require__(185);

/** @type {import('./sign')} */
module.exports = function sign(number) {
	if ($isNaN(number) || number === 0) {
		return number;
	}
	return number < 0 ? -1 : +1;
};


/***/ }),
/* 185 */
/***/ ((module) => {

"use strict";


/** @type {import('./isNaN')} */
module.exports = Number.isNaN || function isNaN(a) {
	return a !== a;
};


/***/ }),
/* 186 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/** @type {import('.')} */
var $gOPD = __webpack_require__(187);

if ($gOPD) {
	try {
		$gOPD([], 'length');
	} catch (e) {
		// IE 8 has a broken gOPD
		$gOPD = null;
	}
}

module.exports = $gOPD;


/***/ }),
/* 187 */
/***/ ((module) => {

"use strict";


/** @type {import('./gOPD')} */
module.exports = Object.getOwnPropertyDescriptor;


/***/ }),
/* 188 */
/***/ ((module) => {

"use strict";


/** @type {import('.')} */
var $defineProperty = Object.defineProperty || false;
if ($defineProperty) {
	try {
		$defineProperty({}, 'a', { value: 1 });
	} catch (e) {
		// IE 8 has a broken defineProperty
		$defineProperty = false;
	}
}

module.exports = $defineProperty;


/***/ }),
/* 189 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var origSymbol = typeof Symbol !== 'undefined' && Symbol;
var hasSymbolSham = __webpack_require__(190);

/** @type {import('.')} */
module.exports = function hasNativeSymbols() {
	if (typeof origSymbol !== 'function') { return false; }
	if (typeof Symbol !== 'function') { return false; }
	if (typeof origSymbol('foo') !== 'symbol') { return false; }
	if (typeof Symbol('bar') !== 'symbol') { return false; }

	return hasSymbolSham();
};


/***/ }),
/* 190 */
/***/ ((module) => {

"use strict";


/** @type {import('./shams')} */
/* eslint complexity: [2, 18], max-statements: [2, 33] */
module.exports = function hasSymbols() {
	if (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }
	if (typeof Symbol.iterator === 'symbol') { return true; }

	/** @type {{ [k in symbol]?: unknown }} */
	var obj = {};
	var sym = Symbol('test');
	var symObj = Object(sym);
	if (typeof sym === 'string') { return false; }

	if (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }
	if (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }

	// temp disabled per https://github.com/ljharb/object.assign/issues/17
	// if (sym instanceof Symbol) { return false; }
	// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4
	// if (!(symObj instanceof Symbol)) { return false; }

	// if (typeof Symbol.prototype.toString !== 'function') { return false; }
	// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }

	var symVal = 42;
	obj[sym] = symVal;
	for (var _ in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop
	if (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }

	if (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }

	var syms = Object.getOwnPropertySymbols(obj);
	if (syms.length !== 1 || syms[0] !== sym) { return false; }

	if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }

	if (typeof Object.getOwnPropertyDescriptor === 'function') {
		// eslint-disable-next-line no-extra-parens
		var descriptor = /** @type {PropertyDescriptor} */ (Object.getOwnPropertyDescriptor(obj, sym));
		if (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }
	}

	return true;
};


/***/ }),
/* 191 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var reflectGetProto = __webpack_require__(192);
var originalGetProto = __webpack_require__(193);

var getDunderProto = __webpack_require__(194);

/** @type {import('.')} */
module.exports = reflectGetProto
	? function getProto(O) {
		// @ts-expect-error TS can't narrow inside a closure, for some reason
		return reflectGetProto(O);
	}
	: originalGetProto
		? function getProto(O) {
			if (!O || (typeof O !== 'object' && typeof O !== 'function')) {
				throw new TypeError('getProto: not an object');
			}
			// @ts-expect-error TS can't narrow inside a closure, for some reason
			return originalGetProto(O);
		}
		: getDunderProto
			? function getProto(O) {
				// @ts-expect-error TS can't narrow inside a closure, for some reason
				return getDunderProto(O);
			}
			: null;


/***/ }),
/* 192 */
/***/ ((module) => {

"use strict";


/** @type {import('./Reflect.getPrototypeOf')} */
module.exports = (typeof Reflect !== 'undefined' && Reflect.getPrototypeOf) || null;


/***/ }),
/* 193 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var $Object = __webpack_require__(170);

/** @type {import('./Object.getPrototypeOf')} */
module.exports = $Object.getPrototypeOf || null;


/***/ }),
/* 194 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var callBind = __webpack_require__(195);
var gOPD = __webpack_require__(186);

var hasProtoAccessor;
try {
	// eslint-disable-next-line no-extra-parens, no-proto
	hasProtoAccessor = /** @type {{ __proto__?: typeof Array.prototype }} */ ([]).__proto__ === Array.prototype;
} catch (e) {
	if (!e || typeof e !== 'object' || !('code' in e) || e.code !== 'ERR_PROTO_ACCESS') {
		throw e;
	}
}

// eslint-disable-next-line no-extra-parens
var desc = !!hasProtoAccessor && gOPD && gOPD(Object.prototype, /** @type {keyof typeof Object.prototype} */ ('__proto__'));

var $Object = Object;
var $getPrototypeOf = $Object.getPrototypeOf;

/** @type {import('./get')} */
module.exports = desc && typeof desc.get === 'function'
	? callBind([desc.get])
	: typeof $getPrototypeOf === 'function'
		? /** @type {import('./get')} */ function getDunder(value) {
			// eslint-disable-next-line eqeqeq
			return $getPrototypeOf(value == null ? value : $Object(value));
		}
		: false;


/***/ }),
/* 195 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(196);
var $TypeError = __webpack_require__(176);

var $call = __webpack_require__(198);
var $actualApply = __webpack_require__(199);

/** @type {(args: [Function, thisArg?: unknown, ...args: unknown[]]) => Function} TODO FIXME, find a way to use import('.') */
module.exports = function callBindBasic(args) {
	if (args.length < 1 || typeof args[0] !== 'function') {
		throw new $TypeError('a function is required');
	}
	return $actualApply(bind, $call, args);
};


/***/ }),
/* 196 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var implementation = __webpack_require__(197);

module.exports = Function.prototype.bind || implementation;


/***/ }),
/* 197 */
/***/ ((module) => {

"use strict";


/* eslint no-invalid-this: 1 */

var ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';
var toStr = Object.prototype.toString;
var max = Math.max;
var funcType = '[object Function]';

var concatty = function concatty(a, b) {
    var arr = [];

    for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
    }
    for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
    }

    return arr;
};

var slicy = function slicy(arrLike, offset) {
    var arr = [];
    for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
    }
    return arr;
};

var joiny = function (arr, joiner) {
    var str = '';
    for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
            str += joiner;
        }
    }
    return str;
};

module.exports = function bind(that) {
    var target = this;
    if (typeof target !== 'function' || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);

    var bound;
    var binder = function () {
        if (this instanceof bound) {
            var result = target.apply(
                this,
                concatty(args, arguments)
            );
            if (Object(result) === result) {
                return result;
            }
            return this;
        }
        return target.apply(
            that,
            concatty(args, arguments)
        );

    };

    var boundLength = max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = '$' + i;
    }

    bound = Function('binder', 'return function (' + joiny(boundArgs, ',') + '){ return binder.apply(this,arguments); }')(binder);

    if (target.prototype) {
        var Empty = function Empty() {};
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
    }

    return bound;
};


/***/ }),
/* 198 */
/***/ ((module) => {

"use strict";


/** @type {import('./functionCall')} */
module.exports = Function.prototype.call;


/***/ }),
/* 199 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var bind = __webpack_require__(196);

var $apply = __webpack_require__(200);
var $call = __webpack_require__(198);
var $reflectApply = __webpack_require__(201);

/** @type {import('./actualApply')} */
module.exports = $reflectApply || bind.call($call, $apply);


/***/ }),
/* 200 */
/***/ ((module) => {

"use strict";


/** @type {import('./functionApply')} */
module.exports = Function.prototype.apply;


/***/ }),
/* 201 */
/***/ ((module) => {

"use strict";


/** @type {import('./reflectApply')} */
module.exports = typeof Reflect !== 'undefined' && Reflect && Reflect.apply;


/***/ }),
/* 202 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var call = Function.prototype.call;
var $hasOwn = Object.prototype.hasOwnProperty;
var bind = __webpack_require__(196);

/** @type {import('.')} */
module.exports = bind.call(call, $hasOwn);


/***/ }),
/* 203 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


var hasSymbols = __webpack_require__(190);

/** @type {import('.')} */
module.exports = function hasToStringTagShams() {
	return hasSymbols() && !!Symbol.toStringTag;
};


/***/ }),
/* 204 */
/***/ ((module) => {

"use strict";


// populates missing values
module.exports = function (dst, src) {
  Object.keys(src).forEach(function (prop) {
    dst[prop] = dst[prop] || src[prop]; // eslint-disable-line no-param-reassign
  });

  return dst;
};


/***/ }),
/* 205 */
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var parseUrl = (__webpack_require__(154).parse);

var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443,
};

var stringEndsWith = String.prototype.endsWith || function(s) {
  return s.length <= this.length &&
    this.indexOf(s, this.length - s.length) !== -1;
};

/**
 * @param {string|object} url - The URL, or the result from url.parse.
 * @return {string} The URL of the proxy that should handle the request to the
 *  given URL. If no proxy is set, this will be an empty string.
 */
function getProxyForUrl(url) {
  var parsedUrl = typeof url === 'string' ? parseUrl(url) : url || {};
  var proto = parsedUrl.protocol;
  var hostname = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname !== 'string' || !hostname || typeof proto !== 'string') {
    return '';  // Don't proxy URLs without a valid scheme or host.
  }

  proto = proto.split(':', 1)[0];
  // Stripping ports in this way instead of using parsedUrl.hostname to make
  // sure that the brackets around IPv6 addresses are kept.
  hostname = hostname.replace(/:\d*$/, '');
  port = parseInt(port) || DEFAULT_PORTS[proto] || 0;
  if (!shouldProxy(hostname, port)) {
    return '';  // Don't proxy URLs that match NO_PROXY.
  }

  var proxy =
    getEnv('npm_config_' + proto + '_proxy') ||
    getEnv(proto + '_proxy') ||
    getEnv('npm_config_proxy') ||
    getEnv('all_proxy');
  if (proxy && proxy.indexOf('://') === -1) {
    // Missing scheme in proxy, default to the requested URL's scheme.
    proxy = proto + '://' + proxy;
  }
  return proxy;
}

/**
 * Determines whether a given URL should be proxied.
 *
 * @param {string} hostname - The host name of the URL.
 * @param {number} port - The effective port of the URL.
 * @returns {boolean} Whether the given URL should be proxied.
 * @private
 */
function shouldProxy(hostname, port) {
  var NO_PROXY =
    (getEnv('npm_config_no_proxy') || getEnv('no_proxy')).toLowerCase();
  if (!NO_PROXY) {
    return true;  // Always proxy if NO_PROXY is not set.
  }
  if (NO_PROXY === '*') {
    return false;  // Never proxy if wildcard is set.
  }

  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;  // Skip zero-length hosts.
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;  // Skip if ports don't match.
    }

    if (!/^[.*]/.test(parsedProxyHostname)) {
      // No wildcards, so stop proxying if there is an exact match.
      return hostname !== parsedProxyHostname;
    }

    if (parsedProxyHostname.charAt(0) === '*') {
      // Remove leading wildcard.
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    // Stop proxying if the hostname ends with the no_proxy host.
    return !stringEndsWith.call(hostname, parsedProxyHostname);
  });
}

/**
 * Get the value for an environment variable.
 *
 * @param {string} key - The name of the environment variable.
 * @return {string} The value of the environment variable.
 * @private
 */
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || '';
}

exports.getProxyForUrl = getProxyForUrl;


/***/ }),
/* 206 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var url = __webpack_require__(154);
var URL = url.URL;
var http = __webpack_require__(152);
var https = __webpack_require__(153);
var Writable = (__webpack_require__(18).Writable);
var assert = __webpack_require__(21);
var debug = __webpack_require__(207);

// Preventive platform detection
// istanbul ignore next
(function detectUnsupportedEnvironment() {
  var looksLikeNode = typeof process !== "undefined";
  var looksLikeBrowser = typeof window !== "undefined" && typeof document !== "undefined";
  var looksLikeV8 = isFunction(Error.captureStackTrace);
  if (!looksLikeNode && (looksLikeBrowser || !looksLikeV8)) {
    console.warn("The follow-redirects package should be excluded from browser builds.");
  }
}());

// Whether to use the native URL object or the legacy url module
var useNativeURL = false;
try {
  assert(new URL(""));
}
catch (error) {
  useNativeURL = error.code === "ERR_INVALID_URL";
}

// URL fields to preserve in copy operations
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash",
];

// Create handlers that pass events from native requests
var events = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = Object.create(null);
events.forEach(function (event) {
  eventHandlers[event] = function (arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});

// Error types with codes
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);

// istanbul ignore next
var destroy = Writable.prototype.destroy || noop;

// An HTTP(S) request that can be redirected
function RedirectableRequest(options, responseCallback) {
  // Initialize the request
  Writable.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];

  // Attach a callback if passed
  if (responseCallback) {
    this.on("response", responseCallback);
  }

  // React to responses of native requests
  var self = this;
  this._onNativeResponse = function (response) {
    try {
      self._processResponse(response);
    }
    catch (cause) {
      self.emit("error", cause instanceof RedirectionError ?
        cause : new RedirectionError({ cause: cause }));
    }
  };

  // Perform the first request
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable.prototype);

RedirectableRequest.prototype.abort = function () {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};

RedirectableRequest.prototype.destroy = function (error) {
  destroyRequest(this._currentRequest, error);
  destroy.call(this, error);
  return this;
};

// Writes buffered data to the current native request
RedirectableRequest.prototype.write = function (data, encoding, callback) {
  // Writing is not allowed if end has been called
  if (this._ending) {
    throw new WriteAfterEndError();
  }

  // Validate input and shift parameters if necessary
  if (!isString(data) && !isBuffer(data)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Ignore empty buffers, since writing them doesn't invoke the callback
  // https://github.com/nodejs/node/issues/22066
  if (data.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  // Only write when we don't exceed the maximum body length
  if (this._requestBodyLength + data.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data.length;
    this._requestBodyBuffers.push({ data: data, encoding: encoding });
    this._currentRequest.write(data, encoding, callback);
  }
  // Error when we exceed the maximum body length
  else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};

// Ends the current native request
RedirectableRequest.prototype.end = function (data, encoding, callback) {
  // Shift parameters if necessary
  if (isFunction(data)) {
    callback = data;
    data = encoding = null;
  }
  else if (isFunction(encoding)) {
    callback = encoding;
    encoding = null;
  }

  // Write data if needed and end
  if (!data) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  }
  else {
    var self = this;
    var currentRequest = this._currentRequest;
    this.write(data, encoding, function () {
      self._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};

// Sets a header value on the current native request
RedirectableRequest.prototype.setHeader = function (name, value) {
  this._options.headers[name] = value;
  this._currentRequest.setHeader(name, value);
};

// Clears a header value on the current native request
RedirectableRequest.prototype.removeHeader = function (name) {
  delete this._options.headers[name];
  this._currentRequest.removeHeader(name);
};

// Global timeout for all underlying requests
RedirectableRequest.prototype.setTimeout = function (msecs, callback) {
  var self = this;

  // Destroys the socket on timeout
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }

  // Sets up a timer to trigger a timeout event
  function startTimer(socket) {
    if (self._timeout) {
      clearTimeout(self._timeout);
    }
    self._timeout = setTimeout(function () {
      self.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }

  // Stops a timeout from triggering
  function clearTimer() {
    // Clear the timeout
    if (self._timeout) {
      clearTimeout(self._timeout);
      self._timeout = null;
    }

    // Clean up all attached listeners
    self.removeListener("abort", clearTimer);
    self.removeListener("error", clearTimer);
    self.removeListener("response", clearTimer);
    self.removeListener("close", clearTimer);
    if (callback) {
      self.removeListener("timeout", callback);
    }
    if (!self.socket) {
      self._currentRequest.removeListener("socket", startTimer);
    }
  }

  // Attach callback if passed
  if (callback) {
    this.on("timeout", callback);
  }

  // Start the timer if or when the socket is opened
  if (this.socket) {
    startTimer(this.socket);
  }
  else {
    this._currentRequest.once("socket", startTimer);
  }

  // Clean up on events
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);

  return this;
};

// Proxy all other public ClientRequest methods
[
  "flushHeaders", "getHeader",
  "setNoDelay", "setSocketKeepAlive",
].forEach(function (method) {
  RedirectableRequest.prototype[method] = function (a, b) {
    return this._currentRequest[method](a, b);
  };
});

// Proxy all public ClientRequest properties
["aborted", "connection", "socket"].forEach(function (property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function () { return this._currentRequest[property]; },
  });
});

RedirectableRequest.prototype._sanitizeOptions = function (options) {
  // Ensure headers are always present
  if (!options.headers) {
    options.headers = {};
  }

  // Since http.request treats host as an alias of hostname,
  // but the url module interprets host as hostname plus port,
  // eliminate the host property to avoid confusion.
  if (options.host) {
    // Use hostname if set, because it has precedence
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }

  // Complete the URL object when necessary
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    }
    else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};


// Executes the next native request (initial or redirect)
RedirectableRequest.prototype._performRequest = function () {
  // Load the native protocol
  var protocol = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol);
  }

  // If specified, use the agent corresponding to the protocol
  // (HTTP and HTTPS use different types of agents)
  if (this._options.agents) {
    var scheme = protocol.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }

  // Create the native request and set up its event handlers
  var request = this._currentRequest =
        nativeProtocol.request(this._options, this._onNativeResponse);
  request._redirectable = this;
  for (var event of events) {
    request.on(event, eventHandlers[event]);
  }

  // RFC7230§5.3.1: When making a request directly to an origin server, […]
  // a client MUST send only the absolute path […] as the request-target.
  this._currentUrl = /^\//.test(this._options.path) ?
    url.format(this._options) :
    // When making a request to a proxy, […]
    // a client MUST send the target URI in absolute-form […].
    this._options.path;

  // End a redirected request
  // (The first request must be ended explicitly with RedirectableRequest#end)
  if (this._isRedirect) {
    // Write the request entity and end
    var i = 0;
    var self = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error) {
      // Only write if this request has not been redirected yet
      // istanbul ignore else
      if (request === self._currentRequest) {
        // Report any write errors
        // istanbul ignore if
        if (error) {
          self.emit("error", error);
        }
        // Write the next buffer if there are still left
        else if (i < buffers.length) {
          var buffer = buffers[i++];
          // istanbul ignore else
          if (!request.finished) {
            request.write(buffer.data, buffer.encoding, writeNext);
          }
        }
        // End the request if `end` has been called on us
        else if (self._ended) {
          request.end();
        }
      }
    }());
  }
};

// Processes a response from the current native request
RedirectableRequest.prototype._processResponse = function (response) {
  // Store the redirected response
  var statusCode = response.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response.headers,
      statusCode: statusCode,
    });
  }

  // RFC7231§6.4: The 3xx (Redirection) class of status code indicates
  // that further action needs to be taken by the user agent in order to
  // fulfill the request. If a Location header field is provided,
  // the user agent MAY automatically redirect its request to the URI
  // referenced by the Location field value,
  // even if the specific status code is not understood.

  // If the response is not a redirect; return it as-is
  var location = response.headers.location;
  if (!location || this._options.followRedirects === false ||
      statusCode < 300 || statusCode >= 400) {
    response.responseUrl = this._currentUrl;
    response.redirects = this._redirects;
    this.emit("response", response);

    // Clean up
    this._requestBodyBuffers = [];
    return;
  }

  // The response is a redirect, so abort the current request
  destroyRequest(this._currentRequest);
  // Discard the remainder of the response to avoid waiting for data
  response.destroy();

  // RFC7231§6.4: A client SHOULD detect and intervene
  // in cyclical redirections (i.e., "infinite" redirection loops).
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }

  // Store the request headers if applicable
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response.req.getHeader("host"),
    }, this._options.headers);
  }

  // RFC7231§6.4: Automatic redirection needs to done with
  // care for methods not known to be safe, […]
  // RFC7231§6.4.2–3: For historical reasons, a user agent MAY change
  // the request method from POST to GET for the subsequent request.
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" ||
      // RFC7231§6.4.4: The 303 (See Other) status code indicates that
      // the server is redirecting the user agent to a different resource […]
      // A user agent can perform a retrieval request targeting that URI
      // (a GET or HEAD request if using HTTP) […]
      (statusCode === 303) && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    // Drop a possible entity and headers related to it
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }

  // Drop the Host header, as the redirect might lead to a different host
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);

  // If the redirect is relative, carry over the host of the last request
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location) ? this._currentUrl :
    url.format(Object.assign(currentUrlParts, { host: currentHost }));

  // Create the redirected request
  var redirectUrl = resolveUrl(location, currentUrl);
  debug("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);

  // Drop confidential headers when redirecting to a less secure protocol
  // or to a different domain that is not a superdomain
  if (redirectUrl.protocol !== currentUrlParts.protocol &&
     redirectUrl.protocol !== "https:" ||
     redirectUrl.host !== currentHost &&
     !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }

  // Evaluate the beforeRedirect callback
  if (isFunction(beforeRedirect)) {
    var responseDetails = {
      headers: response.headers,
      statusCode: statusCode,
    };
    var requestDetails = {
      url: currentUrl,
      method: method,
      headers: requestHeaders,
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }

  // Perform the redirected request
  this._performRequest();
};

// Wraps the key/value object of protocols with redirect functionality
function wrap(protocols) {
  // Default settings
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024,
  };

  // Wrap each protocol
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function (scheme) {
    var protocol = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);

    // Executes a request, following redirects
    function request(input, options, callback) {
      // Parse parameters, ensuring that input is an object
      if (isURL(input)) {
        input = spreadUrlObject(input);
      }
      else if (isString(input)) {
        input = spreadUrlObject(parseUrl(input));
      }
      else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol };
      }
      if (isFunction(options)) {
        callback = options;
        options = null;
      }

      // Set defaults
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength,
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString(options.host) && !isString(options.hostname)) {
        options.hostname = "::1";
      }

      assert.equal(options.protocol, protocol, "protocol mismatch");
      debug("options", options);
      return new RedirectableRequest(options, callback);
    }

    // Executes a GET request, following redirects
    function get(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }

    // Expose the properties on the wrapped protocol
    Object.defineProperties(wrappedProtocol, {
      request: { value: request, configurable: true, enumerable: true, writable: true },
      get: { value: get, configurable: true, enumerable: true, writable: true },
    });
  });
  return exports;
}

function noop() { /* empty */ }

function parseUrl(input) {
  var parsed;
  // istanbul ignore else
  if (useNativeURL) {
    parsed = new URL(input);
  }
  else {
    // Ensure the URL is valid and absolute
    parsed = validateUrl(url.parse(input));
    if (!isString(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}

function resolveUrl(relative, base) {
  // istanbul ignore next
  return useNativeURL ? new URL(relative, base) : parseUrl(url.resolve(base, relative));
}

function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}

function spreadUrlObject(urlObject, target) {
  var spread = target || {};
  for (var key of preservedUrlFields) {
    spread[key] = urlObject[key];
  }

  // Fix IPv6 hostname
  if (spread.hostname.startsWith("[")) {
    spread.hostname = spread.hostname.slice(1, -1);
  }
  // Ensure port is a number
  if (spread.port !== "") {
    spread.port = Number(spread.port);
  }
  // Concatenate path
  spread.path = spread.search ? spread.pathname + spread.search : spread.pathname;

  return spread;
}

function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header in headers) {
    if (regex.test(header)) {
      lastValue = headers[header];
      delete headers[header];
    }
  }
  return (lastValue === null || typeof lastValue === "undefined") ?
    undefined : String(lastValue).trim();
}

function createErrorType(code, message, baseClass) {
  // Create constructor
  function CustomError(properties) {
    // istanbul ignore else
    if (isFunction(Error.captureStackTrace)) {
      Error.captureStackTrace(this, this.constructor);
    }
    Object.assign(this, properties || {});
    this.code = code;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }

  // Attach constructor and set default properties
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false,
    },
    name: {
      value: "Error [" + code + "]",
      enumerable: false,
    },
  });
  return CustomError;
}

function destroyRequest(request, error) {
  for (var event of events) {
    request.removeListener(event, eventHandlers[event]);
  }
  request.on("error", noop);
  request.destroy(error);
}

function isSubdomain(subdomain, domain) {
  assert(isString(subdomain) && isString(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}

function isString(value) {
  return typeof value === "string" || value instanceof String;
}

function isFunction(value) {
  return typeof value === "function";
}

function isBuffer(value) {
  return typeof value === "object" && ("length" in value);
}

function isURL(value) {
  return URL && value instanceof URL;
}

// Exports
module.exports = wrap({ http: http, https: https });
module.exports.wrap = wrap;


/***/ }),
/* 207 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var debug;

module.exports = function () {
  if (!debug) {
    try {
      /* eslint global-require: off */
      debug = __webpack_require__(208)("follow-redirects");
    }
    catch (error) { /* */ }
    if (typeof debug !== "function") {
      debug = function () { /* */ };
    }
  }
  debug.apply(null, arguments);
};


/***/ }),
/* 208 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Detect Electron renderer / nwjs process, which is node, but we should
 * treat as a browser.
 */

if (typeof process === 'undefined' || process.type === 'renderer' || process.browser === true || process.__nwjs) {
	module.exports = __webpack_require__(209);
} else {
	module.exports = __webpack_require__(212);
}


/***/ }),
/* 209 */
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	let m;

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	// eslint-disable-next-line no-return-assign
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug') || exports.storage.getItem('DEBUG') ;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = __webpack_require__(210)(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};


/***/ }),
/* 210 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {


/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = __webpack_require__(211);
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		const split = (typeof namespaces === 'string' ? namespaces : '')
			.trim()
			.replace(/\s+/g, ',')
			.split(',')
			.filter(Boolean);

		for (const ns of split) {
			if (ns[0] === '-') {
				createDebug.skips.push(ns.slice(1));
			} else {
				createDebug.names.push(ns);
			}
		}
	}

	/**
	 * Checks if the given string matches a namespace template, honoring
	 * asterisks as wildcards.
	 *
	 * @param {String} search
	 * @param {String} template
	 * @return {Boolean}
	 */
	function matchesTemplate(search, template) {
		let searchIndex = 0;
		let templateIndex = 0;
		let starIndex = -1;
		let matchIndex = 0;

		while (searchIndex < search.length) {
			if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === '*')) {
				// Match character or proceed with wildcard
				if (template[templateIndex] === '*') {
					starIndex = templateIndex;
					matchIndex = searchIndex;
					templateIndex++; // Skip the '*'
				} else {
					searchIndex++;
					templateIndex++;
				}
			} else if (starIndex !== -1) { // eslint-disable-line no-negated-condition
				// Backtrack to the last '*' and try to match more characters
				templateIndex = starIndex + 1;
				matchIndex++;
				searchIndex = matchIndex;
			} else {
				return false; // No match
			}
		}

		// Handle trailing '*' in template
		while (templateIndex < template.length && template[templateIndex] === '*') {
			templateIndex++;
		}

		return templateIndex === template.length;
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names,
			...createDebug.skips.map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		for (const skip of createDebug.skips) {
			if (matchesTemplate(name, skip)) {
				return false;
			}
		}

		for (const ns of createDebug.names) {
			if (matchesTemplate(name, ns)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

module.exports = setup;


/***/ }),
/* 211 */
/***/ ((module) => {

/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}


/***/ }),
/* 212 */
/***/ ((module, exports, __webpack_require__) => {

/**
 * Module dependencies.
 */

const tty = __webpack_require__(213);
const util = __webpack_require__(20);

/**
 * This is the Node.js implementation of `debug()`.
 */

exports.init = init;
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.destroy = util.deprecate(
	() => {},
	'Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.'
);

/**
 * Colors.
 */

exports.colors = [6, 2, 3, 4, 5, 1];

try {
	// Optional dependency (as in, doesn't need to be installed, NOT like optionalDependencies in package.json)
	// eslint-disable-next-line import/no-extraneous-dependencies
	const supportsColor = __webpack_require__(214);

	if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
		exports.colors = [
			20,
			21,
			26,
			27,
			32,
			33,
			38,
			39,
			40,
			41,
			42,
			43,
			44,
			45,
			56,
			57,
			62,
			63,
			68,
			69,
			74,
			75,
			76,
			77,
			78,
			79,
			80,
			81,
			92,
			93,
			98,
			99,
			112,
			113,
			128,
			129,
			134,
			135,
			148,
			149,
			160,
			161,
			162,
			163,
			164,
			165,
			166,
			167,
			168,
			169,
			170,
			171,
			172,
			173,
			178,
			179,
			184,
			185,
			196,
			197,
			198,
			199,
			200,
			201,
			202,
			203,
			204,
			205,
			206,
			207,
			208,
			209,
			214,
			215,
			220,
			221
		];
	}
} catch (error) {
	// Swallow - we only care if `supports-color` is available; it doesn't have to be.
}

/**
 * Build up the default `inspectOpts` object from the environment variables.
 *
 *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js
 */

exports.inspectOpts = Object.keys(process.env).filter(key => {
	return /^debug_/i.test(key);
}).reduce((obj, key) => {
	// Camel-case
	const prop = key
		.substring(6)
		.toLowerCase()
		.replace(/_([a-z])/g, (_, k) => {
			return k.toUpperCase();
		});

	// Coerce string value into JS value
	let val = process.env[key];
	if (/^(yes|on|true|enabled)$/i.test(val)) {
		val = true;
	} else if (/^(no|off|false|disabled)$/i.test(val)) {
		val = false;
	} else if (val === 'null') {
		val = null;
	} else {
		val = Number(val);
	}

	obj[prop] = val;
	return obj;
}, {});

/**
 * Is stdout a TTY? Colored output is enabled when `true`.
 */

function useColors() {
	return 'colors' in exports.inspectOpts ?
		Boolean(exports.inspectOpts.colors) :
		tty.isatty(process.stderr.fd);
}

/**
 * Adds ANSI color escape codes if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	const {namespace: name, useColors} = this;

	if (useColors) {
		const c = this.color;
		const colorCode = '\u001B[3' + (c < 8 ? c : '8;5;' + c);
		const prefix = `  ${colorCode};1m${name} \u001B[0m`;

		args[0] = prefix + args[0].split('\n').join('\n' + prefix);
		args.push(colorCode + 'm+' + module.exports.humanize(this.diff) + '\u001B[0m');
	} else {
		args[0] = getDate() + name + ' ' + args[0];
	}
}

function getDate() {
	if (exports.inspectOpts.hideDate) {
		return '';
	}
	return new Date().toISOString() + ' ';
}

/**
 * Invokes `util.formatWithOptions()` with the specified arguments and writes to stderr.
 */

function log(...args) {
	return process.stderr.write(util.formatWithOptions(exports.inspectOpts, ...args) + '\n');
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	if (namespaces) {
		process.env.DEBUG = namespaces;
	} else {
		// If you set a process.env field to null or undefined, it gets cast to the
		// string 'null' or 'undefined'. Just delete instead.
		delete process.env.DEBUG;
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
	return process.env.DEBUG;
}

/**
 * Init logic for `debug` instances.
 *
 * Create a new `inspectOpts` object in case `useColors` is set
 * differently for a particular `debug` instance.
 */

function init(debug) {
	debug.inspectOpts = {};

	const keys = Object.keys(exports.inspectOpts);
	for (let i = 0; i < keys.length; i++) {
		debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
	}
}

module.exports = __webpack_require__(210)(exports);

const {formatters} = module.exports;

/**
 * Map %o to `util.inspect()`, all on a single line.
 */

formatters.o = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts)
		.split('\n')
		.map(str => str.trim())
		.join(' ');
};

/**
 * Map %O to `util.inspect()`, allowing multiple lines if needed.
 */

formatters.O = function (v) {
	this.inspectOpts.colors = this.useColors;
	return util.inspect(v, this.inspectOpts);
};


/***/ }),
/* 213 */
/***/ ((module) => {

"use strict";
module.exports = require("tty");

/***/ }),
/* 214 */
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSupportsColor: () => (/* binding */ createSupportsColor),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(215);
/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(216);
/* harmony import */ var node_tty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(217);




// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : node_process__WEBPACK_IMPORTED_MODULE_0__.argv) {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}

const {env} = node_process__WEBPACK_IMPORTED_MODULE_0__;

let flagForceColor;
if (
	hasFlag('no-color')
	|| hasFlag('no-colors')
	|| hasFlag('color=false')
	|| hasFlag('color=never')
) {
	flagForceColor = 0;
} else if (
	hasFlag('color')
	|| hasFlag('colors')
	|| hasFlag('color=true')
	|| hasFlag('color=always')
) {
	flagForceColor = 1;
}

function envForceColor() {
	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			return 1;
		}

		if (env.FORCE_COLOR === 'false') {
			return 0;
		}

		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3,
	};
}

function _supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== undefined) {
		flagForceColor = noFlagForceColor;
	}

	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;

	if (forceColor === 0) {
		return 0;
	}

	if (sniffFlags) {
		if (hasFlag('color=16m')
			|| hasFlag('color=full')
			|| hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}
	}

	// Check for Azure DevOps pipelines.
	// Has to be above the `!streamIsTTY` check.
	if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
		return 1;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (node_process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = node_os__WEBPACK_IMPORTED_MODULE_1__.release().split('.');
		if (
			Number(osRelease[0]) >= 10
			&& Number(osRelease[2]) >= 10_586
		) {
			return Number(osRelease[2]) >= 14_931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if ('GITHUB_ACTIONS' in env || 'GITEA_ACTIONS' in env) {
			return 3;
		}

		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if (env.TERM === 'xterm-kitty') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app': {
				return version >= 3 ? 3 : 2;
			}

			case 'Apple_Terminal': {
				return 2;
			}
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function createSupportsColor(stream, options = {}) {
	const level = _supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options,
	});

	return translateLevel(level);
}

const supportsColor = {
	stdout: createSupportsColor({isTTY: node_tty__WEBPACK_IMPORTED_MODULE_2__.isatty(1)}),
	stderr: createSupportsColor({isTTY: node_tty__WEBPACK_IMPORTED_MODULE_2__.isatty(2)}),
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (supportsColor);


/***/ }),
/* 215 */
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),
/* 216 */
/***/ ((module) => {

"use strict";
module.exports = require("node:os");

/***/ }),
/* 217 */
/***/ ((module) => {

"use strict";
module.exports = require("node:tty");

/***/ }),
/* 218 */
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),
/* 219 */
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),
/* 220 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const path = __webpack_require__(4);

class ProgressTracker {
    constructor() {
        this.chunks = new Map();
        this.fileProgress = new Map();
        
        // 新增：文件级别跟踪
        this.fileStatus = new Map(); // filePath -> 'pending'|'processing'|'completed'|'failed'
        this.totalFiles = 0;
        this.completedFiles = 0;
        this.processingFiles = 0;
        this.failedFiles = 0;
    }

    registerChunk(chunkId, metadata) {
        if (!this.chunks.has(chunkId)) {
            const chunkInfo = {
                chunkId,
                filePath: metadata.filePath,
                language: this._detectLanguage(metadata.filePath),
                startLine: metadata.startLine,
                endLine: metadata.endLine,
                content: metadata.content || '',
                parser: metadata.parser || this._getDefaultParser(metadata.filePath),
                type: metadata.type || 'unknown',
                registeredAt: Date.now(),
                status: 'pending',
                startTime: Date.now(),
                endTime: null,
                retries: 0,
                metadata: metadata
            };

            this.chunks.set(chunkId, chunkInfo);
            
            // 初始化文件进度
            const filePath = metadata.filePath;
            if (!this.fileProgress.has(filePath)) {
                this.fileProgress.set(filePath, {
                    total: 0,
                    pending: 0,
                    processing: 0,
                    completed: 0,
                    failed: 0,
                    language: chunkInfo.language
                });
            }
            
            const fileStats = this.fileProgress.get(filePath);
            fileStats.total++;
            fileStats.pending++;
        }
    }

    _detectLanguage(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        const languageMap = {
            '.py': 'python',
            '.js': 'javascript',
            '.ts': 'typescript',
            '.java': 'java',
            '.cpp': 'cpp',
            '.c': 'c',
            '.go': 'go',
            '.rs': 'rust',
            '.php': 'php',
            '.rb': 'ruby',
            '.swift': 'swift',
            '.kt': 'kotlin',
            '.scala': 'scala',
            '.hs': 'haskell',
            '.lua': 'lua',
            '.pl': 'perl',
            '.sh': 'shell',
            '.sql': 'sql',
            '.html': 'html',
            '.css': 'css',
            '.json': 'json',
            '.xml': 'xml',
            '.yaml': 'yaml',
            '.yml': 'yaml',
            '.md': 'markdown'
        };
        return languageMap[ext] || 'unknown';
    }

    _getDefaultParser(filePath) {
        const ext = path.extname(filePath).toLowerCase();
        const parserMap = {
            '.py': 'python_parser',
            '.js': 'javascript_parser',
            '.ts': 'typescript_parser',
            '.java': 'java_parser',
            '.cpp': 'cpp_parser',
            '.c': 'c_parser',
            '.go': 'go_parser',
            '.rs': 'rust_parser',
            '.php': 'php_parser',
            '.rb': 'ruby_parser',
            '.swift': 'swift_parser',
            '.kt': 'kotlin_parser',
            '.scala': 'scala_parser',
            '.hs': 'haskell_parser',
            '.lua': 'lua_parser',
            '.pl': 'perl_parser',
            '.sh': 'shell_parser',
            '.sql': 'sql_parser',
            '.html': 'html_parser',
            '.css': 'css_parser',
            '.json': 'json_parser',
            '.xml': 'xml_parser',
            '.yaml': 'yaml_parser',
            '.yml': 'yaml_parser',
            '.md': 'markdown_parser'
        };
        return parserMap[ext] || 'default_parser';
    }

    updateChunkStatus(chunkId, status) {
        const chunk = this.chunks.get(chunkId);
        if (!chunk) {
            console.warn(`Chunk ${chunkId} not found in progress tracker`);
            return;
        }

        const oldStatus = chunk.status;
        chunk.status = status;
        chunk.endTime = ['completed', 'failed'].includes(status) ? Date.now() : null;
        
        if (status === 'processing') {
            chunk.retries++;
        }
        
        // 更新文件进度
        const filePath = chunk.filePath;
        const fileStats = this.fileProgress.get(filePath);
        
        // 减少旧状态的计数
        if (oldStatus) {
            fileStats[oldStatus]--;
        }
        
        // 增加新状态的计数
        fileStats[status]++;
        
        // 新增：自动更新文件级别的状态
        this._updateFileStatusByChunks();
    }

    getOverallProgress() {
        let pendingChunks = 0;
        let processingChunks = 0;
        let completedChunks = 0;
        let failedChunks = 0;
        let totalChunks = this.chunks.size;

        for (const chunk of this.chunks.values()) {
            switch (chunk.status) {
                case 'pending':
                    pendingChunks++;
                    break;
                case 'processing':
                    processingChunks++;
                    break;
                case 'completed':
                    completedChunks++;
                    break;
                case 'failed':
                    failedChunks++;
                    break;
            }
        }

        return {
            pendingChunks,
            processingChunks,
            completedChunks,
            failedChunks,
            totalChunks,
            successRate: totalChunks > 0 ? (completedChunks / totalChunks) * 100 : 0
        };
    }

    getFileProgressSummary() {
        const summary = [];
        for (const [file, stats] of this.fileProgress.entries()) {
            summary.push({
                file: path.basename(file),
                language: stats.language,
                pending: stats.pending,
                processing: stats.processing,
                completed: stats.completed,
                failed: stats.failed,
                total: stats.total,
                successRate: stats.total > 0 ? (stats.completed / stats.total) * 100 : 0
            });
        }
        return summary;
    }

    getChunkDetails(chunkId) {
        return this.chunks.get(chunkId);
    }

    getAllChunks() {
        return Array.from(this.chunks.values());
    }

    getChunksByStatus(status) {
        return Array.from(this.chunks.values()).filter(chunk => chunk.status === status);
    }

    getChunksByFile(filePath) {
        return Array.from(this.chunks.values()).filter(chunk => chunk.filePath === filePath);
    }

    getChunksByLanguage(language) {
        return Array.from(this.chunks.values()).filter(chunk => chunk.language === language);
    }

    getChunksByType(type) {
        return Array.from(this.chunks.values()).filter(chunk => chunk.type === type);
    }

    // 新增：文件级别的进度跟踪方法
    
    /**
     * 注册文件到进度跟踪器
     * @param {string} filePath - 文件路径
     */
    registerFile(filePath) {
        if (!this.fileStatus.has(filePath)) {
            this.fileStatus.set(filePath, 'pending');
            this.totalFiles++;
        }
    }

    /**
     * 批量注册文件
     * @param {Array} fileList - 文件路径数组
     */
    registerFiles(fileList) {
        fileList.forEach(filePath => {
            this.registerFile(filePath);
        });
    }

    /**
     * 更新文件处理状态
     * @param {string} filePath - 文件路径
     * @param {string} status - 状态：'pending'|'processing'|'completed'|'failed'
     */
    updateFileStatus(filePath, status) {
        const oldStatus = this.fileStatus.get(filePath);
        
        if (oldStatus) {
            // 减少旧状态的计数
            switch (oldStatus) {
                case 'processing':
                    this.processingFiles = Math.max(0, this.processingFiles - 1);
                    break;
                case 'completed':
                    this.completedFiles = Math.max(0, this.completedFiles - 1);
                    break;
                case 'failed':
                    this.failedFiles = Math.max(0, this.failedFiles - 1);
                    break;
            }
        }
        
        // 设置新状态
        this.fileStatus.set(filePath, status);
        
        // 增加新状态的计数
        switch (status) {
            case 'processing':
                this.processingFiles++;
                break;
            case 'completed':
                this.completedFiles++;
                break;
            case 'failed':
                this.failedFiles++;
                break;
        }
    }

    /**
     * 获取文件级别的处理进度
     * @returns {Object} 包含文件处理进度的对象
     */
    getFileProgress() {
        return {
            totalFiles: this.totalFiles,
            completedFiles: this.completedFiles,
            processingFiles: this.processingFiles,
            failedFiles: this.failedFiles,
            pendingFiles: this.totalFiles - this.completedFiles - this.processingFiles - this.failedFiles,
            progressPercentage: this.totalFiles > 0 ? (this.completedFiles / this.totalFiles) * 100 : 0
        };
    }

    /**
     * 获取文件处理进度百分比（0-100浮点数）
     * @returns {number} 进度百分比
     */
    getFileProgressPercentage() {
        return this.totalFiles > 0 ? (this.completedFiles / this.totalFiles) * 100 : 0;
    }

    /**
     * 获取所有文件的状态详情
     * @returns {Array} 文件状态详情数组
     */
    getFileStatusDetails() {
        const details = [];
        for (const [filePath, status] of this.fileStatus.entries()) {
            details.push({
                filePath,
                status,
                language: this._detectLanguage(filePath)
            });
        }
        return details;
    }

    /**
     * 根据文件中的chunks来自动更新文件状态
     * 当文件中所有chunks都完成时，文件状态自动变为completed
     */
    _updateFileStatusByChunks() {
        const fileChunkStatus = new Map();
        
        // 统计每个文件的chunk状态
        for (const chunk of this.chunks.values()) {
            const filePath = chunk.filePath;
            if (!fileChunkStatus.has(filePath)) {
                fileChunkStatus.set(filePath, {
                    total: 0,
                    completed: 0,
                    failed: 0,
                    processing: 0
                });
            }
            
            const fileStats = fileChunkStatus.get(filePath);
            fileStats.total++;
            
            switch (chunk.status) {
                case 'completed':
                    fileStats.completed++;
                    break;
                case 'failed':
                    fileStats.failed++;
                    break;
                case 'processing':
                    fileStats.processing++;
                    break;
            }
        }
        
        // 根据chunk状态更新文件状态
        for (const [filePath, stats] of fileChunkStatus.entries()) {
            let newFileStatus = 'pending';
            
            if (stats.processing > 0) {
                newFileStatus = 'processing';
            } else if (stats.completed === stats.total) {
                newFileStatus = 'completed';
            } else if (stats.failed > 0 && stats.completed + stats.failed === stats.total) {
                newFileStatus = 'failed';
            }
            
            const currentStatus = this.fileStatus.get(filePath);
            if (currentStatus !== newFileStatus) {
                this.updateFileStatus(filePath, newFileStatus);
            }
        }
    }
}

module.exports = ProgressTracker; 

/***/ }),
/* 221 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const VectorManager = __webpack_require__(222);

module.exports = VectorManager;

/***/ }),
/* 222 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const VectorDB = __webpack_require__(223);
const EmbeddingClient = __webpack_require__(231);
const PathEncryption = __webpack_require__(232);
const Logger = __webpack_require__(225);
const Validator = __webpack_require__(235);
const RetryHelper = __webpack_require__(230);
const TencentVectorDB = __webpack_require__(226);
const TencentVectorDBAdapter = __webpack_require__(236);
const { createCollectionName } = __webpack_require__(229);

class VectorManager {
    constructor(config = {}) {
        this.config = config;
        this.logger = new Logger('VectorManager', config.logLevel);
        this.validator = new Validator();
        this.retryHelper = new RetryHelper(config.retry);
        
        // 核心组件
        this.vectorDB = null;
        this.embeddingClient = null;
        this.pathEncryption = null;
        
        // 状态管理
        this.isInitialized = false;
        this.isShuttingDown = false;
        this.uploadInProgress = new Set(); // 跟踪正在上传的 comboKey
        
        // 临时存储（用于开发模式，替代缓存）
        this.tempVectors = new Map();
    }

    async initialize() {
        if (this.isInitialized) {
            this.logger.warn('VectorManager is already initialized');
            return;
        }

        try {
            this.logger.info('Initializing VectorManager...');
            
            // 检查是否配置了数据库且不是local类型
            const shouldInitFullMode = this.config.database && 
                                     this.config.database.type !== 'local' && 
                                     this.config.database.type !== 'disabled';
            
            // 在开发和测试环境中简化初始化，但如果配置了在线数据库则完整初始化
            if ((process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test') && !shouldInitFullMode) {
                this.logger.info('Development mode: simplified VectorManager initialization');
                
                // 最小化初始化
                if (this.config.embedding) {
                this.embeddingClient = new EmbeddingClient(this.config.embedding);
                this.logger.info('EmbeddingClient initialized');
                }
                
                // 跳过其他复杂组件的初始化
                this.pathEncryption = null;
                this.vectorDB = null;
                
            } else {
                // 生产环境或在线模式完整初始化
                this.logger.info('Production mode: full VectorManager initialization');
                
                try {
                    // 1. 初始化安全模块
                    if (this.config.security && this.config.security.enabled) {
                        this.pathEncryption = new PathEncryption(this.config.security);
                        await this.pathEncryption.initialize();
                        this.logger.info('PathEncryption initialized');
                    } else {
                        this.logger.info('PathEncryption disabled, using passthrough mode');
                        this.pathEncryption = new PathEncryption({ enabled: false });
                        await this.pathEncryption.initialize();
                    }
                    
                    // 2. 跳过数据库连接初始化 - 只使用API接口
                    if (this.config.database && this.config.database.enabled && this.config.database.type !== 'api_only') {
                        // 根据配置类型选择不同的数据库实现
                        if (this.config.database.type === 'tencent_vectordb') {
                            // 使用腾讯云向量数据库适配器
                            this.vectorDB = new TencentVectorDBAdapter(this.config.database);
                            await this.vectorDB.initialize();
                            this.logger.info('Tencent VectorDB Adapter initialized');
                        } else if (this.config.database.type === 'tencent_cloud') {
                            // 使用默认VectorDB实现
                            this.vectorDB = new VectorDB(this.config.database);
                            await this.vectorDB.initialize();
                            this.logger.info('VectorDB initialized with Tencent Cloud');
                        }
                    } else {
                        this.logger.info('Database disabled or API-only mode, skipping VectorDB initialization');
                        this.vectorDB = null;
                    }
                    
                    // 3. 初始化嵌入服务客户端
                    if (this.config.embedding) {
                    this.embeddingClient = new EmbeddingClient(this.config.embedding);
                    this.logger.info('EmbeddingClient initialized');
                    }
                    
                    // 4. 注册清理回调
                    this._registerCleanupHandlers();
                    
                } catch (error) {
                    this.logger.error('Failed to initialize production components, falling back to simplified mode:', error);
                    
                    // 降级到简化模式，但仍尝试初始化基础组件
                    this.pathEncryption = new PathEncryption({ enabled: false });
                    await this.pathEncryption.initialize();
                    this.vectorDB = null;
                    
                    // 尝试初始化嵌入客户端
                    try {
                        if (this.config.embedding) {
                        this.embeddingClient = new EmbeddingClient(this.config.embedding);
                        this.logger.info('EmbeddingClient initialized in fallback mode');
                        }
                    } catch (embeddingError) {
                        this.logger.warn('Failed to initialize EmbeddingClient in fallback mode:', embeddingError);
                        this.embeddingClient = null;
                    }
                    
                    // 启用临时存储机制
                    this.tempVectors = new Map();
                    this.logger.info('Temporary vector storage enabled for fallback mode');
                }
            }
            
            this.isInitialized = true;
            this.logger.info('VectorManager initialized successfully');
            
        } catch (error) {
            this.logger.error('Failed to initialize VectorManager:', error);
            await this._cleanup();
            throw error;
        }
    }

    async addVector(data) {
        if (!this.isInitialized) {
            throw new Error('VectorManager not initialized');
        }
        
        if (this.isShuttingDown) {
            console.warn(`VectorManager is shutting down, skipping vector ${data.chunkId}`);
            return false;
        }
        
        try {
            // 1. 数据验证
            this._validateVectorData(data);
            
            // 2. 生成组合键
            const comboKey = this._generateComboKey(data.userId, data.deviceId, data.workspacePath);
            
            // 3. 如果有vectorDB，直接上传；否则存储到临时位置
            if (this.vectorDB) {
                // 确保目标集合存在
                await this._ensureCollectionExists(comboKey);
                
                // 直接上传到向量数据库
                const vectorData = {
                    id: data.chunkId,
                    vector: data.vector,
                    user_id: data.userId || 'unknown',
                    device_id: data.deviceId || 'unknown',
                    workspace_path: data.workspacePath || 'unknown',
                    file_path: this.pathEncryption ? this.pathEncryption.encryptPath(data.filePath) : data.filePath,
                    code: data.content || data.code || '',
                    start_line: data.startLine || data.start_line || 0,
                    end_line: data.endLine || data.end_line || 0,
                    vector_model: data.vector_model || 'CoCoSoDa-v1.0',
                    metadata: {
                        timestamp: Date.now(),
                        ...data.metadata
                    }
                };
                
                await this.vectorDB.upsert(comboKey, [vectorData]);
                this.logger.debug(`Added vector ${data.chunkId} directly to database for ${comboKey}`);
                return true;
            } else {
                // 临时存储模式
                if (!this.tempVectors.has(comboKey)) {
                    this.tempVectors.set(comboKey, []);
                }
                
                const tempVector = {
                    id: data.chunkId,
                    vector: data.vector,
                    filePath: data.filePath,
                    fileName: data.fileName,
                    userId: data.userId,
                    deviceId: data.deviceId,
                    workspacePath: data.workspacePath,
                    ...data.metadata
                };
                
                this.tempVectors.get(comboKey).push(tempVector);
                this.logger.debug(`Added vector ${data.chunkId} to temporary storage for ${comboKey}`);
                return true;
            }
            
        } catch (error) {
            this.logger.error(`Error adding vector ${data.chunkId}:`, error);
            
            if (this._isCriticalError(error)) {
                throw error;
            }
            
            return false;
        }
    }

    async search(query, topK = 10, options = {}) {
        if (!this.isInitialized) {
            throw new Error('VectorManager not initialized');
        }
        
        try {
            // 1. 参数验证
            if (!query || typeof query !== 'string') {
                throw new Error('Query must be a non-empty string');
            }
            
            if (!Number.isInteger(topK) || topK <= 0) {
                throw new Error('topK must be a positive integer');
            }
            
            // 2. 生成组合键（用于限定搜索范围）
            const comboKey = this._generateComboKey(
                options.userId, 
                options.deviceId, 
                options.workspacePath
            );
            
            // 3. 如果没有vectorDB但有临时存储，使用简单的文本匹配
            if (!this.vectorDB && this.tempVectors && this.tempVectors.has(comboKey)) {
                this.logger.debug(`Using temporary storage for search: ${comboKey}`);
                
                const vectors = this.tempVectors.get(comboKey);
                const results = vectors.filter(vector => {
                    // 简单的文本匹配搜索
                    const content = vector.content || '';
                    const filePath = vector.filePath || '';
                    const language = vector.language || '';
                    
                    return content.toLowerCase().includes(query.toLowerCase()) ||
                           filePath.toLowerCase().includes(query.toLowerCase()) ||
                           language.toLowerCase().includes(query.toLowerCase());
                }).slice(0, topK).map((vector, index) => ({
                    chunkId: vector.id,
                    id: vector.id,
                    score: 0.9 - (index * 0.1), // 模拟相似度分数
                    similarity: 0.9 - (index * 0.1),
                    filePath: vector.filePath,
                    fileName: vector.fileName,
                    startLine: vector.startLine,
                    endLine: vector.endLine,
                    content: vector.content,
                    metadata: {
                        userId: vector.userId,
                        deviceId: vector.deviceId,
                        workspacePath: vector.workspacePath,
                        language: vector.language,
                        parser: vector.parser,
                        type: vector.type,
                        vectorModel: 'temp-storage',
                        originalScore: 0.9 - (index * 0.1)
                    }
                }));
                
                this.logger.info(`Temporary storage search completed: found ${results.length} results`);
                return results;
            }
            
            // 3. 获取查询向量 - 支持压缩向量格式
            const queryEmbedding = await this.retryHelper.executeWithRetry(
                () => this.embeddingClient.getEmbedding(query),
                'Getting embedding for query'
            );
            
            // 处理压缩向量格式：如果是压缩向量，需要解压缩或使用压缩向量搜索
            let queryVector;
            if (queryEmbedding.isCompressed && queryEmbedding.compressedVector) {
                // 如果后端支持压缩向量搜索，直接使用压缩向量
                // 否则这里需要解压缩逻辑（目前暂时抛出错误提醒开发者）
                this.logger.warn('Query embedding is compressed. Current implementation requires uncompressed vectors for search.');
                // TODO: 实现压缩向量的解压缩逻辑或支持压缩向量搜索
                throw new Error('Compressed vector search not yet implemented. Please ensure query embedding returns uncompressed vector.');
            } else {
                queryVector = queryEmbedding.vector; // 使用未压缩的向量
            }
            
            // 4. 执行向量搜索
            const searchResults = await this.retryHelper.executeWithRetry(
                () => this.vectorDB.search(queryVector, topK, comboKey),
                'Searching vectors in database'
            );
            
            // 5. 处理搜索结果
            const processedResults = await this._processSearchResults(searchResults);
            
            this.logger.info(`Search completed: found ${processedResults.length} results for query "${query.substring(0, 50)}..."`);
            
            return processedResults;
            
        } catch (error) {
            this.logger.error(`Error searching vectors for query "${query}":`, error);
            throw error;
        }
    }

    async flushVectors() {
        if (!this.isInitialized) {
            throw new Error('VectorManager not initialized');
        }
        
        // 如果没有vectorDB或tempVectors，直接返回
        if (!this.vectorDB || !this.tempVectors) {
            this.logger.debug('No vectors to flush');
            return 0;
        }
        
        try {
            let totalUploaded = 0;
            
            for (const [comboKey, vectors] of this.tempVectors.entries()) {
                if (vectors.length === 0) continue;
                
                // 确保目标集合存在
                await this._ensureCollectionExists(comboKey);
                
                // 转换向量格式并上传
                const vectorsForUpload = vectors.map(vector => ({
                    id: vector.id,
                    vector: vector.vector,
                    user_id: vector.userId || 'unknown',
                    device_id: vector.deviceId || 'unknown',
                    workspace_path: vector.workspacePath || 'unknown',
                    file_path: this.pathEncryption ? this.pathEncryption.encryptPath(vector.filePath) : vector.filePath,
                    code: vector.content || vector.code || '',
                    start_line: vector.startLine || vector.start_line || 0,
                    end_line: vector.endLine || vector.end_line || 0,
                    vector_model: vector.vector_model || 'CoCoSoDa-v1.0',
                    metadata: {
                        timestamp: Date.now(),
                        ...vector.metadata
                    }
                }));
                
                await this.vectorDB.upsert(comboKey, vectorsForUpload);
                totalUploaded += vectorsForUpload.length;
                
                // 清空临时存储
                this.tempVectors.set(comboKey, []);
            }
            
            this.logger.info(`Flush completed: uploaded ${totalUploaded} vectors`);
            return totalUploaded;
            
        } catch (error) {
            this.logger.error('Error flushing vectors:', error);
            return 0;
        }
    }

    async getVectorInfo() {
        try {
            if (this.tempVectors) {
                // 临时存储模式
                let totalVectors = 0;
                for (const vectors of this.tempVectors.values()) {
                    totalVectors += vectors.length;
                }
                
                return {
                    totalVectors,
                    cacheSize: totalVectors * 1024, // 估算大小
                    lastUpdate: new Date().toISOString()
                };
            } else {
                return {
                    totalVectors: 0,
                    cacheSize: 0,
                    lastUpdate: undefined
                };
            }
        } catch (error) {
            this.logger.error('Error getting vector info:', error);
            return {
                totalVectors: 0,
                cacheSize: 0,
                lastUpdate: undefined
            };
        }
    }

    // 内部辅助方法
    _generateComboKey(userId, deviceId, workspacePath) {
        if (!userId || !deviceId || !workspacePath) {
            throw new Error('Missing required parameters for combo key generation');
        }
        
        // 使用统一的collection名称生成工具
        return createCollectionName(userId, deviceId, workspacePath);
    }

    async _ensureCollectionExists(comboKey) {
        try {
            if (this.vectorDB && typeof this.vectorDB.ensureCollection === 'function') {
                await this.vectorDB.ensureCollection(comboKey);
                this.logger.debug(`Ensured collection exists for ${comboKey}`);
            } else {
                this.logger.debug(`VectorDB not available or ensureCollection not supported for ${comboKey}`);
            }
        } catch (error) {
            this.logger.warn(`Failed to ensure collection exists for ${comboKey}:`, error);
            // 不抛出错误，让上传继续进行
        }
    }

    async _processSearchResults(searchResults) {
        const processedResults = [];
        
        this.logger.debug(`_processSearchResults接收到的原始数据:`, JSON.stringify(searchResults, null, 2));
        
        // 修复：处理腾讯云实际返回的嵌套数据结构
        // 实际搜索结果在第一个元素的metadata数组中
        let actualResults = [];
        
        if (Array.isArray(searchResults) && searchResults.length > 0) {
            const firstItem = searchResults[0];
            if (firstItem && Array.isArray(firstItem.metadata)) {
                // 真正的搜索结果在metadata数组中
                actualResults = firstItem.metadata;
                this.logger.info(`从metadata数组中提取到 ${actualResults.length} 个实际搜索结果`);
            } else {
                // 如果数据结构正常，直接使用
                actualResults = searchResults;
                this.logger.info(`使用原始数据结构，包含 ${actualResults.length} 个搜索结果`);
            }
        } else {
            this.logger.warn(`搜索结果为空或格式异常`);
            return [];
        }
        
        this.logger.debug(`Processing ${actualResults.length} actual search results`);
        
        for (const result of actualResults) {
            try {
                this.logger.debug(`Processing search result:`, JSON.stringify(result, null, 2));
                
                // 修复：处理腾讯云实际返回的字段结构
                const filePath = result.file_path || result.filePath || 'unknown';
                const fileName = result.fileName || null;
                const chunkId = result.id || result.chunkId || 'unknown';
                const score = result.score || 0;
                
                // 解密文件路径
                let decryptedPath = filePath;
                try {
                    decryptedPath = this.pathEncryption.decryptPath(filePath);
                } catch (decryptError) {
                    this.logger.warn(`Failed to decrypt path ${filePath}, using original path:`, decryptError.message);
                    decryptedPath = filePath;
                }
                
                // 构造返回结果 - 兼容多种数据格式
                const processedResult = {
                    chunkId: chunkId,
                    score: score, // 保持原始分数字段
                    similarity: score, // 同时保留similarity字段供向后兼容
                    filePath: decryptedPath,
                    fileName: fileName ? this.pathEncryption.decryptPath(fileName) : null,
                    offset: result.offset || 0,
                    
                    // 尝试从多个可能的字段中获取内容
                    content: result.content || result.code || '', 
                    
                    // 尝试从多个可能的字段中获取行号
                    startLine: result.startLine || result.start_line || 0,
                    endLine: result.endLine || result.end_line || 0,
                    
                    metadata: {
                        // 尝试从多个可能的字段中获取用户信息
                        userId: result.userId || result.user_id || 'unknown',
                        deviceId: result.deviceId || result.device_id || 'unknown',
                        workspacePath: result.workspacePath || result.workspace_path || '',
                        
                        // 尝试从多个可能的字段中获取其他元数据
                        language: result.language || result.metadata?.language || '',
                        parser: result.parser || result.metadata?.parser || '',
                        type: result.type || result.metadata?.type || '',
                        vectorModel: result.vectorModel || result.vector_model || result.metadata?.vectorModel || '',
                        processingTimeMs: result.processingTimeMs || result.processing_time_ms || result.metadata?.processingTimeMs || 0,
                        createdAt: result.createdAt || result.created_at || result.metadata?.createdAt || '',
                        
                        originalScore: result.score // 保留原始分数
                    }
                };
                
                processedResults.push(processedResult);
                this.logger.debug(`Successfully processed result ${chunkId} with score ${score}`);
                
            } catch (error) {
                this.logger.error(`Error processing search result ${result?.id || 'unknown'}:`, error);
                this.logger.error(`Result data:`, JSON.stringify(result, null, 2));
                // 跳过处理失败的结果，但不中断整个处理流程
            }
        }
        
        this.logger.info(`Successfully processed ${processedResults.length}/${actualResults.length} search results`);
        return processedResults;
    }

    _startPeriodicTasks() {
        // 定期清理任务（保留基础清理功能）
        this.cleanupTimer = setInterval(async () => {
            try {
                await this._periodicCleanup();
            } catch (error) {
                this.logger.error('Error in periodic cleanup:', error);
            }
        }, 600000); // 10分钟
    }

    async shutdown() {
        if (this.isShuttingDown) {
            this.logger.warn('VectorManager is already shutting down, waiting for completion...');
            // 等待当前关闭流程完成
            const maxWait = 10000; // 最多等待10秒
            const startTime = Date.now();
            while (this.isShuttingDown && (Date.now() - startTime) < maxWait) {
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            return;
        }
        
        this.isShuttingDown = true;
        this.logger.info('Shutting down VectorManager...');
        
        try {
            // 1. 停止定时任务
            if (this.cleanupTimer) {
                clearInterval(this.cleanupTimer);
                this.cleanupTimer = null;
            }
            
            // 2. 给正在进行的操作更多时间完成
            this.logger.info('Waiting for ongoing operations to complete...');
            await new Promise(resolve => setTimeout(resolve, 2000)); // 等待2秒
            
            // 3. 等待正在进行的上传完成
            await this._waitForUploadsToComplete();
            
            // 4. 刷新临时存储的向量（如果有的话）
            try {
                await this.flushVectors();
            } catch (error) {
                this.logger.warn('Error during final vector flush (ignoring):', error);
            }
            
            // 5. 关闭各组件
            await this._cleanup();
            
            this.isShuttingDown = false; // 重置状态
            this.logger.info('VectorManager shutdown completed');
            
        } catch (error) {
            this.logger.error('Error during shutdown:', error);
            this.isShuttingDown = false; // 即使出错也要重置状态
            throw error;
        }
    }

    _validateVectorData(data) {
        const requiredFields = ['chunkId', 'vector', 'filePath', 'userId', 'deviceId', 'workspacePath'];
        
        for (const field of requiredFields) {
            if (!data[field]) {
                throw new Error(`Missing required field: ${field}`);
            }
        }
        
        if (!Array.isArray(data.vector)) {
            throw new Error('Vector must be an array');
        }
        
        if (data.vector.length === 0) {
            throw new Error('Vector cannot be empty');
        }
        
        if (!data.vector.every(v => typeof v === 'number')) {
            throw new Error('Vector must contain only numbers');
        }
        
        if (typeof data.chunkId !== 'string' || data.chunkId.length === 0) {
            throw new Error('chunkId must be a non-empty string');
        }
    }

    _handleError(error, context) {
        const errorInfo = {
            message: error.message,
            stack: error.stack,
            context: context,
            timestamp: new Date().toISOString()
        };
        
        this.logger.error('VectorManager error:', errorInfo);
        
        // 根据错误类型决定是否需要告警
        if (this._isCriticalError(error)) {
            this._sendAlert(errorInfo);
        }
    }

    _isCriticalError(error) {
        // 判断是否为关键错误
        const criticalPatterns = [
            'database connection',
            'authentication failed',
            'out of memory',
            'permission denied'
        ];
        
        return criticalPatterns.some(pattern => 
            error.message.toLowerCase().includes(pattern)
        );
    }

    async _cleanup() {
        try {
            if (this.vectorDB) {
                // VectorDB使用close方法，不是shutdown
                if (typeof this.vectorDB.shutdown === 'function') {
                    await this.vectorDB.shutdown();
                } else if (typeof this.vectorDB.close === 'function') {
                    await this.vectorDB.close();
                }
            }
            // EmbeddingClient没有shutdown方法，跳过
            if (this.embeddingClient) {
                this.logger.info('EmbeddingClient cleanup completed (no explicit shutdown needed)');
            }
            // PathEncryption没有shutdown方法，跳过
            if (this.pathEncryption) {
                this.logger.info('PathEncryption cleanup completed (no explicit shutdown needed)');
            }
        } catch (error) {
            this.logger.error('Error during cleanup:', error);
        }
    }

    async _waitForUploadsToComplete() {
        const maxWaitTime = 30000; // 30秒
        const startTime = Date.now();
        
        while (this.uploadInProgress.size > 0) {
            if (Date.now() - startTime > maxWaitTime) {
                this.logger.warn('Timeout waiting for uploads to complete');
                break;
            }
            await new Promise(resolve => setTimeout(resolve, 100));
        }
    }

    _splitVectorsIntoBatches(vectors, batchSize) {
        const batches = [];
        for (let i = 0; i < vectors.length; i += batchSize) {
            batches.push(vectors.slice(i, i + batchSize));
        }
        return batches;
    }

    async _periodicCleanup() {
        try {
            if (this.vectorDB) {
                await this.vectorDB.cleanup();
            }
        } catch (error) {
            this.logger.error('Error in periodic cleanup:', error);
        }
    }

    _registerCleanupHandlers() {
        // 优化清理处理器，避免过于激进的关闭
        let shutdownInProgress = false;
        
        const gracefulShutdown = async (signal) => {
            if (shutdownInProgress) {
                this.logger.warn(`Shutdown already in progress, ignoring ${signal}`);
                return;
            }
            shutdownInProgress = true;
            
            this.logger.info(`Received ${signal} signal, initiating graceful shutdown...`);
            try {
                await this.shutdown();
                process.exit(0);
            } catch (error) {
                this.logger.error('Error during graceful shutdown:', error);
                process.exit(1);
            }
        };

        process.on('SIGINT', async () => {
            await gracefulShutdown('SIGINT');
        });

        process.on('SIGTERM', async () => {
            await gracefulShutdown('SIGTERM');
        });

        // 对于未捕获异常，给更多容错性
        process.on('uncaughtException', async (error) => {
            this.logger.error('Uncaught exception:', error);
            
            // 检查是否是关键错误
            if (this._isCriticalError(error)) {
                this.logger.error('Critical error detected, shutting down immediately');
                if (!shutdownInProgress) {
                    shutdownInProgress = true;
                    try {
                        await this.shutdown();
                    } catch (shutdownError) {
                        this.logger.error('Error during emergency shutdown:', shutdownError);
                    }
                    process.exit(1);
                }
            } else {
                // 非关键错误，记录但不关闭
                this.logger.warn('Non-critical uncaught exception, continuing operation');
            }
        });

        // 对于未处理的Promise拒绝，也给更多容错性
        process.on('unhandledRejection', async (reason, promise) => {
            this.logger.error('Unhandled rejection:', reason);
            
            // 只有在确实是关键错误时才关闭
            if (reason && typeof reason === 'object' && this._isCriticalError(reason)) {
                this.logger.error('Critical unhandled rejection, shutting down');
                if (!shutdownInProgress) {
                    shutdownInProgress = true;
                    try {
                        await this.shutdown();
                    } catch (shutdownError) {
                        this.logger.error('Error during emergency shutdown:', shutdownError);
                    }
                    process.exit(1);
                }
            } else {
                // 非关键错误，记录但不关闭
                this.logger.warn('Non-critical unhandled rejection, continuing operation');
            }
        });
    }
}

module.exports = VectorManager;

/***/ }),
/* 223 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const DBConnection = __webpack_require__(224);
const CollectionManager = __webpack_require__(227);
const QueryBuilder = __webpack_require__(228);
const TencentVectorDB = __webpack_require__(226);
const Logger = __webpack_require__(225);
const { createCollectionName } = __webpack_require__(229);
const RetryHelper = __webpack_require__(230);

class VectorDB {
    constructor(config) {
        this.config = config;
        this.logger = new Logger('VectorDB', config.logLevel);
        this.retryHelper = new RetryHelper(config.retry);

        // 调试：检查配置类型
        this.logger.debug('VectorDB配置检查:', {
            configType: config.type,
            isTencentCloud: config.type === 'tencent_cloud',
            connectionType: config.connection?.type
        });

        // 根据数据库类型选择实现
        if (config.type === 'tencent_cloud') {
            this.logger.info('使用腾讯云向量数据库实现');
            // 为TencentVectorDB准备正确的配置格式
            const tencentConfig = {
                ...config.connection,  // 将connection下的配置提升到顶级
                logLevel: config.logLevel || 'info',
                database: config.connection.database || config.query?.defaultDatabase,
                ...config  // 保留其他顶级配置
            };
            this.implementation = new TencentVectorDB(tencentConfig);
            this.useTencentCloud = true;
        } else {
            // 原有的实现逻辑
            this.logger.info('使用原始数据库实现');
            this.useTencentCloud = false;
            this._initOriginalImplementation(config);
        }
        
        // 连接状态
        this.isConnected = false;
        this.connectionAttempts = 0;
        this.maxConnectionAttempts = config.maxConnectionAttempts || 3;
        
        // 性能优化
        this.batchSize = config.batchSize || 100;
        this.requestTimeout = config.requestTimeout || 30000;
    }

    _initOriginalImplementation(config) {
        // 保证连接配置存在且有 logLevel
        if (!this.config.connection) {
            this.config.connection = {
                logLevel: 'info',
                host: 'localhost',
                database: 'test_db',
                username: 'test_user',
                apiKey: 'test_key'
            };
        } else {
            if (!this.config.connection.logLevel) this.config.connection.logLevel = 'info';
            if (!this.config.connection.host) this.config.connection.host = 'localhost';
            if (!this.config.connection.database) this.config.connection.database = 'test_db';
            if (!this.config.connection.username) this.config.connection.username = 'test_user';
            if (!this.config.connection.apiKey) this.config.connection.apiKey = 'test_key';
        }
        
        // 核心组件
        this.connection = null;
        this.collectionManager = null;
        this.queryBuilder = null;
    }

    async initialize() {
        if (this.useTencentCloud) {
            // 使用腾讯云向量数据库
            await this.implementation.initialize();
            this.isConnected = true;
            this.logger.info('VectorDB initialized with Tencent Cloud');
            return;
        }

        // 原有的初始化逻辑
        try {
            this.logger.info('Initializing VectorDB...');
            
            // 1. 初始化连接管理器
            this.connection = new DBConnection(this.config.connection);
            await this.connection.initialize();
            
            // 2. 初始化集合管理器
            this.collectionManager = new CollectionManager(this.connection, this.config.collections);
            
            // 3. 初始化查询构建器
            this.queryBuilder = new QueryBuilder(this.config.query);
            
            // 4. 测试连接
            await this._testConnection();
            
            this.isConnected = true;
            this.logger.info('VectorDB initialized successfully');
            
        } catch (error) {
            this.logger.error('Failed to initialize VectorDB:', error);
            throw error;
        }
    }

    async batchUpsert(comboKey, vectors) {
        if (!this.isConnected) {
            throw new Error('Database not connected');
        }
        
        if (this.useTencentCloud) {
            // 使用腾讯云向量数据库
            return await this.implementation.batchUpsert(comboKey, vectors);
        }

        // 原有的逻辑
        try {
            this.logger.info(`Starting batch upsert for ${comboKey}: ${vectors.length} vectors`);
            
            // 1. 确保目标集合存在
            const collectionName = this._getCollectionName(comboKey);
            await this.collectionManager.ensureCollection(collectionName);
            
            // 2. 分批处理大量数据
            const batches = this._splitIntoBatches(vectors, this.batchSize);
            let totalUploaded = 0;
            const uploadResults = [];
            
            for (let i = 0; i < batches.length; i++) {
                const batch = batches[i];
                this.logger.debug(`Uploading batch ${i + 1}/${batches.length}: ${batch.length} vectors`);
                
                try {
                    const batchResult = await this._uploadBatch(collectionName, batch);
                    totalUploaded += batchResult.count;
                    uploadResults.push(batchResult);
                    
                } catch (error) {
                    this.logger.error(`Failed to upload batch ${i + 1}:`, error);
                    
                    // 根据配置决定是否继续处理剩余批次
                    if (this.config.stopOnBatchError) {
                        throw error;
                    } else {
                        uploadResults.push({ success: false, error: error.message, count: 0 });
                    }
                }
            }
            
            // 3. 汇总结果
            const result = {
                success: totalUploaded > 0,
                count: totalUploaded,
                totalBatches: batches.length,
                successfulBatches: uploadResults.filter(r => r.success).length,
                failedBatches: uploadResults.filter(r => !r.success).length,
                details: uploadResults
            };
            
            if (result.success) {
                this.logger.info(`Batch upsert completed for ${comboKey}: ${totalUploaded}/${vectors.length} vectors uploaded`);
            } else {
                this.logger.error(`Batch upsert failed for ${comboKey}: no vectors uploaded`);
            }
            
            return result;
            
        } catch (error) {
            this.logger.error(`Error in batch upsert for ${comboKey}:`, error);
            throw error;
        }
    }

    async search(queryVector, topK, comboKey, options = {}) {
        if (!this.isConnected) {
            throw new Error('Database not connected');
        }
        
        if (this.useTencentCloud) {
            // 使用腾讯云向量数据库
            return await this.implementation.search(queryVector, topK, comboKey, options);
        }

        // 原有的搜索逻辑
        try {
            // 1. 构建搜索查询
            const collectionName = this._getCollectionName(comboKey);
            const searchQuery = this.queryBuilder.buildSearchQuery({
                vector: queryVector,
                topK: topK,
                collection: collectionName,
                ...options
            });
            
            this.logger.debug(`Executing search in collection ${collectionName} with topK=${topK}`);
            
            // 2. 执行搜索
            const response = await this.retryHelper.executeWithRetry(
                () => this.connection.post('/document/search', searchQuery),
                `Search in collection ${collectionName}`
            );
            
            // 3. 处理搜索结果
            const results = this._processSearchResponse(response);
            
            this.logger.info(`Search completed: found ${results.length} results in collection ${collectionName}`);
            
            return results;
            
        } catch (error) {
            this.logger.error(`Error in vector search:`, error);
            throw error;
        }
    }

    async deleteVectors(comboKey, vectorIds) {
        if (!this.isConnected) {
            throw new Error('Database not connected');
        }
        
        if (this.useTencentCloud) {
            // 腾讯云删除功能暂不实现
            this.logger.warn('Delete vectors not implemented for Tencent Cloud yet');
            return 0;
        }

        try {
            const collectionName = this._getCollectionName(comboKey);
            
            // 分批删除
            const batches = this._splitIntoBatches(vectorIds, this.batchSize);
            let totalDeleted = 0;
            
            for (const batch of batches) {
                const deleteQuery = this.queryBuilder.buildDeleteQuery({
                    collection: collectionName,
                    ids: batch
                });
                
                const response = await this.retryHelper.executeWithRetry(
                    () => this.connection.post('/document/delete', deleteQuery),
                    `Delete vectors from collection ${collectionName}`
                );
                
                totalDeleted += this._getDeletedCount(response);
            }
            
            this.logger.info(`Deleted ${totalDeleted} vectors from collection ${collectionName}`);
            return totalDeleted;
            
        } catch (error) {
            this.logger.error(`Error deleting vectors:`, error);
            throw error;
        }
    }

    // 内部方法
    async _testConnection() {
        try {
            // 对于腾讯云向量数据库，跳过健康检查（连接测试已在DBConnection中完成）
            if (this.config.connection.type === 'tencent') {
                this.logger.debug('Skipping health check for Tencent VectorDB - connection already tested');
                return;
            }
            
            // 测试基本连接
            const response = await this.connection.get('/health');
            this.logger.debug('Database connection test successful');
            
        } catch (error) {
            throw new Error(`Database connection test failed: ${error.message}`);
        }
    }

    _getCollectionName(comboKey) {
        // 直接使用组合键作为集合名称（已包含user_id+device_id+workspace_path）
        return comboKey;
    }

    /**
     * 创建符合腾讯云限制的集合名称
     * 基于用户ID、设备ID和工作空间路径生成
     * 
     * @param {string} user_id - 用户标识符
     * @param {string} device_id - 设备标识符
     * @param {string} workspace_path - 工作空间路径
     * @returns {string} 集合名称字符串
     */
    _createCollectionName(user_id, device_id, workspace_path) {
        return createCollectionName(user_id, device_id, workspace_path);
    }

    _splitIntoBatches(items, batchSize) {
        const batches = [];
        for (let i = 0; i < items.length; i += batchSize) {
            batches.push(items.slice(i, i + batchSize));
        }
        return batches;
    }

    async _uploadBatch(collectionName, vectors) {
        try {
            // 构建腾讯云向量数据库上传请求
            const upsertQuery = this.queryBuilder.buildUpsertQuery({
                collection: collectionName,
                documents: vectors.map(vector => ({
                    // 必需字段
                    id: vector.id,
                    vector: vector.vector,
                    // 腾讯云向量数据库测试规范字段
                    user_id: vector.user_id,
                    device_id: vector.device_id, 
                    workspace_path: vector.workspace_path,
                    file_path: vector.file_path,
                    start_line: vector.start_line,
                    end_line: vector.end_line,
                    code: vector.code,
                    vector_model: vector.vector_model,
                    // 兼容旧格式
                    filePath: vector.filePath,
                    fileName: vector.fileName,
                    offset: vector.offset,
                    timestamp: vector.metadata?.timestamp || new Date().toISOString(),
                    // 其他元数据字段
                    ...vector.metadata
                }))
            });
            
            // 执行上传
            const response = await this.connection.post('/document/upsert', upsertQuery);
            
            // 验证响应
            if (response.code !== 0) {
                throw new Error(`Upload failed: ${response.msg || 'Unknown error'}`);
            }
            
            return {
                success: true,
                count: response.affectedCount || response.count || vectors.length,
                response: response
            };
            
        } catch (error) {
            return {
                success: false,
                count: 0,
                error: error.message
            };
        }
    }

    _processSearchResponse(response) {
        if (response.code !== 0) {
            throw new Error(`Search failed: ${response.msg || 'Unknown error'}`);
        }
        
        if (!response.documents || !Array.isArray(response.documents)) {
            return [];
        }
        
        // 转换搜索结果格式
        return response.documents.map(doc => ({
            id: doc.id,
            score: doc.score,
            filePath: doc.filePath,
            fileName: doc.fileName,
            offset: doc.offset,
            timestamp: doc.timestamp,
            metadata: {
                // 提取其他元数据
                ...doc
            }
        }));
    }

    _getDeletedCount(response) {
        if (response.code !== 0) {
            throw new Error(`Delete failed: ${response.msg || 'Unknown error'}`);
        }
        
        return response.count || 0;
    }

    async close() {
        if (this.useTencentCloud) {
            await this.implementation.close();
        } else if (this.connection) {
            await this.connection.close();
        }
        this.isConnected = false;
        this.logger.info('VectorDB connection closed');
    }
}

module.exports = VectorDB;

/***/ }),
/* 224 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const axios = __webpack_require__(148);
const Logger = __webpack_require__(225);
const TencentVectorDB = __webpack_require__(226);

class DBConnection {
    constructor(config) {
        this.config = config;
        this.logger = new Logger('DBConnection', config.logLevel);
        
        // 连接配置
        this.host = config.host;
        this.port = config.port || 80;
        this.database = config.database;
        this.username = config.username;
        this.apiKey = config.apiKey;
        
        // HTTP 客户端配置
        this.timeout = config.timeout || 30000;
        this.maxRetries = config.maxRetries || 3;
        
        // 连接池配置
        this.maxConnections = config.maxConnections || 10;
        this.keepAlive = config.keepAlive !== false;
        
        // HTTP 客户端实例
        this.httpClient = null;
        
        // 连接状态
        this.isInitialized = false;
        this.lastError = null;
    }

    async initialize() {
        try {
            this.logger.info(`Initializing database connection to ${this.host}:${this.port}`);
            
            // 验证配置
            this._validateConfig();
            
            // 创建 HTTP 客户端
            this._createHttpClient();
            
            // 测试连接并自动创建数据库（如果需要）
            await this._testConnectionAndEnsureDatabase();
            
            this.isInitialized = true;
            this.logger.info('Database connection initialized successfully');
            
        } catch (error) {
            this.lastError = error;
            this.logger.error('Failed to initialize database connection:', error);
            throw error;
        }
    }

    async get(path, params = {}) {
        return this._makeRequest('GET', path, null, params);
    }

    async post(path, data, params = {}) {
        return this._makeRequest('POST', path, data, params);
    }

    async put(path, data, params = {}) {
        return this._makeRequest('PUT', path, data, params);
    }

    async delete(path, params = {}) {
        return this._makeRequest('DELETE', path, null, params);
    }

    // 内部方法
    _validateConfig() {
        const requiredFields = ['host', 'database', 'username', 'apiKey'];
        
        for (const field of requiredFields) {
            if (!this.config[field]) {
                throw new Error(`Missing required database config field: ${field}`);
            }
        }
    }

    _createHttpClient() {
        // 检查host是否已经包含协议前缀
        let baseURL;
        if (this.host.startsWith('http://') || this.host.startsWith('https://')) {
            // 如果host已经包含协议，直接使用
            baseURL = this.port && this.port !== 80 && this.port !== 443 
                ? `${this.host}:${this.port}` 
                : this.host;
        } else {
            // 如果host不包含协议，添加http前缀
            baseURL = `http://${this.host}:${this.port}`;
        }
        
        this.httpClient = axios.create({
            baseURL: baseURL,
            timeout: this.timeout,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': this._getAuthHeader()
            },
            // 连接池配置
            maxRedirects: 5,
            // 保持连接活跃
            ...(this.keepAlive && {
                'Connection': 'keep-alive',
                'Keep-Alive': 'timeout=30'
            }),
            // 禁用代理避免连接问题
            proxy: false
        });
        
        // 添加请求拦截器
        this.httpClient.interceptors.request.use(
            config => {
                this.logger.debug(`Making request: ${config.method?.toUpperCase()} ${config.url}`);
                return config;
            },
            error => {
                this.logger.error('Request interceptor error:', error);
                return Promise.reject(error);
            }
        );
        
        // 添加响应拦截器
        this.httpClient.interceptors.response.use(
            response => {
                this.logger.debug(`Response received: ${response.status} ${response.statusText}`);
                return response.data; // 直接返回数据部分
            },
            error => {
                this._handleResponseError(error);
                return Promise.reject(error);
            }
        );
    }

    _getAuthHeader() {
        // 构建认证头
        return `Bearer account=${this.username}&api_key=${this.apiKey}`;
    }

    async _makeRequest(method, path, data = null, params = {}) {
        if (!this.isInitialized) {
            throw new Error('Database connection not initialized');
        }
        
        try {
            const config = {
                method: method,
                url: path,
                params: params
            };
            
            if (data) {
                config.data = data;
            }
            
            const response = await this.httpClient.request(config);
            return response;
            
        } catch (error) {
            this.logger.error(`Request failed: ${method} ${path}`, error);
            throw this._processError(error);
        }
    }

    async _testConnectionAndEnsureDatabase() {
        try {
            // 对于腾讯云向量数据库，先测试连接再确保数据库存在
            if (this.config.type === 'tencent') {
                await this._testTencentConnection();
                await this._ensureDatabaseExists();
            } else {
                // 其他数据库类型的连接测试
                const response = await this.httpClient.get('/database/info');
                
                if (response.code !== 0) {
                    throw new Error(`Connection test failed: ${response.msg}`);
                }
                this.logger.debug('Database connection test passed');
            }
            
        } catch (error) {
            throw new Error(`Database connection test failed: ${error.message}`);
        }
    }

    async _testTencentConnection() {
        try {
            const response = await this.httpClient.get('/collections');
            this.logger.debug('Tencent VectorDB connection test passed');
        } catch (error) {
            // 如果是404错误，认为连接是正常的
            if (error.response && error.response.status === 404) {
                this.logger.warn('Connection test endpoint not found, but connection to Tencent VectorDB is working');
                return; // 连接测试通过
            }
            throw error;
        }
    }

    async _ensureDatabaseExists() {
        if (!this.database) {
            this.logger.warn('No database name specified, skipping database creation check');
            return;
        }

        try {
            this.logger.info(`Checking if database ${this.database} exists...`);
            
            // 创建腾讯云向量数据库客户端实例
            const tencentDB = new TencentVectorDB({
                host: this.host,
                port: this.port,
                username: this.username,
                apiKey: this.apiKey,
                timeout: this.timeout
            });
            
            await tencentDB.initialize();
            
            // 先尝试列出所有数据库，检查目标数据库是否存在
            let databaseExists = false;
            try {
                const databaseListResult = await tencentDB.listDatabases();
                const databases = databaseListResult.data?.databases || [];
                databaseExists = databases.some(db => db.database === this.database || db.name === this.database);
                
                if (databaseExists) {
                    this.logger.info(`Database ${this.database} exists in the database list`);
                } else {
                    this.logger.info(`Database ${this.database} not found in database list, needs to be created`);
                }
            } catch (error) {
                this.logger.warn(`Unable to list databases, will try direct access: ${error.message}`);
                // 如果无法列出数据库，就尝试直接访问
            }
            
            // 如果数据库不存在（或者无法确定），尝试创建
            if (!databaseExists) {
                try {
                    this.logger.info(`Attempting to create database ${this.database}...`);
                    const createResult = await tencentDB.createDatabase(this.database);
                    
                    if (createResult.success || createResult.message === 'Database already exists') {
                        this.logger.info(`Database ${this.database} created successfully`);
                        databaseExists = true;
                    } else {
                        this.logger.warn(`Database creation result unclear: ${JSON.stringify(createResult)}`);
                    }
                } catch (createError) {
                    if (createError.message.includes('already exist')) {
                        this.logger.info(`Database ${this.database} already exists`);
                        databaseExists = true;
                    } else {
                        this.logger.error(`Failed to create database: ${createError.message}`);
                        // 不抛出错误，继续尝试验证数据库
                    }
                }
            }
            
            // 最后验证数据库是否可访问
            try {
                await tencentDB.listCollections(this.database);
                this.logger.info(`Database ${this.database} is accessible`);
            } catch (error) {
                if (error.message.includes('can not find database') || 
                    error.message.includes('not exist')) {
                    throw new Error(`Database ${this.database} still does not exist after creation attempt`);
                } else {
                    // 其他错误可能不是致命的，只记录警告
                    this.logger.warn(`Database access test failed, but may be due to other reasons: ${error.message}`);
                }
            }
            
            await tencentDB.close();
            
        } catch (error) {
            this.logger.error(`Error ensuring database exists: ${error.message}`);
            throw error;
        }
    }

    _handleResponseError(error) {
        if (error.response) {
            // 服务器返回错误状态码
            const status = error.response.status;
            const message = error.response.data?.msg || error.response.statusText;
            
            switch (status) {
                case 401:
                    this.logger.error('Authentication failed - check API key');
                    break;
                case 403:
                    this.logger.error('Access forbidden - check permissions');
                    break;
                case 404:
                    this.logger.error('Resource not found');
                    break;
                case 429:
                    this.logger.error('Rate limit exceeded');
                    break;
                case 500:
                    this.logger.error('Database server error');
                    break;
                default:
                    this.logger.error(`HTTP error ${status}: ${message}`);
            }
            
        } else if (error.request) {
            // 网络错误
            this.logger.error('Network error:', error.message);
            
        } else {
            // 其他错误
            this.logger.error('Request setup error:', error.message);
        }
    }

    _processError(error) {
        // 根据错误类型进行分类处理
        if (error.code === 'ECONNREFUSED') {
            return new Error('Database connection refused - check host and port');
        }
        
        if (error.code === 'ETIMEDOUT') {
            return new Error('Database request timeout');
        }
        
        if (error.response && error.response.status === 401) {
            return new Error('Database authentication failed');
        }
        
        return error;
    }

    async close() {
        if (this.httpClient) {
            // 清理 HTTP 客户端
            this.httpClient = null;
        }
        
        this.isInitialized = false;
        this.logger.info('Database connection closed');
    }
}

module.exports = DBConnection;

/***/ }),
/* 225 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);

class Logger {
    constructor(name, level = 'info', config = {}) {
        this.name = name;
        this.level = level;
        this.config = config;

        // 【修改】测试环境下关闭日志
        this.enableConsole = process.env.NODE_ENV !== 'test' && (config.enableConsole !== false);
        this.enableFile = process.env.NODE_ENV !== 'test' && (config.enableFile !== false);
        
        // 日志级别映射
        this.levels = {
            error: 0,
            warn: 1,
            info: 2,
            debug: 3,
            trace: 4
        };
        
        // 当前日志级别
        this.currentLevel = this.levels[level] || this.levels.info;
        
        // 输出配置
        this.enableConsole = config.enableConsole !== false;
        this.enableFile = config.enableFile !== false;
        this.logDir = config.logDir || path.join(process.cwd(), 'logs');
        this.maxFileSize = config.maxFileSize || 10 * 1024 * 1024; // 10MB
        this.maxFiles = config.maxFiles || 10;
        
        // 格式化配置
        this.includeTimestamp = config.includeTimestamp !== false;
        this.includeLevel = config.includeLevel !== false;
        this.includeName = config.includeName !== false;
        this.colorize = config.colorize !== false && process.stdout.isTTY;
        
        // 颜色配置
        this.colors = {
            error: '\x1b[31m',   // 红色
            warn: '\x1b[33m',    // 黄色
            info: '\x1b[36m',    // 青色
            debug: '\x1b[37m',   // 白色
            trace: '\x1b[90m',   // 灰色
            reset: '\x1b[0m'     // 重置
        };
        
        // 文件流管理
        this.fileStreams = new Map();
        
        // 初始化日志目录
        this._initializeLogDirectory();
    }

    error(message, ...args) {
        this._log('error', message, ...args);
    }

    warn(message, ...args) {
        this._log('warn', message, ...args);
    }

    info(message, ...args) {
        this._log('info', message, ...args);
    }

    debug(message, ...args) {
        this._log('debug', message, ...args);
    }

    trace(message, ...args) {
        this._log('trace', message, ...args);
    }

    // 格式化对象日志
    logObject(level, label, obj) {
        const formatted = this._formatObject(obj);
        this._log(level, `${label}:\n${formatted}`);
    }

    // 性能日志
    logPerformance(operation, duration, metadata = {}) {
        const perfLog = {
            operation,
            duration: `${duration}ms`,
            timestamp: new Date().toISOString(),
            ...metadata
        };
        
        this.info(`Performance: ${operation} completed in ${duration}ms`, perfLog);
    }

    // 错误日志（带堆栈）
    logError(error, context = '') {
        const errorInfo = {
            message: error.message,
            stack: error.stack,
            context: context,
            timestamp: new Date().toISOString()
        };
        
        this.error(`Error${context ? ` in ${context}` : ''}:`, errorInfo);
    }

    // 内部方法
    _log(level, message, ...args) {
        if (this.levels[level] > this.currentLevel) {
            return; // 跳过低于当前级别的日志
        }
        
        const logEntry = this._formatLogEntry(level, message, args);
        
        // 控制台输出
        if (this.enableConsole) {
            this._writeToConsole(level, logEntry);
        }
        
        // 文件输出
        if (this.enableFile) {
            this._writeToFile(level, logEntry);
        }
    }

    _formatLogEntry(level, message, args) {
        let formattedMessage = message;
        
        // 处理参数
        if (args.length > 0) {
            const additionalInfo = args.map(arg => 
                typeof arg === 'object' ? JSON.stringify(arg, null, 2) : String(arg)
            ).join(' ');
            formattedMessage += ` ${additionalInfo}`;
        }
        
        // 构建日志条目
        const parts = [];
        
        if (this.includeTimestamp) {
            parts.push(new Date().toISOString());
        }
        
        if (this.includeLevel) {
            parts.push(`[${level.toUpperCase()}]`);
        }
        
        if (this.includeName) {
            parts.push(`[${this.name}]`);
        }
        
        parts.push(formattedMessage);
        
        return parts.join(' ');
    }

    _writeToConsole(level, logEntry) {
        const colorized = this.colorize ? 
            `${this.colors[level]}${logEntry}${this.colors.reset}` : 
            logEntry;
        
        if (level === 'error') {
            console.error(colorized);
        } else if (level === 'warn') {
            console.warn(colorized);
        } else {
            console.log(colorized);
        }
    }

    _writeToFile(level, logEntry) {
        try {
            const logFileName = this._getLogFileName(level);
            const logFilePath = path.join(this.logDir, logFileName);
            
            // 检查文件大小，如果需要则轮转
            this._rotateLogFileIfNeeded(logFilePath);
            
            // 写入日志
            const logLine = logEntry + '\n';
            fs.appendFileSync(logFilePath, logLine, 'utf8');
            
        } catch (error) {
            console.error(`Failed to write log to file: ${error.message}`);
        }
    }

    _getLogFileName(level) {
        const date = new Date().toISOString().split('T')[0]; // YYYY-MM-DD
        return `${this.name}-${level}-${date}.log`;
    }

    _rotateLogFileIfNeeded(logFilePath) {
        try {
            if (!fs.existsSync(logFilePath)) {
                return;
            }
            
            const stats = fs.statSync(logFilePath);
            if (stats.size < this.maxFileSize) {
                return;
            }
            
            // 生成备份文件名
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupPath = logFilePath.replace('.log', `.${timestamp}.log`);
            
            // 移动当前文件到备份
            fs.moveSync(logFilePath, backupPath);
            
            // 清理旧的备份文件
            this._cleanupOldLogFiles(path.dirname(logFilePath));
            
        } catch (error) {
            console.error(`Failed to rotate log file: ${error.message}`);
        }
    }

    _cleanupOldLogFiles(logDir) {
        try {
            const files = fs.readdirSync(logDir)
                .filter(file => file.includes(this.name) && file.endsWith('.log'))
                .map(file => ({
                    name: file,
                    path: path.join(logDir, file),
                    stats: fs.statSync(path.join(logDir, file))
                }))
                .sort((a, b) => b.stats.mtime - a.stats.mtime);
            
            // 删除超过最大文件数的旧文件
            const filesToDelete = files.slice(this.maxFiles);
            for (const file of filesToDelete) {
                fs.unlinkSync(file.path);
            }
            
        } catch (error) {
            console.error(`Failed to cleanup old log files: ${error.message}`);
        }
    }

    _formatObject(obj) {
        try {
            return JSON.stringify(obj, null, 2);
        } catch (error) {
            return `[Object cannot be serialized: ${error.message}]`;
        }
    }

    _initializeLogDirectory() {
        if (this.enableFile) {
            try {
                fs.ensureDirSync(this.logDir);
            } catch (error) {
                console.error(`Failed to create log directory: ${error.message}`);
                this.enableFile = false;
            }
        }
    }

    // 工具方法
    setLevel(level) {
        if (this.levels.hasOwnProperty(level)) {
            this.level = level;
            this.currentLevel = this.levels[level];
        }
    }

    createChild(childName) {
        const fullName = `${this.name}:${childName}`;
        return new Logger(fullName, this.level, this.config);
    }

    close() {
        // 关闭文件流
        for (const stream of this.fileStreams.values()) {
            if (stream && typeof stream.close === 'function') {
                stream.close();
            }
        }
        this.fileStreams.clear();
    }
}

module.exports = Logger;

/***/ }),
/* 226 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const axios = __webpack_require__(148);
const crypto = __webpack_require__(8);
const Logger = __webpack_require__(225);

class TencentVectorDB {
    constructor(config) {
        this.config = config;
        this.logger = new Logger('TencentVectorDB', config.logLevel);
        
        // 智能处理host URL - 检查是否已包含协议
        if (config.host.startsWith('http://') || config.host.startsWith('https://')) {
            // 如果host已经包含协议，直接使用并添加端口
            this.baseURL = config.port && config.port !== 80 && config.port !== 443 
                ? `${config.host}:${config.port}` 
                : config.host;
        } else {
            // 如果host不包含协议，添加协议前缀
            const protocol = config.useHttps ? 'https' : 'http';
            this.baseURL = `${protocol}://${config.host}:${config.port}`;
        }
        
        this.isInitialized = false;
    }

    async initialize() {
        try {
            this.logger.info('初始化腾讯云向量数据库...');
            
            // 测试数据库连接 - 使用官方API格式
            await this.testConnection();
            
            this.isInitialized = true;
            this.logger.info('腾讯云向量数据库初始化成功');
            
        } catch (error) {
            this.logger.error('腾讯云向量数据库初始化失败:', error);
            throw error;
        }
    }

    async testConnection() {
        try {
            // 使用官方API：查询所有数据库来测试连接
            const response = await this.listDatabases();
            this.logger.debug('数据库连接测试成功');
            return response;
        } catch (error) {
            this.logger.debug('连接测试:', error.message);
            // 即使API调用失败，只要不是网络错误就认为连接正常
            if (!error.message.includes('socket hang up') && !error.message.includes('ECONNRESET')) {
                return true;
            }
            throw error;
        }
    }

    // TC1: 创建Database - 使用官方API格式
    async createDatabase(databaseName) {
        try {
            this.logger.info(`创建数据库: ${databaseName}`);
            
            const response = await this.makeRequest('POST', '/database/create', {
                database: databaseName,
                description: `Database created for testing - ${databaseName}`
            });
            
            this.logger.info(`数据库 ${databaseName} 创建成功`);
            return response;
        } catch (error) {
            // 如果是数据库已存在，降级为警告
            if (error.message.includes('already exist')) {
                this.logger.warn(`数据库 ${databaseName} 已存在`);
                return { success: true, message: 'Database already exists' };
            }
            this.logger.error(`创建数据库失败: ${error.message}`);
            throw error;
        }
    }

    // TC2: 删除Database - 使用官方API格式
    async dropDatabase(databaseName) {
        try {
            this.logger.info(`删除数据库: ${databaseName}`);
            
            const response = await this.makeRequest('POST', '/database/drop', {
                database: databaseName
            });
            
            this.logger.info(`数据库 ${databaseName} 删除成功`);
            return response;
        } catch (error) {
            this.logger.error(`删除数据库失败: ${error.message}`);
            throw error;
        }
    }

    // TC3: 列出所有Database - 使用官方API格式，根据文档应该是POST请求
    async listDatabases() {
        try {
            this.logger.info('获取数据库列表');
            
            // 根据官方文档，/database/list 是 POST 请求，不需要请求体
            const response = await this.makeRequest('POST', '/database/list');
            
            this.logger.info(`获取到 ${response.data?.databases ? response.data.databases.length : 0} 个数据库`);
            return response;
        } catch (error) {
            this.logger.error(`获取数据库列表失败: ${error.message}`);
            throw error;
        }
    }

    // TC4: 创建Collection - 使用官方API格式，完整参数
    async createCollection(databaseName, collectionName, params = {}) {
        try {
            this.logger.info(`在数据库 ${databaseName} 中创建集合: ${collectionName}`);
            
            // 根据腾讯云API调试结果，修正默认参数
            const collectionData = {
                database: databaseName,
                collection: collectionName,
                replicaNum: params.replicaNum !== undefined ? params.replicaNum : 0,  // 腾讯云要求必须是0
                shardNum: params.shardNum || 1,
                description: params.description || `Collection created by Node.js client - ${collectionName}`,
                indexes: params.indexes || [
                    // 默认主键索引
                    {
                        fieldName: "id",
                        fieldType: "string",
                        indexType: "primaryKey"
                    },
                    // 默认向量索引 - 修正维度为768
                    {
                        fieldName: "vector",
                        fieldType: "vector",
                        indexType: "HNSW",
                        dimension: 768,  // 修正为768维度
                        metricType: "COSINE",
                        params: {
                            M: 16,
                            efConstruction: 200
                        }
                    }
                ]
            };

            const result = await this.makeRequest('POST', '/collection/create', collectionData);
            
            if (result.success) {
                this.logger.info(`集合 ${collectionName} 创建成功`);
            }
            
            return result;
            
        } catch (error) {
            this.logger.error(`创建集合失败: ${error.message}`);
            return {
                success: false,
                status: 500,
                message: '集合创建失败',
                error: error.message
            };
        }
    }

    // TC5: 删除Collection - 使用官方API格式
    async dropCollection(databaseName, collectionName) {
        try {
            this.logger.info(`删除集合: ${databaseName}.${collectionName}`);
            
            const response = await this.makeRequest('POST', '/collection/drop', {
                database: databaseName,
                collection: collectionName
            });
            
            // 检查响应是否成功
            if (response.success) {
            this.logger.info(`集合 ${collectionName} 删除成功`);
            return response;
            } else {
                // 检查是否是Collection不存在的错误
                if (response.data && response.data.code === 15302) {
                    this.logger.info(`集合 ${collectionName} 不存在，无需删除`);
                    // Collection不存在的情况，返回特殊标识
                    return {
                        success: true,
                        status: 200,
                        notExist: true, // 添加标识表示collection不存在
                        data: {
                            code: 15302,
                            message: `Collection ${collectionName} does not exist`,
                            affectedCount: 0
                        },
                        message: `集合 ${collectionName} 不存在`
                    };
                } else {
                    this.logger.error(`删除集合失败: ${response.message || 'Unknown error'}`);
                    const error = new Error(response.message || 'Delete collection failed');
                    error.response = response;
                    throw error;
                }
            }
        } catch (error) {
            // 如果是我们主动抛出的错误，直接传递
            if (error.code === 15302) {
                throw error;
            }
            this.logger.error(`删除集合失败: ${error.message}`);
            throw error;
        }
    }

    // TC6: 查询Collection详情 - 使用官方API格式
    async describeCollection(databaseName, collectionName) {
        try {
            this.logger.info(`查询集合详情: ${databaseName}.${collectionName}`);
            
            const response = await this.makeRequest('POST', '/collection/describe', {
                database: databaseName,
                collection: collectionName
            });
            
            if (response.success) {
                this.logger.info(`获取集合 ${collectionName} 详情成功`);
            } else {
                this.logger.warn(`获取集合 ${collectionName} 详情失败: ${response.message}`);
            }
            return response;
        } catch (error) {
            this.logger.error(`查询集合详情失败: ${error.message}`);
            // 返回失败响应而不是抛出异常
            return {
                success: false,
                status: 500,
                data: null,
                message: `查询集合详情失败: ${error.message}`,
                error: error.message
            };
        }
    }

    // TC7: 列出所有Collection - 使用官方API格式
    async listCollections(databaseName) {
        try {
            this.logger.info(`获取数据库 ${databaseName} 的集合列表`);
            
            const response = await this.makeRequest('POST', '/collection/list', {
                database: databaseName
            });
            
            this.logger.info(`获取到 ${response.data?.collections ? response.data.collections.length : 0} 个集合`);
            return response;
        } catch (error) {
            this.logger.error(`获取集合列表失败: ${error.message}`);
            throw error;
        }
    }

    // TC8: 向量数据写入 - 使用官方API格式
    async upsertDocuments(databaseName, collectionName, documents) {
        try {
            this.logger.info(`向集合 ${databaseName}.${collectionName} 写入 ${documents.length} 条数据`);
            
            const response = await this.makeRequest('POST', '/document/upsert', {
                database: databaseName,
                collection: collectionName,
                documents: documents,
                buildIndex: true  // 根据官方文档，默认为true
            });
            
            this.logger.info(`数据写入成功`);
            return response;
        } catch (error) {
            this.logger.error(`数据写入失败: ${error.message}`);
            throw error;
        }
    }

    // TC9: 向量相似度检索 - 使用官方API格式
    async searchVectors(databaseName, collectionName, vectors, params = {}) {
        try {
            this.logger.info(`执行向量检索: ${databaseName}.${collectionName}`);
            
            // 确保vectors是正确的数组格式 - 腾讯云需要二维数组
            let vectorArray;
            if (Array.isArray(vectors)) {
                // 如果是数组，检查第一个元素是否也是数组
                if (vectors.length > 0 && Array.isArray(vectors[0])) {
                    vectorArray = vectors; // 已经是二维数组
                } else {
                    vectorArray = [vectors]; // 转换为二维数组
                }
            } else {
                vectorArray = [vectors]; // 单个向量包装为二维数组
            }

            this.logger.debug(`向量数组格式检查:`, {
                originalType: Array.isArray(vectors) ? 'array' : typeof vectors,
                originalLength: Array.isArray(vectors) ? vectors.length : 'N/A',
                processedLength: vectorArray.length,
                firstElementType: vectorArray.length > 0 ? (Array.isArray(vectorArray[0]) ? 'array' : typeof vectorArray[0]) : 'N/A',
                firstElementLength: vectorArray.length > 0 && Array.isArray(vectorArray[0]) ? vectorArray[0].length : 'N/A'
            });
            
            // 根据官方API文档格式构建请求体
            const requestBody = {
                database: databaseName,
                collection: collectionName,
                search: {
                    vectors: vectorArray,
                    params: params.searchParams || {
                        ef: 200  // 默认ef参数
                    },
                    limit: params.limit || 10,
                    retrieveVector: params.retrieveVector !== undefined ? params.retrieveVector : false  // 修正从params获取参数
                }
            };

            // 处理过滤器 - 转换为腾讯云格式的字符串
            if (params.filter) {
                requestBody.search.filter = this._convertFilterToTencentFormat(params.filter);
            }

            // 处理输出字段
            // if (params.outputFields && params.outputFields.length > 0) {
            //     requestBody.search.outputFields = params.outputFields;
            // }

            // 如果有混合检索参数
            if (params.hybridSearch) {
                requestBody.search.hybridSearch = params.hybridSearch;
            }
            this.logger.info(`量检索请求体:`, JSON.stringify(requestBody, null, 2));
            const response = await this.makeRequest('POST', '/document/search', requestBody);
            
            this.logger.info(`向量检索完成，返回 ${response.data?.results ? response.data.results.length : 0} 条结果`);
            return response;
        } catch (error) {
            this.logger.error(`向量检索失败: ${error.message}`);
            throw error;
        }
    }

    // 新的代码向量存储接口 - 适配 /api/v1/codebase/upsert 接口
    async upsertCodebase(requestId, database, collection, documents, buildIndex = true) {
        try {
            this.logger.info(`代码向量存储: ${documents.length} 个文档到 ${database}.${collection}`);
            
            // 构建请求数据，符合新接口规范，支持压缩向量
            const requestData = {
                requestId: requestId,
                database: database,
                collection: collection,
                documents: documents.map(doc => ({
                    snippet_id: doc.snippet_id,
                    user_id: doc.user_id,
                    device_id: doc.device_id,
                    workspace_path: doc.workspace_path,
                    file_path: doc.file_path,
                    start_line: doc.start_line,
                    end_line: doc.end_line,
                    code: doc.code,
                    vector: doc.isCompressed ? null : doc.vector,
                    compressedVector: doc.isCompressed ? doc.compressedVector : null,
                    isCompressed: doc.isCompressed || false,
                    vector_model: doc.vector_model || "CoCoSoDa-v1.0"
                })),
                buildIndex: buildIndex
            };

            // 发送到新的代理接口
            const response = await this.makeCodebaseRequest('POST', '/api/v1/codebase/upsert', requestData);
            
            if (response.status === 'success') {
                this.logger.info(`代码向量存储成功: 影响 ${response.affectedRows} 行`);
                return {
                    success: true,
                    affectedRows: response.affectedRows,
                    requestId: response.requestId,
                    timestamp: response.timestamp
                };
            } else {
                this.logger.error(`代码向量存储失败: ${response.error}`);
                throw new Error(response.error || 'Upsert failed');
            }
            
        } catch (error) {
            this.logger.error(`代码向量存储异常: ${error.message}`);
            throw error;
        }
    }

    // 新的HTTP请求方法，专门用于代码库接口
    async makeCodebaseRequest(method, endpoint, data = null) {
        const url = (__webpack_require__(154).URL);
        const https = __webpack_require__(153);
        const http = __webpack_require__(152);
        
        try {
            // 使用代码库API的基础URL（可能与向量数据库不同）
            const codebaseBaseURL = this.config.codebaseApiUrl || this.baseURL;
            const requestUrl = new URL(endpoint, codebaseBaseURL);
            const isHttps = requestUrl.protocol === 'https:';
            
            const options = {
                hostname: requestUrl.hostname,
                port: requestUrl.port || (isHttps ? 443 : 80),
                path: requestUrl.pathname + requestUrl.search,
                method: method,
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${this.config.apiKey}`,
                    'User-Agent': 'CodeChunker-VectorDB/1.0.0'
                },
                timeout: this.config.timeout || 30000
            };

            if (data) {
                const postData = JSON.stringify(data);
                options.headers['Content-Length'] = Buffer.byteLength(postData);
            }

            return new Promise((resolve, reject) => {
                const req = (isHttps ? https : http).request(options, (res) => {
                    let responseData = '';
                    
                    res.on('data', (chunk) => {
                        responseData += chunk;
                    });
                    
                    res.on('end', () => {
                        try {
                            // 检查响应数据是否为空或不完整
                            if (!responseData || responseData.trim().length === 0) {
                                reject(new Error('Empty response from server'));
                                return;
                            }
                            
                            // 检查响应是否看起来像JSON
                            if (!responseData.trim().startsWith('{') && !responseData.trim().startsWith('[')) {
                                this.logger.error(`Non-JSON response received: ${responseData.substring(0, 200)}...`);
                                reject(new Error(`Invalid response format: expected JSON, got: ${responseData.substring(0, 100)}...`));
                                return;
                            }
                            
                            const parsed = JSON.parse(responseData);
                            
                            if (res.statusCode >= 200 && res.statusCode < 300) {
                                resolve(parsed);
                            } else {
                                const error = new Error(parsed.error || `HTTP ${res.statusCode}`);
                                error.statusCode = res.statusCode;
                                error.response = parsed;
                                error.errorCode = parsed.errorCode;
                                reject(error);
                            }
                        } catch (error) {
                            this.logger.error(`JSON parse error. Response length: ${responseData.length}, Content: ${responseData.substring(0, 200)}...`);
                            reject(new Error(`Failed to parse response: ${error.message}. Response was: ${responseData.substring(0, 200)}...`));
                        }
                    });
                });

                req.on('error', (error) => {
                    reject(new Error(`Request failed: ${error.message}`));
                });

                req.on('timeout', () => {
                    req.destroy();
                    reject(new Error('Request timeout'));
                });

                if (data) {
                    req.write(JSON.stringify(data));
                }
                
                req.end();
            });
            
        } catch (error) {
            this.logger.error(`代码库请求失败: ${error.message}`);
            throw error;
        }
    }

    // 修改现有的batchUpsert方法以使用新接口
    async batchUpsert(comboKey, vectors) {
        try {
            this.logger.info(`开始批量向量存储: ${comboKey} - ${vectors.length} 个向量`);

            // 验证和过滤向量数据
            const validVectors = this._validateAndFilterVectors(vectors);
            if (validVectors.length === 0) {
                this.logger.warn('没有有效的向量数据需要存储');
                return {
                    success: true,
                    count: 0,
                    message: '没有有效数据'
                };
            }

            // 解析comboKey获取用户信息
            const [userId, deviceId, workspaceHash] = comboKey.split('_');
            const workspacePath = this._extractWorkspacePathFromHash(workspaceHash) || '/unknown/workspace';
            
            // 准备数据库和集合名称
            const databaseName = this.config.database || 'codebase_db';
            // ✅ 修复：使用时间戳生成新的collection名称，避免旧collection的socket hang up问题
            const timestamp = Date.now();
            const collectionName = `code_vectors_${timestamp}`;
            
            // 转换为新接口格式的文档，支持压缩向量
            const documents = validVectors.map((vector, index) => ({
                snippet_id: vector.id || `${comboKey}_${index}`,
                user_id: userId,
                device_id: deviceId,
                workspace_path: workspacePath,
                file_path: vector.filePath || 'unknown',
                start_line: vector.startLine || 1,
                end_line: vector.endLine || 1,
                code: vector.content || '',
                vector: vector.isCompressed ? null : vector.vector,
                compressedVector: vector.isCompressed ? vector.compressedVector : null,
                isCompressed: vector.isCompressed || false,
                vector_model: vector.vectorModel || "CoCoSoDa-v1.0"
            }));

            // 生成请求ID
            const requestId = `req-upsert-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

            // 使用新的代码库接口
            const result = await this.upsertCodebase(requestId, databaseName, collectionName, documents, true);
            
            this.logger.info(`批量向量存储完成: ${result.affectedRows} 行数据`);
            
            return {
                success: true,
                count: result.affectedRows,
                requestId: result.requestId,
                details: result
            };

        } catch (error) {
            this.logger.error(`批量向量存储失败: ${error.message}`);
            
            // 如果新接口失败，可以尝试回退到原接口（可选）
            if (error.message.includes('404') || error.message.includes('endpoint')) {
                this.logger.warn('新接口不可用，尝试使用原接口...');
                return await this._fallbackBatchUpsert(comboKey, vectors);
            }
            
            throw error;
        }
    }

    // 回退方法：使用原有的腾讯云接口
    async _fallbackBatchUpsert(comboKey, vectors) {
        this.logger.info('使用原有腾讯云接口进行向量存储');
        
        try {
            // 验证和过滤向量数据
            const validVectors = this._validateAndFilterVectors(vectors);
            if (validVectors.length === 0) {
                return {
                    success: true,
                    count: 0,
                    message: '没有有效数据'
                };
            }

            // 生成集合名称
            const crypto = __webpack_require__(8);
            const workspaceHash = crypto.createHash('sha256').update(comboKey).digest('hex').substring(0, 16);
            const collectionName = `collection_${comboKey}`;
            const databaseName = this.config.database || 'vectordb-test';

            // 确保集合存在
            await this._ensureCollectionExists(databaseName, collectionName, 768);

            // 转换为腾讯云格式
            const documents = validVectors.map((vector, index) => ({
                id: vector.id || `${comboKey}_${index}`,
                vector: vector.vector,
                user_id: comboKey.split('_')[0] || 'unknown',
                device_id: comboKey.split('_')[1] || 'unknown',
                workspace_path: vector.workspacePath || 'unknown',
                file_path: vector.filePath || 'unknown',
                start_line: vector.startLine || 1,
                end_line: vector.endLine || 1,
                code: vector.content || '',
                vector_model: vector.vectorModel || 'default'
            }));

            // 分批上传
            const batchSize = this.config.batchSize || 100;
            const batches = this._splitIntoBatches(documents, batchSize);
            let totalUploaded = 0;

            for (let i = 0; i < batches.length; i++) {
                const batch = batches[i];
                this.logger.debug(`上传批次 ${i + 1}/${batches.length}: ${batch.length} 个向量`);
                
                const batchResult = await this._uploadBatchWithRetry(databaseName, collectionName, batch);
                totalUploaded += batchResult.count || 0;
            }

            this.logger.info(`回退接口批量存储完成: ${totalUploaded} 个向量`);
            
            return {
                success: true,
                count: totalUploaded,
                fallback: true
            };

        } catch (error) {
            this.logger.error(`回退接口也失败: ${error.message}`);
            throw error;
        }
    }

    // 辅助方法：从哈希中提取工作区路径（简化实现）
    _extractWorkspacePathFromHash(workspaceHash) {
        // 这里可以实现更复杂的逻辑来恢复原始路径
        // 目前返回一个通用路径
        return `/workspace/${workspaceHash}`;
    }

    // 辅助方法：验证和过滤向量数据
    _validateAndFilterVectors(vectors) {
        const validVectors = [];
        
        // ✅ 修复：重新计算合理的限制
        // 向量维度768 * 8字节(双精度) ≈ 6KB 
        // 加上其他字段，总文档大小应该控制在9KB以下
        const maxCodeSize = 2 * 1024; // ✅ 代码内容限制降到2KB
        const vectorSizeEstimate = 768 * 8; // ✅ 768维向量的估算大小
        
        for (let i = 0; i < vectors.length; i++) {
            const vector = vectors[i];
            
            // 基本字段检查
            if (!vector.id || !vector.vector || !Array.isArray(vector.vector)) {
                this.logger.warn(`向量 ${i} 缺少必要字段 (id 或 vector)，跳过`);
                continue;
            }
            
            // ✅ 修复：先处理代码内容，确保不会过大
            let codeContent = vector.code || '';
            if (codeContent.length > maxCodeSize) {
                // 智能截断：保留开头和结尾
                const truncateSize = maxCodeSize - 50; // 为标记保留空间
                const halfSize = Math.floor(truncateSize / 2);
                codeContent = codeContent.substring(0, halfSize) + 
                             '\n\n... [内容截断] ...\n\n' + 
                             codeContent.substring(codeContent.length - halfSize);
                this.logger.debug(`向量 ${vector.id} 代码内容截断: ${vector.code.length} -> ${codeContent.length} 字符`);
            }
            
            // ✅ 修复：更准确的文档大小估算（不包含向量数据）
            const metadataSize = JSON.stringify({
                id: vector.id,
                user_id: vector.user_id || 'unknown',
                device_id: vector.device_id || 'unknown',
                workspace_path: vector.workspace_path || 'unknown',
                file_path: vector.file_path || 'unknown',
                code: codeContent,
                start_line: vector.start_line || 0,
                end_line: vector.end_line || 0,
                vector_model: vector.vector_model || 'unknown'
            }).length;
            
            // ✅ 文档总大小 = 元数据 + 向量数据
            const estimatedTotalSize = metadataSize + vectorSizeEstimate;
            const maxDocSize = 9 * 1024; // ✅ 腾讯云限制是10KB，留1KB余量
            
            if (estimatedTotalSize > maxDocSize) {
                this.logger.warn(`向量 ${vector.id} 文档仍然过大 (${estimatedTotalSize} > ${maxDocSize})，跳过处理`);
                continue;
            }
            
            // 确保必要字段存在
            const validVector = {
                id: vector.id,
                vector: vector.vector,
                user_id: vector.user_id || 'unknown',
                device_id: vector.device_id || 'unknown',
                workspace_path: vector.workspace_path || 'unknown',
                file_path: vector.file_path || 'unknown',
                code: codeContent, // ✅ 使用处理后的代码内容
                start_line: vector.start_line || 0,
                end_line: vector.end_line || 0,
                vector_model: vector.vector_model || 'unknown'
            };
            
            validVectors.push(validVector);
        }
        
        this.logger.info(`向量验证完成: ${validVectors.length}/${vectors.length} 个向量有效`);
        return validVectors;
    }

    // 辅助方法：带重试的批量上传
    async _uploadBatchWithRetry(databaseName, collectionName, batch, maxRetries = 3) {
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const result = await this.upsertDocuments(databaseName, collectionName, batch);
                
                if (result.success) {
                    return result;
                } else {
                    lastError = new Error(result.message || '上传失败');
                    
                    // 如果是索引未准备错误，等待一下再重试
                    if (result.message && result.message.includes('current index is not ready')) {
                        this.logger.warn(`索引未准备就绪，等待${attempt * 2}秒后重试 (${attempt}/${maxRetries})`);
                        await new Promise(resolve => setTimeout(resolve, attempt * 2000));
                        continue;
                    } else {
                        throw lastError;
                    }
                }
                
            } catch (error) {
                lastError = error;
                
                // 对于400错误（客户端错误），不要重试
                if (error.response && error.response.status === 400) {
                    this.logger.error(`客户端错误，不重试: ${error.response.data ? JSON.stringify(error.response.data) : error.message}`);
                    throw error;
                }
                
                if (attempt < maxRetries) {
                    this.logger.warn(`批量上传失败，${attempt * 2}秒后重试 (${attempt}/${maxRetries}): ${error.message}`);
                    await new Promise(resolve => setTimeout(resolve, attempt * 2000));
                } else {
                    this.logger.error(`批量上传最终失败，已重试${maxRetries}次: ${error.message}`);
                    throw error;
                }
            }
        }
        
        throw lastError;
    }

    // 辅助方法：确保集合存在
    async _ensureCollectionExists(databaseName, collectionName, vectorDimension = 768) {
        try {
            // 检查集合是否存在
            const describeResult = await this.describeCollection(databaseName, collectionName);
            
            if (describeResult.success) {
                this.logger.info(`集合 ${collectionName} 已存在，检查是否需要重新创建...`);
                
                // 检查现有集合的维度配置
                const existingDimension = describeResult.data?.collection?.indexes?.find(
                    index => index.fieldName === 'vector'
                )?.dimension;
                
                if (existingDimension && existingDimension !== vectorDimension) {
                    this.logger.info(`集合维度不匹配 (现有: ${existingDimension}, 需要: ${vectorDimension})，重新创建集合...`);
                    
                    // 删除现有集合
                    await this.dropCollection(databaseName, collectionName);
                    
                    // 创建新集合
                    await this._createCollectionWithFields(databaseName, collectionName, vectorDimension);
                } else {
                    this.logger.debug(`集合 ${collectionName} 配置正确，跳过重新创建`);
                }
            } else {
                // 检查是否是"集合不存在"的错误
                if (describeResult.data && describeResult.data.code === 15302) {
                    this.logger.info(`集合 ${collectionName} 不存在，正在创建...`);
                    await this._createCollectionWithFields(databaseName, collectionName, vectorDimension);
                } else {
                    // 其他错误，抛出异常
                    throw new Error(`查询集合详情失败: ${describeResult.message || '未知错误'}`);
                }
            }
            
        } catch (error) {
            // 对于已知的"集合不存在"错误，创建集合
            if (error.message.includes('not exist') || error.message.includes('Not Found') || 
                (error.response && error.response.data && error.response.data.msg && 
                 error.response.data.msg.includes('not exist'))) {
                this.logger.info(`集合 ${collectionName} 不存在，正在创建...`);
                await this._createCollectionWithFields(databaseName, collectionName, vectorDimension);
            } else {
                throw error;
            }
        }
    }

    // 辅助方法：创建带有完整字段定义的集合
    async _createCollectionWithFields(databaseName, collectionName, vectorDimension) {
        const collectionParams = {
            description: `Auto-created collection for ${collectionName}`,
            indexes: [
                {
                    fieldName: "id",
                    fieldType: "string",
                    indexType: "primaryKey"
                },
                {
                    fieldName: "vector",
                    fieldType: "vector",
                    indexType: "HNSW",
                    dimension: vectorDimension,
                    metricType: "COSINE",
                    params: {
                        M: 16,
                        efConstruction: 200
                    }
                },
                // 添加测试数据的字段
                {
                    fieldName: "user_id",
                    fieldType: "string",
                    indexType: "filter"
                },
                {
                    fieldName: "device_id", 
                    fieldType: "string",
                    indexType: "filter"
                },
                {
                    fieldName: "workspace_path",
                    fieldType: "string",
                    indexType: "filter"
                },
                {
                    fieldName: "file_path",
                    fieldType: "string",
                    indexType: "filter"
                },
                {
                    fieldName: "code",
                    fieldType: "string",
                    indexType: "filter"
                },
                // 添加更多可能需要的字段
                {
                    fieldName: "start_line",
                    fieldType: "uint64",
                    indexType: "filter"
                },
                {
                    fieldName: "end_line",
                    fieldType: "uint64",
                    indexType: "filter"
                },
                {
                    fieldName: "vector_model",
                    fieldType: "string",
                    indexType: "filter"
                }
            ]
        };
        
        const createResult = await this.createCollection(databaseName, collectionName, collectionParams);
        if (createResult.success) {
            this.logger.info(`集合 ${collectionName} 创建成功，维度: ${vectorDimension}`);
            
            // 等待索引构建完成
            await this._waitForIndexReady(databaseName, collectionName);
        } else {
            throw new Error(`创建集合失败: ${createResult.message || '未知错误'}`);
        }
    }

    // 辅助方法：等待索引准备就绪
    async _waitForIndexReady(databaseName, collectionName, maxWaitTime = 60000) {
        this.logger.info(`等待集合 ${collectionName} 的索引构建完成...`);
        
        const startTime = Date.now();
        let retryCount = 0;
        const maxRetries = Math.floor(maxWaitTime / 2000); // 每2秒检查一次
        
        while (retryCount < maxRetries) {
            try {
                // 尝试插入一个测试文档来检查索引是否就绪
                const testDoc = {
                    id: `test_${Date.now()}`,
                    vector: new Array(768).fill(0.1),
                    user_id: 'test',
                    device_id: 'test',
                    workspace_path: 'test',
                    file_path: 'test',
                    code: 'test',
                    start_line: 1,
                    end_line: 1,
                    vector_model: 'test'
                };
                
                const result = await this.upsertDocuments(databaseName, collectionName, [testDoc]);
                
                if (result.success) {
                    // 索引就绪，删除测试文档
                    await this.deleteDocuments(databaseName, collectionName, `id="${testDoc.id}"`);
                    this.logger.info(`集合 ${collectionName} 索引构建完成，耗时 ${Date.now() - startTime}ms`);
                    return;
                }
                
            } catch (error) {
                if (error.message && error.message.includes('current index is not ready')) {
                    // 索引还未准备好，继续等待
                    retryCount++;
                    this.logger.debug(`索引尚未准备就绪，等待中... (${retryCount}/${maxRetries})`);
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    continue;
                } else {
                    // 其他错误，可能索引已经准备好了
                    this.logger.info(`索引状态检查完成 (可能已就绪): ${error.message}`);
                    return;
                }
            }
        }
        
        // 超时但不抛出错误，让后续操作自行处理
        this.logger.warn(`等待索引就绪超时 (${maxWaitTime}ms)，将继续尝试上传数据`);
    }

    // 辅助方法：分批处理
    _splitIntoBatches(items, batchSize) {
        const batches = [];
        for (let i = 0; i < items.length; i += batchSize) {
            batches.push(items.slice(i, i + batchSize));
        }
        return batches;
    }

    async search(queryVector, topK, comboKey, options = {}) {
        try {
            const collectionName = `collection_${comboKey}`;
            const databaseName = this.config.database || 'vectordb-test';
            
            this.logger.info(`执行搜索: ${databaseName}.${collectionName}, topK=${topK}`);
            this.logger.debug(`查询向量长度: ${queryVector.length}`);
            this.logger.debug(`搜索选项:`, JSON.stringify(options, null, 2));
            
            // 修正输出字段配置，避免使用'*'
            const defaultOutputFields = ['id', 'user_id', 'device_id', 'workspace_path', 'file_path', 'code', 'start_line', 'end_line', 'vector_model'];
            
            const params = {
                limit: topK,
                filter: options.filter,
                outputFields: options.outputFields || defaultOutputFields,
                retrieveVector: false  // 默认不返回向量以提高性能
            };
            
            this.logger.debug(`搜索参数:`, JSON.stringify(params, null, 2));
            
            const response = await this.searchVectors(databaseName, collectionName, queryVector, params);
            
            this.logger.debug(`搜索响应:`, JSON.stringify(response, null, 2));
            
            // 转换为标准格式
            if (response.success && response.data) {
                // 检查不同可能的响应格式
                let documents = response.data.documents || response.data.results || response.data;
                
                if (Array.isArray(documents)) {
                    this.logger.info(`找到 ${documents.length} 个搜索结果`);
                    return documents.map(doc => ({
                        id: doc.id,
                        score: doc.score || 0,
                        user_id: doc.user_id,
                        device_id: doc.device_id,
                        workspace_path: doc.workspace_path,
                        file_path: doc.file_path,
                        start_line: doc.start_line,
                        end_line: doc.end_line,
                        code: doc.code,
                        vector_model: doc.vector_model,
                        // 兼容字段
                        filePath: doc.filePath,
                        fileName: doc.fileName,
                        offset: doc.offset,
                        timestamp: doc.timestamp,
                        metadata: doc
                    }));
                } else {
                    this.logger.warn(`意外的响应格式，documents不是数组:`, typeof documents);
                }
            } else {
                // 检查常见的错误代码，提供更友好的处理
                if (response.data && response.data.code) {
                    const errorCode = response.data.code;
                    const errorMsg = response.data.msg || '未知错误';
                    
                    switch (errorCode) {
                        case 15171:
                            this.logger.warn(`向量维度不匹配: ${errorMsg} - 请检查向量维度是否与集合定义一致`);
                            break;
                        case 14000:
                            this.logger.warn(`字段不存在错误: ${errorMsg} - 请检查outputFields中指定的字段是否在集合中定义`);
                            break;
                        default:
                            this.logger.warn(`搜索响应包含错误 (${errorCode}): ${errorMsg}`);
                    }
                } else {
                    this.logger.warn(`搜索响应不包含成功数据:`, JSON.stringify(response, null, 2));
                }
            }
            
            return [];
            
        } catch (error) {
            this.logger.error(`搜索失败，完整错误信息:`, {
                message: error.message,
                stack: error.stack,
                code: error.code,
                response: error.response?.data,
                status: error.response?.status
            });
            throw new Error(`向量搜索失败: ${error.message || '未知错误'}`);
        }
    }

    // TC10: 精确查询 - 使用官方API格式
    async queryDocuments(databaseName, collectionName, filter, params = {}) {
        try {
            this.logger.info(`执行精确查询: ${databaseName}.${collectionName}`);
            
            const requestBody = {
                database: databaseName,
                collection: collectionName,
                filter: filter,
                limit: params.limit || 10,
                offset: params.offset || 0,
                outputFields: params.outputFields || []  // 指定返回的字段
            };

            // 如果指定了特定字段
            if (params.retrieveVector !== undefined) {
                requestBody.retrieveVector = params.retrieveVector;
            }
            
            const response = await this.makeRequest('POST', '/document/query', requestBody);
            
            this.logger.info(`精确查询完成，返回 ${response.data?.documents ? response.data.documents.length : 0} 条结果`);
            return response;
        } catch (error) {
            this.logger.error(`精确查询失败: ${error.message}`);
            throw error;
        }
    }

    // TC11: 删除数据 - 使用官方API格式
    async deleteDocuments(databaseName, collectionName, filter) {
        try {
            this.logger.info(`删除文档: ${databaseName}.${collectionName}`);
            
            const response = await this.makeRequest('POST', '/document/delete', {
                database: databaseName,
                collection: collectionName,
                filter: filter
            });
            
            this.logger.info(`文档删除成功`);
            return response;
        } catch (error) {
            this.logger.error(`删除文档失败: ${error.message}`);
            throw error;
        }
    }

    // TC12: 清空Collection - 使用官方API格式
    async truncateCollection(databaseName, collectionName) {
        try {
            this.logger.info(`清空集合: ${databaseName}.${collectionName}`);
            
            const response = await this.makeRequest('POST', '/collection/truncate', {
                database: databaseName,
                collection: collectionName
            });
            
            this.logger.info(`集合清空成功`);
            return response;
        } catch (error) {
            this.logger.error(`清空集合失败: ${error.message}`);
            throw error;
        }
    }

    // 将对象格式的过滤器转换为腾讯云API的字符串格式
    _convertFilterToTencentFormat(filter) {
        if (!filter || typeof filter === 'string') {
            return filter; // 如果已经是字符串格式，直接返回
        }
        
        const conditions = [];
        
        for (const [field, value] of Object.entries(filter)) {
            if (Array.isArray(value)) {
                // 数组格式转换为 in 操作 - 使用腾讯云格式
                const valueStr = value.map(v => `"${v}"`).join(',');
                conditions.push(`${field} in (${valueStr})`);
            } else if (typeof value === 'object' && value !== null) {
                // 范围查询等复杂条件
                if (value.$in) {
                    const valueStr = value.$in.map(v => `"${v}"`).join(',');
                    conditions.push(`${field} in (${valueStr})`);
                } else if (value.$eq) {
                    conditions.push(`${field}="${value.$eq}"`);  // 移除空格
                } else if (value.$gt) {
                    conditions.push(`${field}>${value.$gt}`);   // 移除空格
                } else if (value.$lt) {
                    conditions.push(`${field}<${value.$lt}`);   // 移除空格
                }
            } else {
                // 简单等值条件 - 移除等号两边的空格，使用腾讯云标准格式
                conditions.push(`${field}="${value}"`);
            }
        }
        
        // 使用腾讯云格式的连接符
        return conditions.length > 0 ? conditions.join(' and ') : '';  // 使用小写 'and'
    }

    // 发送HTTP请求的通用方法 - 根据官方文档修正认证方式
    async makeRequest(method, endpoint, data = null) {
        const maxRetries = 3;
        let lastError;
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
            try {
                const url = `${this.baseURL}${endpoint}`;
                
                // 根据官方文档：使用 Authorization Bearer 头部认证
                const authToken = `account=${this.config.username}&api_key=${this.config.apiKey}`;
                
                // 标准HTTP请求头 + 官方认证头部
                const headers = {
                    'Content-Type': 'application/json',
                    'Accept': 'application/json',
                    'Authorization': `Bearer ${authToken}`,
                    'User-Agent': 'TencentVectorDB-NodeJS-Client/1.0.0',
                    'Connection': 'keep-alive'  // 保持连接
                };

                this.logger.debug(`发送请求 (尝试 ${attempt}/${maxRetries}): ${method} ${url}`);
                if (data) {
                    this.logger.debug(`请求数据:`, JSON.stringify(data, null, 2));
                }

                const axiosConfig = {
                    method,
                    url,
                    headers,
                    timeout: this.config.timeout || 60000, // 增加到60秒
                    validateStatus: (status) => {
                        // 接受2xx状态码
                        return status >= 200 && status < 300;
                    },
                    // 添加重试配置
                    retry: {
                        retries: 0, // axios层面不重试，我们手动控制
                        retryDelay: (retryCount) => {
                            return Math.pow(2, retryCount) * 1000; // 指数退避
                        },
                        retryCondition: (error) => {
                            // 网络错误才重试
                            return error.code === 'ECONNRESET' || 
                                   error.code === 'ETIMEDOUT' || 
                                   error.code === 'ECONNABORTED';
                        }
                    },
                    // 添加HTTP Agent配置
                    httpAgent: new ((__webpack_require__(152).Agent))({
                        keepAlive: true,
                        keepAliveMsecs: 30000,
                        maxSockets: 5,
                        timeout: 30000
                    })
                };

                // 只有在有数据时才添加data字段
                if (data && method !== 'GET') {
                    axiosConfig.data = data;
                }

                const response = await axios(axiosConfig);

                this.logger.debug(`响应状态: ${response.status}`);
                this.logger.debug(`响应数据:`, JSON.stringify(response.data, null, 2));

                return {
                    success: true,
                    status: response.status,
                    data: response.data,
                    headers: response.headers,
                    message: this.getStatusMessage(response.status)
                };

            } catch (error) {
                lastError = error;
                
                if (error.response) {
                    // 检查是否是常见的业务错误，降级为警告
                    const isBusinessError = error.response.data && (
                        error.response.data.msg?.includes('already exist') ||
                        error.response.data.msg?.includes('current index is not ready') ||
                        error.response.data.code === 15201 || // 数据库已存在
                        error.response.data.code === 13100    // 索引未准备好
                    );
                    
                    if (isBusinessError) {
                        this.logger.warn(`业务警告 (${error.response.status}): ${error.response.data.msg || error.message}`);
                        return {
                            success: false,
                            status: error.response.status,
                            data: error.response.data,
                            headers: error.response.headers,
                            message: this.getStatusMessage(error.response.status),
                            error: error.message
                        };
                    } else {
                        this.logger.error(`请求失败 (尝试 ${attempt}/${maxRetries}): ${error.message}`);
                        this.logger.error(`响应状态: ${error.response.status}`);
                        this.logger.error(`响应数据:`, error.response.data);
                    }
                    
                    // 对于HTTP错误，不重试
                    return {
                        success: false,
                        status: error.response.status,
                        data: error.response.data,
                        headers: error.response.headers,
                        message: this.getStatusMessage(error.response.status),
                        error: error.message
                    };
                } else if (error.request) {
                    // 网络错误，可以重试
                    const isRetryableError = error.code === 'ECONNRESET' || 
                                           error.code === 'ETIMEDOUT' || 
                                           error.code === 'ECONNABORTED' ||
                                           error.message.includes('timeout');
                    
                    if (isRetryableError && attempt < maxRetries) {
                        const delay = Math.pow(2, attempt - 1) * 1000; // 指数退避: 1s, 2s, 4s
                        this.logger.warn(`网络错误，${delay}ms后重试 (${attempt}/${maxRetries}): ${error.message}`);
                        await new Promise(resolve => setTimeout(resolve, delay));
                        continue; // 重试
                    }
                    
                    this.logger.error(`网络错误 (尝试 ${attempt}/${maxRetries}):`, error.message);
                } else {
                    this.logger.error(`请求设置错误 (尝试 ${attempt}/${maxRetries}):`, error.message);
                }
                
                // 如果是最后一次尝试，返回错误
                if (attempt === maxRetries) {
                    break;
                }
            }
        }
        
        // 所有重试都失败了
        return {
            success: false,
            status: 0,
            data: null,
            message: `网络错误 (已重试${maxRetries}次): ${lastError?.message || 'Unknown error'}`,
            error: lastError?.message || 'Unknown error'
        };
    }

    // 获取状态码对应的消息
    getStatusMessage(status) {
        const statusMessages = {
            200: 'Success',
            201: 'Created',
            400: 'Bad Request - 请求参数错误',
            401: 'Unauthorized - 认证失败',
            403: 'Forbidden - 权限不足',
            404: 'Not Found - 资源不存在',
            405: 'Method Not Allowed - 请求方法不允许',
            409: 'Conflict - 资源冲突',
            422: 'Unprocessable Entity - 请求格式错误',
            429: 'Too Many Requests - 请求过于频繁',
            500: 'Internal Server Error - 服务器内部错误',
            502: 'Bad Gateway - 网关错误',
            503: 'Service Unavailable - 服务不可用',
            504: 'Gateway Timeout - 网关超时'
        };
        
        return statusMessages[status] || `HTTP ${status}`;
    }

    async close() {
        try {
            this.logger.info('关闭腾讯云向量数据库连接');
            this.isInitialized = false;
        } catch (error) {
            this.logger.error('关闭连接时出错:', error);
        }
    }
}

module.exports = TencentVectorDB; 

/***/ }),
/* 227 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Logger = __webpack_require__(225);

class CollectionManager {
    constructor(connection, config) {
        this.connection = connection;
        this.config = config;
        this.logger = new Logger('CollectionManager', config.logLevel);
        
        // 集合缓存：collectionName -> collection info
        this.collectionCache = new Map();
        
        // 默认集合配置
        this.defaultConfig = {
            vectorDimension: config.vectorDimension || 768,
            metricType: config.metricType || 'COSINE',
            indexType: config.indexType || 'HNSW',
            ...config.defaultCollection
        };
    }

    async ensureCollection(collectionName) {
        try {
            // 检查缓存
            if (this.collectionCache.has(collectionName)) {
                const cachedInfo = this.collectionCache.get(collectionName);
                if (Date.now() - cachedInfo.lastChecked < 300000) { // 5分钟缓存
                    return cachedInfo;
                }
            }
            
            // 检查集合是否存在
            const exists = await this._checkCollectionExists(collectionName);
            
            if (!exists) {
                this.logger.info(`Collection ${collectionName} does not exist, creating...`);
                await this._createCollection(collectionName);
            }
            
            // 获取集合信息
            const collectionInfo = await this._getCollectionInfo(collectionName);
            
            // 更新缓存
            this.collectionCache.set(collectionName, {
                ...collectionInfo,
                lastChecked: Date.now()
            });
            
            return collectionInfo;
            
        } catch (error) {
            this.logger.error(`Error ensuring collection ${collectionName}:`, error);
            throw error;
        }
    }

    async createCollection(collectionName, customConfig = {}) {
        try {
            const collectionConfig = {
                ...this.defaultConfig,
                ...customConfig
            };
            
            this.logger.info(`Creating collection ${collectionName} with config:`, collectionConfig);
            
            const createQuery = {
                database: this.connection.database,
                collection: collectionName,
                description: collectionConfig.description || `Collection for ${collectionName}`,
                // 腾讯云向量数据库必需参数
                shardNum: collectionConfig.shardNum || 1,
                replicaNum: collectionConfig.replicaNum || 0,
                // 腾讯云向量数据库索引定义
                indexes: [
                    // 主键索引
                    {
                        fieldName: "id",
                        fieldType: "string",
                        indexType: "primaryKey"
                    },
                    // 向量索引
                    {
                        fieldName: "vector",
                        fieldType: "vector",
                        indexType: collectionConfig.indexType || "HNSW",
                        dimension: collectionConfig.vectorDimension || 768,
                        metricType: collectionConfig.metricType || "COSINE",
                        params: collectionConfig.indexParam || {
                            M: 16,
                            efConstruction: 200
                        }
                    },
                    // 元数据字段索引 - 符合腾讯云向量数据库测试规范
                    {
                        fieldName: "user_id",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "device_id", 
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "workspace_path",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "file_path",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "start_line",
                        fieldType: "uint64",
                        indexType: "filter"
                    },
                    {
                        fieldName: "end_line",
                        fieldType: "uint64", 
                        indexType: "filter"
                    },
                    {
                        fieldName: "code",
                        fieldType: "string",
                        indexType: "filter"
                    },
                    {
                        fieldName: "vector_model",
                        fieldType: "string",
                        indexType: "filter"
                    }
                ]
            };
            
            const response = await this.connection.post('/collection/create', createQuery);
            
            if (response.code !== 0) {
                throw new Error(`Failed to create collection: ${response.msg}`);
            }
            
            // 清除缓存以强制重新获取
            this.collectionCache.delete(collectionName);
            
            this.logger.info(`Collection ${collectionName} created successfully`);
            
            return response;
            
        } catch (error) {
            this.logger.error(`Error creating collection ${collectionName}:`, error);
            throw error;
        }
    }

    async deleteCollection(collectionName) {
        try {
            this.logger.info(`Deleting collection ${collectionName}`);
            
            const deleteQuery = {
                database: this.connection.database,
                collection: collectionName
            };
            
            const response = await this.connection.post('/collection/drop', deleteQuery);
            
            if (response.code !== 0) {
                throw new Error(`Failed to delete collection: ${response.msg}`);
            }
            
            // 清除缓存
            this.collectionCache.delete(collectionName);
            
            this.logger.info(`Collection ${collectionName} deleted successfully`);
            
            return response;
            
        } catch (error) {
            this.logger.error(`Error deleting collection ${collectionName}:`, error);
            throw error;
        }
    }

    async listCollections() {
        try {
            const listQuery = {
                database: this.connection.database
            };
            
            const response = await this.connection.post('/collection/list', listQuery);
            
            if (response.code !== 0) {
                throw new Error(`Failed to list collections: ${response.msg}`);
            }
            
            return response.collections || [];
            
        } catch (error) {
            this.logger.error('Error listing collections:', error);
            throw error;
        }
    }

    async getCollectionStats(collectionName) {
        try {
            const statsQuery = {
                database: this.connection.database,
                collection: collectionName
            };
            
            const response = await this.connection.post('/collection/describe', statsQuery);
            
            if (response.code !== 0) {
                throw new Error(`Failed to get collection stats: ${response.msg}`);
            }
            
            return {
                documentCount: response.documentCount || 0,
                size: response.size || 0,
                dimension: response.dimension,
                metricType: response.metricType,
                indexType: response.indexType,
                ...response
            };
            
        } catch (error) {
            this.logger.error(`Error getting stats for collection ${collectionName}:`, error);
            throw error;
        }
    }

    // 内部方法
    async _checkCollectionExists(collectionName) {
        try {
            const collections = await this.listCollections();
            return collections.some(col => col.collection === collectionName);
            
        } catch (error) {
            // 如果列表操作失败，尝试直接描述集合
            try {
                await this._getCollectionInfo(collectionName);
                return true;
            } catch (describeError) {
                return false;
            }
        }
    }

    async _createCollection(collectionName) {
        return this.createCollection(collectionName);
    }

    async _getCollectionInfo(collectionName) {
        try {
            const describeQuery = {
                database: this.connection.database,
                collection: collectionName
            };
            
            const response = await this.connection.post('/collection/describe', describeQuery);
            
            if (response.code !== 0) {
                throw new Error(`Collection ${collectionName} not found`);
            }
            
            return {
                name: collectionName,
                dimension: response.dimension,
                metricType: response.metricType,
                indexType: response.indexType,
                documentCount: response.documentCount || 0,
                size: response.size || 0,
                status: response.status
            };
            
        } catch (error) {
            throw error;
        }
    }

    clearCache() {
        this.collectionCache.clear();
        this.logger.debug('Collection cache cleared');
    }
}

module.exports = CollectionManager;

/***/ }),
/* 228 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Logger = __webpack_require__(225);

class QueryBuilder {
    constructor(config) {
        this.config = config;
        this.logger = new Logger('QueryBuilder', config.logLevel);
        
        // 默认查询参数
        this.defaultParams = {
            topK: config.defaultTopK || 10,
            minScore: config.defaultMinScore || 0.7,
            maxResults: config.defaultMaxResults || 100,
            timeout: config.defaultTimeout || 5000
        };
    }

    buildSearchQuery(params) {
        try {
            const {
                collection,
                vector,
                topK = this.defaultParams.topK,
                minScore = this.defaultParams.minScore,
                filter = {},
                outputFields = ['*'],
                timeout = this.defaultParams.timeout
            } = params;

            // 验证必要参数
            if (!collection) {
                throw new Error('Collection name is required');
            }
            if (!vector || !Array.isArray(vector)) {
                throw new Error('Valid vector is required');
            }

            // 构建腾讯云向量数据库搜索查询
            const query = {
                database: this.config.database || this.config.defaultDatabase,
                collection: collection,
                vectors: [vector],  // 腾讯云API需要向量数组格式
                limit: Math.min(topK, this.defaultParams.maxResults),
                filter: this._buildTencentFilter(filter),
                outputFields: outputFields.length === 1 && outputFields[0] === '*' ? undefined : outputFields
            };

            this.logger.debug('Built search query:', query);
            return query;

        } catch (error) {
            this.logger.error('Error building search query:', error);
            throw error;
        }
    }

    buildUpsertQuery(params) {
        try {
            const {
                collection,
                documents,
                timeout = this.defaultParams.timeout
            } = params;

            // 验证必要参数
            if (!collection) {
                throw new Error('Collection name is required');
            }
            if (!documents || !Array.isArray(documents) || documents.length === 0) {
                throw new Error('Valid documents array is required');
            }

            // 构建腾讯云向量数据库API格式的查询
            const query = {
                database: this.config.database || this.config.defaultDatabase,
                collection: collection,
                documents: documents.map(doc => ({
                    // 主键
                    id: doc.id,
                    // 向量数据
                    vector: doc.vector,
                    // 腾讯云向量数据库测试规范字段
                    user_id: doc.user_id,
                    device_id: doc.device_id,
                    workspace_path: doc.workspace_path,
                    file_path: doc.file_path,
                    start_line: doc.start_line,
                    end_line: doc.end_line,
                    code: doc.code,
                    vector_model: doc.vector_model,
                    // 兼容字段
                    filePath: doc.filePath,
                    fileName: doc.fileName,
                    offset: doc.offset,
                    timestamp: doc.timestamp,
                    // 其他字段
                    ...this._buildMetadata(doc)
                })),
                buildIndex: true  // 根据API文档，默认为true
            };

            this.logger.debug('Built upsert query:', query);
            return query;

        } catch (error) {
            this.logger.error('Error building upsert query:', error);
            throw error;
        }
    }

    buildDeleteQuery(params) {
        try {
            const {
                collection,
                ids,
                filter = {},
                timeout = this.defaultParams.timeout
            } = params;

            // 验证必要参数
            if (!collection) {
                throw new Error('Collection name is required');
            }
            if ((!ids || !Array.isArray(ids) || ids.length === 0) && 
                Object.keys(filter).length === 0) {
                throw new Error('Either ids array or filter is required');
            }

            // 构建查询
            const query = {
                database: this.config.database,
                collection: collection,
                ids: ids,
                filter: this._buildFilter(filter),
                timeout: timeout
            };

            this.logger.debug('Built delete query:', query);
            return query;

        } catch (error) {
            this.logger.error('Error building delete query:', error);
            throw error;
        }
    }

    // 内部方法
    _buildFilter(filter) {
        if (!filter || Object.keys(filter).length === 0) {
            return {};
        }

        const conditions = [];
        
        for (const [field, value] of Object.entries(filter)) {
            if (typeof value === 'object' && value !== null) {
                // 处理范围查询
                if (value.$gt !== undefined || value.$gte !== undefined ||
                    value.$lt !== undefined || value.$lte !== undefined) {
                    const rangeCondition = {};
                    
                    if (value.$gt !== undefined) rangeCondition.$gt = value.$gt;
                    if (value.$gte !== undefined) rangeCondition.$gte = value.$gte;
                    if (value.$lt !== undefined) rangeCondition.$lt = value.$lt;
                    if (value.$lte !== undefined) rangeCondition.$lte = value.$lte;
                    
                    conditions.push({
                        field: field,
                        ...rangeCondition
                    });
                }
                // 处理数组查询
                else if (value.$in !== undefined) {
                    conditions.push({
                        field: field,
                        $in: value.$in
                    });
                }
            } else {
                // 处理精确匹配
                conditions.push({
                    field: field,
                    $eq: value
                });
            }
        }

        return conditions.length > 0 ? { conditions } : {};
    }

    // 腾讯云向量数据库专用过滤器构建
    _buildTencentFilter(filter) {
        if (!filter || Object.keys(filter).length === 0) {
            return undefined;
        }

        // 腾讯云向量数据库使用简单的键值对过滤格式
        const tencentFilter = {};
        
        for (const [field, value] of Object.entries(filter)) {
            if (typeof value === 'object' && value !== null) {
                // 腾讯云暂时只支持基本过滤，复杂查询可能需要转换
                if (value.$eq !== undefined) {
                    tencentFilter[field] = value.$eq;
                } else if (value.$in !== undefined && Array.isArray(value.$in) && value.$in.length > 0) {
                    tencentFilter[field] = value.$in[0]; // 取第一个值作为示例
                }
            } else {
                tencentFilter[field] = value;
            }
        }

        return Object.keys(tencentFilter).length > 0 ? tencentFilter : undefined;
    }

    _buildMetadata(vector) {
        const metadata = {};
        
        // 添加基本字段
        if (vector.filePath) metadata.filePath = vector.filePath;
        if (vector.fileName) metadata.fileName = vector.fileName;
        if (vector.offset !== undefined) metadata.offset = vector.offset;
        if (vector.timestamp) metadata.timestamp = vector.timestamp;
        
        // 添加自定义字段
        if (vector.metadata) {
            Object.assign(metadata, vector.metadata);
        }
        
        return metadata;
    }
}

module.exports = QueryBuilder;

/***/ }),
/* 229 */
/***/ ((module) => {

/**
 * Collection名称生成工具
 * 
 * 基于腾讯云向量数据库的collection命名限制
 * 实现与Python版本相同的collection名称生成逻辑
 */

/**
 * 创建符合腾讯云限制的集合名称
 * 从用户ID、设备ID和工作空间路径生成collection名称
 * 
 * @param {string} user_id - 用户标识符
 * @param {string} device_id - 设备标识符  
 * @param {string} workspace_path - 工作空间路径
 * @returns {string} Collection名称字符串
 */
function createCollectionName(user_id, device_id, workspace_path) {
    // 参数验证
    if (!user_id || !device_id || !workspace_path) {
        throw new Error('Missing required parameters: user_id, device_id, workspace_path');
    }
    
    // 清理工作空间路径 - 将所有非字母数字字符替换为下划线
    const clean_workspace = workspace_path
        .replace(/[^a-zA-Z0-9]/g, '_')  // 替换所有非字母数字字符为下划线
        .replace(/_+/g, '_')            // 多个连续下划线合并为一个
        .replace(/^_+|_+$/g, '');       // 去除首尾的下划线
    
    return `${user_id}_${device_id}_${clean_workspace}`;
}

/**
 * 验证collection名称是否符合腾讯云要求
 * 
 * @param {string} collectionName - 待验证的collection名称
 * @returns {boolean} 是否有效
 */
function validateCollectionName(collectionName) {
    if (!collectionName || typeof collectionName !== 'string') {
        return false;
    }
    
    // 腾讯云collection名称规则:
    // - 只能包含字母、数字、下划线
    // - 长度限制通常为1-64字符
    // - 不能以下划线开头或结尾
    const isValidFormat = /^[a-zA-Z0-9][a-zA-Z0-9_]*[a-zA-Z0-9]$/.test(collectionName) || 
                         /^[a-zA-Z0-9]$/.test(collectionName);
    const isValidLength = collectionName.length >= 1 && collectionName.length <= 64;
    
    return isValidFormat && isValidLength;
}

/**
 * 从collection名称中解析出组件信息
 * 
 * @param {string} collectionName - collection名称
 * @returns {Object} 解析结果 {user_id, device_id, workspace_path}
 */
function parseCollectionName(collectionName) {
    if (!collectionName || typeof collectionName !== 'string') {
        return null;
    }
    
    const parts = collectionName.split('_');
    if (parts.length < 3) {
        return null;
    }
    
    return {
        user_id: parts[0],
        device_id: parts[1],
        workspace_path: parts.slice(2).join('_')  // 重新组合workspace部分
    };
}

module.exports = {
    createCollectionName,
    validateCollectionName,
    parseCollectionName
}; 

/***/ }),
/* 230 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Logger = __webpack_require__(225);

class RetryHelper {
    constructor(config = {}) {
        this.config = config;
        this.logger = new Logger('RetryHelper', config.logLevel);
        
        // 重试配置
        this.maxRetries = config.maxRetries || 3;
        this.baseDelay = config.baseDelay || 1000; // 1秒
        this.maxDelay = config.maxDelay || 30000; // 30秒
        this.backoffFactor = config.backoffFactor || 2;
        this.jitter = config.jitter !== false; // 添加随机性
        
        // 重试条件配置
        this.retryableErrors = config.retryableErrors || [
            'ECONNRESET',
            'ETIMEDOUT', 
            'ECONNREFUSED',
            'ENETUNREACH',
            'EAI_AGAIN'
        ];
        
        this.retryableHttpCodes = config.retryableHttpCodes || [
            408, // Request Timeout
            429, // Too Many Requests
            500, // Internal Server Error
            502, // Bad Gateway
            503, // Service Unavailable
            504  // Gateway Timeout
        ];
        
        // 统计信息
        this.stats = {
            totalAttempts: 0,
            successfulRetries: 0,
            failedRetries: 0,
            totalDelayTime: 0
        };
    }

    async executeWithRetry(operation, context = '', options = {}) {
        const mergedOptions = { ...this.config, ...options };
        const maxRetries = mergedOptions.maxRetries || this.maxRetries;
        
        let lastError;
        let attempt = 0;
        
        console.log('开始重试执行，maxRetries:', maxRetries);
        
        while (attempt < maxRetries) {
            console.log('当前尝试次数:', attempt);
            try {
                attempt++;
                this.stats.totalAttempts++;
                
                console.log('执行操作，当前attempt:', attempt);
                
                if (attempt > 1) {
                    this.logger.debug(`Retry attempt ${attempt}/${maxRetries} for: ${context}`);
                }
                
                const result = await this._executeOperation(operation);
                
                if (attempt > 1) {
                    this.stats.successfulRetries++;
                    this.logger.info(`Operation succeeded after ${attempt} retries: ${context}`);
                }
                
                return result;
                
            } catch (error) {
                lastError = error;
                console.log('操作失败，当前attempt:', attempt, '错误:', error.message);
                
                if (attempt >= maxRetries) {
                    console.log('达到最大重试次数，退出循环');
                    break;
                }
                
                const delay = this._calculateDelay(attempt, mergedOptions);
                
                this.logger.warn(`Operation failed (attempt ${attempt}), retrying in ${delay}ms: ${context}`, {
                    error: error.message,
                    attempt: attempt,
                    maxRetries: maxRetries
                });
                
                await this._delay(delay);
            }
        }
        
        this.stats.failedRetries++;
        this.logger.error(`Operation failed after ${maxRetries} retries: ${context}`, {
            finalError: lastError.message,
            totalAttempts: attempt
        });
        
        throw new Error(`Operation failed after ${maxRetries} retries: ${lastError.message}`);
    }

    async executeWithCircuitBreaker(operation, context = '', circuitConfig = {}) {
        const circuitBreaker = this._getCircuitBreaker(context, circuitConfig);
        
        if (circuitBreaker.isOpen()) {
            throw new Error(`Circuit breaker is open for: ${context}`);
        }
        
        try {
            const result = await this.executeWithRetry(operation, context);
            circuitBreaker.recordSuccess();
            return result;
            
        } catch (error) {
            circuitBreaker.recordFailure();
            throw error;
        }
    }

    // 批量重试执行
    async executeBatchWithRetry(operations, context = '', options = {}) {
        const batchOptions = { ...this.config, ...options };
        const concurrency = batchOptions.concurrency || 5;
        const failFast = batchOptions.failFast !== false;
        
        const results = [];
        const errors = [];
        
        // 分批处理
        for (let i = 0; i < operations.length; i += concurrency) {
            const batch = operations.slice(i, i + concurrency);
            
            const batchPromises = batch.map(async (operation, index) => {
                try {
                    const result = await this.executeWithRetry(
                        operation, 
                        `${context}[${i + index}]`, 
                        batchOptions
                    );
                    return { index: i + index, result, success: true };
                    
                } catch (error) {
                    const errorInfo = { index: i + index, error, success: false };
                    
                    if (failFast) {
                        throw errorInfo;
                    }
                    
                    return errorInfo;
                }
            });
            
            const batchResults = await Promise.allSettled(batchPromises);
            
            for (const promiseResult of batchResults) {
                if (promiseResult.status === 'fulfilled') {
                    const operationResult = promiseResult.value;
                    
                    if (operationResult.success) {
                        results[operationResult.index] = operationResult.result;
                    } else {
                        errors.push(operationResult);
                    }
                    
                } else {
                    // failFast模式下的错误
                    throw promiseResult.reason;
                }
            }
        }
        
        return {
            results,
            errors,
            successCount: results.filter(r => r !== undefined).length,
            errorCount: errors.length
        };
    }

    // 内部方法
    async _executeOperation(operation) {
        if (typeof operation === 'function') {
            return await operation();
        } else if (operation && typeof operation.then === 'function') {
            return await operation;
        } else {
            throw new Error('Operation must be a function or Promise');
        }
    }

    _shouldRetry(error) {
        // 检查错误代码
        if (error.code && this.retryableErrors.includes(error.code)) {
            return true;
        }
        
        // 检查HTTP状态码
        if (error.response && this.retryableHttpCodes.includes(error.response.status)) {
            return true;
        }
        
        // 检查错误消息中的关键词
        const retryableKeywords = ['timeout', 'reset', 'refused', 'unavailable'];
        const errorMessage = error.message.toLowerCase();
        
        return retryableKeywords.some(keyword => errorMessage.includes(keyword));
    }

    _calculateDelay(attempt, options = {}) {
        const baseDelay = options.baseDelay || this.baseDelay;
        const maxDelay = options.maxDelay || this.maxDelay;
        const backoffFactor = options.backoffFactor || this.backoffFactor;
        const jitter = options.jitter !== false;
        
        // 指数退避
        let delay = baseDelay * Math.pow(backoffFactor, attempt);
        
        // 限制最大延迟
        delay = Math.min(delay, maxDelay);
        
        // 添加随机抖动
        if (jitter) {
            const jitterAmount = delay * 0.1; // 10%的抖动
            delay += (Math.random() - 0.5) * 2 * jitterAmount;
        }
        
        this.stats.totalDelayTime += delay;
        
        return Math.max(0, Math.floor(delay));
    }

    async _delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    _getCircuitBreaker(context, config) {
        // 简化的断路器实现
        if (!this.circuitBreakers) {
            this.circuitBreakers = new Map();
        }
        
        if (!this.circuitBreakers.has(context)) {
            this.circuitBreakers.set(context, new CircuitBreaker(config));
        }
        
        return this.circuitBreakers.get(context);
    }

    // 统计方法
    getStats() {
        return {
            ...this.stats,
            averageDelayTime: this.stats.totalAttempts > 0 ? 
                this.stats.totalDelayTime / this.stats.totalAttempts : 0
        };
    }

    resetStats() {
        this.stats = {
            totalAttempts: 0,
            successfulRetries: 0,
            failedRetries: 0,
            totalDelayTime: 0
        };
    }
}

// 简化的断路器实现
class CircuitBreaker {
    constructor(config = {}) {
        this.failureThreshold = config.failureThreshold || 5;
        this.timeout = config.timeout || 60000; // 1分钟
        this.monitoringPeriod = config.monitoringPeriod || 10000; // 10秒
        
        this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
        this.failureCount = 0;
        this.lastFailureTime = null;
        this.lastSuccessTime = null;
    }

    isOpen() {
        if (this.state === 'OPEN') {
            // 检查是否应该转为半开状态
            if (Date.now() - this.lastFailureTime > this.timeout) {
                this.state = 'HALF_OPEN';
                return false;
            }
            return true;
        }
        
        return false;
    }

    recordSuccess() {
        this.failureCount = 0;
        this.lastSuccessTime = Date.now();
        this.state = 'CLOSED';
    }

    recordFailure() {
        this.failureCount++;
        this.lastFailureTime = Date.now();
        
        if (this.failureCount >= this.failureThreshold) {
            this.state = 'OPEN';
        }
    }
}

module.exports = RetryHelper;

/***/ }),
/* 231 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const https = __webpack_require__(153);
const http = __webpack_require__(152);
const crypto = __webpack_require__(8);
const URL = (__webpack_require__(154).URL);
const backendApiConfig = __webpack_require__(124);
const config = __webpack_require__(123);

/**
 * 新版本嵌入客户端
 * 适配新的 /api/v1/codebase/embed 接口
 */
class EmbeddingClient {
    constructor(options = {}) {
        // 从现有配置系统获取配置
        const userConfig = config.getAll();
        
        // 解析API端点（支持<SERVER_IP>占位符格式）
        let apiEndpoint = options.apiEndpoint || userConfig.apiEndpoint;
        if (apiEndpoint && apiEndpoint.includes('<SERVER_IP>')) {
            const serverIP = process.env.BACKEND_API_SERVER_IP || '42.193.14.136:8087';
            const protocol = process.env.BACKEND_API_PROTOCOL || 'http';
            apiEndpoint = apiEndpoint.replace('<SERVER_IP>', serverIP);
            
            // 如果协议不匹配，更新协议
            if (apiEndpoint.startsWith('https://') && protocol === 'http') {
                apiEndpoint = apiEndpoint.replace('https://', 'http://');
            } else if (apiEndpoint.startsWith('http://') && protocol === 'https') {
                apiEndpoint = apiEndpoint.replace('http://', 'https://');
            }
        }
        
        // 解析URL获取基础信息
        const url = new URL(apiEndpoint || 'http://42.193.14.136:8087/api/v1/codebase/embed');
        this.baseURL = `${url.protocol}//${url.host}`;
        
        this.config = {
            baseURL: this.baseURL,
            token: options.token || process.env.BACKEND_API_TOKEN || userConfig.token || 'test_auth_token',
            timeout: options.timeout || userConfig.timeout || 30000,
            batchSize: options.batchSize || userConfig.batchSize || 100,
            maxRetries: options.maxRetries || userConfig.maxRetries || 3,
            retryDelay: options.retryDelay || userConfig.retryDelay || 1000,
            logLevel: options.logLevel || 'info',
        };
        
        // 新的API端点
        this.endpoints = {
            embed: '/api/v1/codebase/embed',
            upsert: '/api/v1/codebase/upsert'
        };
        
        this.stats = {
            totalRequests: 0,
            successfulRequests: 0,
            failedRequests: 0,
            totalProcessingTime: 0,
        };
        
        this._log('info', `EmbeddingClient initialized with baseURL: ${this.baseURL}`);
    }

    /**
     * 生成随机ID
     */
    _generateId() {
        return `req-${crypto.randomBytes(8).toString('hex')}`;
    }

    /**
     * 生成UUID格式的请求ID
     */
    _generateRequestId() {
        return `req-${crypto.randomBytes(8).toString('hex')}`;
    }

    /**
     * 嵌入代码块 - 新接口格式
     * @param {Array} codeBlocks - 代码块数组
     * @param {Object} options - 处理选项
     */
    async embedCodeBlocks(codeBlocks, options = {}) {
        const startTime = Date.now();
        
        try {
            // 验证并获取处理后的代码块
            const validatedBlocks = this._validateCodeBlocks(codeBlocks);
            
            // 准备新接口格式的请求数据
            const requestData = {
                requestId: this._generateRequestId(),
                uniqueId: options.uniqueId || `${Date.now()}-unknown-unknown`,
                parserVersion: options.parserVersion || "v0.1.2",
                timestamp: new Date().toISOString(),
                processingMode: options.processingMode || "sync",
                codeChunks: validatedBlocks.map(block => ({
                    chunkId: block.chunkId,
                    filePath: block.filePath,
                    language: block.language || this._detectLanguage(block.filePath),
                    startLine: block.startLine || 1,
                    endLine: block.endLine || 1,
                    content: block.content,
                    parser: block.parser || "ast_parser"
                }))
            };

            
            this._log('info', `Processing ${validatedBlocks.length} code blocks with requestId: ${requestData.requestId}`);
            
            // 发送请求到新的接口
            const response = await this._makeRequest('POST', this.endpoints.embed, requestData);
            
            const processingTime = Date.now() - startTime;
            this._updateStats(true, processingTime);
            
            // 处理响应并转换为原格式兼容
            const result = this._processNewEmbedResponse(response, validatedBlocks);
            
            this._log('info', `Successfully processed ${validatedBlocks.length} code blocks in ${processingTime}ms`);
            return result;
            
        } catch (error) {
            const processingTime = Date.now() - startTime;
            this._updateStats(false, processingTime);
            
            this._log('error', `Failed to process code blocks: ${error.message}`);
            throw error;
        }
    }

    /**
     * 获取单个查询的嵌入向量（用于搜索功能）
     * @param {string} query - 查询字符串
     * @param {Object} options - 处理选项
     */
    async getEmbedding(query, options = {}) {
        const startTime = Date.now();
        
        try {
            if (!query || typeof query !== 'string') {
                throw new Error('Query must be a non-empty string');
            }

            if (Buffer.byteLength(query, 'utf8') > 10240) { // 10KB
                throw new Error('Query exceeds 10KB limit');
            }

            this._log('info', `Getting embedding for query: "${query.substring(0, 50)}${query.length > 50 ? '...' : ''}"`);

            // 将查询包装为代码块格式以复用现有API
            const queryBlock = {
                chunkId: options.queryId || `query_${this._generateId()}`,
                filePath: 'search_query',
                language: 'text',
                startLine: 1,
                endLine: 1,
                content: query,
                parser: 'search'
            };

            // 使用embedCodeBlocks方法处理单个查询
            const result = await this.embedCodeBlocks([queryBlock], {
                ...options,
                processingMode: 'sync'
            });

            const processingTime = Date.now() - startTime;

            // 提取第一个结果的向量，支持压缩向量格式
            if (result.results && result.results.length > 0) {
                const firstResult = result.results[0];
                if (firstResult.status === 'success') {
                    this._log('info', `Successfully generated embedding for query in ${processingTime}ms`);
                    
                    // 支持压缩向量格式
                    const response = {
                        vector: firstResult.vector,
                        compressedVector: firstResult.compressedVector,
                        isCompressed: firstResult.isCompressed || false,
                        vectorDimension: firstResult.vectorDimension,
                        processingTimeMs: firstResult.processingTimeMs,
                        modelVersion: firstResult.modelVersion
                    };
                    
                    // 记录压缩向量信息
                    if (firstResult.isCompressed) {
                        this._log('info', `Query embedding is compressed: compressedVector length = ${firstResult.compressedVector ? firstResult.compressedVector.length : 'null'}`);
                    }
                    
                    return response;
                } else {
                    throw new Error(`Failed to generate embedding: ${firstResult.error}`);
                }
            } else {
                throw new Error('No embedding result returned');
            }
            
        } catch (error) {
            this._log('error', `Failed to get embedding for query: ${error.message}`);
            throw error;
        }
    }

    /**
     * 处理新接口的响应格式（支持压缩向量）
     */
    _processNewEmbedResponse(response, originalBlocks) {
        try {
            // 增强日志记录，显示完整的响应信息（强制输出）

            
            // 兼容后端返回的字段名错误：支持 "status:" 和 "status"
            const status = response.status || response['status:'];
            
            // 检查是否为成功响应
            // 如果有明确的错误字段（detail, error, message），则认为是错误响应
            const hasErrorField = response.detail || response.error || response.message;
            const isSuccessStatus = status === 'success';
            const hasSuccessFields = response.results || response.processed !== undefined;
            
            if (isSuccessStatus || (!hasErrorField && hasSuccessFields)) {
                // 处理压缩向量格式
                const processedResults = this._processCompressedVectors(response.results);
                
                return {
                    status: 'success',
                    requestId: response.requestId,
                    processed: response.processed,
                    skipped: response.skipped,
                    results: processedResults,
                    totalProcessingTimeMs: response.totalProcessingTimeMs,
                    timestamp: response.timestamp,
                    processingMode: 'sync'
                };
            } else {
                // 优先检查各种可能的错误字段
                const errorMsg = response.error || response.detail || response.message || 'Unknown error occurred';
                console.error(`🔥 [EmbeddingClient] Response indicates failure. Status: "${status}", Error: "${errorMsg}"`);
                console.error(`🔥 [EmbeddingClient] Available error fields:`, {
                    error: response.error,
                    detail: response.detail,
                    message: response.message
                });
                throw new Error(errorMsg);
            }
        } catch (error) {
            console.error(`🔥 [EmbeddingClient] Failed to process embed response: ${error.message}`);
            console.error(`🔥 [EmbeddingClient] Full response object:`, JSON.stringify(response, null, 2));
            throw error;
        }
    }

    /**
     * 处理压缩向量格式的结果
     */
    _processCompressedVectors(results) {
        if (!Array.isArray(results)) {
            return results;
        }

        return results.map(result => {
            const processedResult = { ...result };

            // 处理压缩向量
            if (result.isCompressed === true) {
                // 确保压缩格式的数据结构正确
                processedResult.vector = null;
                processedResult.compressedVector = result.compressedVector;
                processedResult.isCompressed = true;
            } else {
                // 如果不是压缩格式，使用原始向量
                processedResult.vector = result.vector;
                processedResult.compressedVector = null;
                processedResult.isCompressed = false;
            }

            return processedResult;
        });
    }

    /**
     * 验证代码块数据
     */
    _validateCodeBlocks(codeBlocks) {
        if (!Array.isArray(codeBlocks)) {
            throw new Error('codeBlocks must be an array');
        }
        
        if (codeBlocks.length === 0) {
            throw new Error('codeBlocks cannot be empty');
        }
        
        if (codeBlocks.length > 100) {
            throw new Error('codeBlocks cannot exceed 100 items');
        }
        
        const validatedBlocks = [];
        
        for (let index = 0; index < codeBlocks.length; index++) {
            const block = codeBlocks[index];
            
            // 验证必填字段
            if (!block.chunkId) {
                throw new Error(`Code block ${index}: chunkId is required`);
            }
            
            if (!block.filePath) {
                throw new Error(`Code block ${index}: filePath is required`);
            }
            
            if (block.content === undefined || block.content === null) {
                throw new Error(`Code block ${index}: content is required`);
            }
            
            // 详细记录空内容情况，但不过滤
            if (block.content === '' || block.content === null || block.content === undefined) {
                console.error(`🚨 [EmbeddingClient] 空内容代码块详情:`);
                console.error(`   索引: ${index}`);
                console.error(`   chunkId: ${block.chunkId}`);
                console.error(`   filePath: ${block.filePath}`);
                console.error(`   行号范围: ${block.startLine}-${block.endLine}`);
                console.error(`   内容类型: ${typeof block.content}`);
                console.error(`   内容值: ${JSON.stringify(block.content)}`);
                this._log('warn', `Code block ${index} (${block.chunkId}) has empty content`);
            }
            
            // 检查内容长度（10KB限制）
            const contentSize = Buffer.byteLength(block.content, 'utf8');
            if (contentSize > 10240) {
                // 自动分割超大代码块而不是抛出错误
                this._log('warn', `Code block ${index} exceeds 10KB (${contentSize} bytes), splitting automatically`);
                const splitBlocks = this._splitLargeCodeBlock(block);
                validatedBlocks.push(...splitBlocks);
            } else {
                validatedBlocks.push({
                    chunkId: block.chunkId,
                    filePath: block.filePath,
                    language: block.language || this._detectLanguage(block.filePath),
                    startLine: block.startLine || 1,
                    endLine: block.endLine || 1,
                    content: block.content,
                    parser: block.parser || 'ast_parser'
                });
            }
        }
        
        return validatedBlocks;
    }

    /**
     * 分割过大的代码块
     */
    _splitLargeCodeBlock(block, maxSize = 10240) {
        const lines = block.content.split('\n');
        const chunks = [];
        let currentLines = [];
        let currentStartLine = block.startLine || 1;
        let partIndex = 0;
        
        for (let i = 0; i < lines.length; i++) {
            currentLines.push(lines[i]);
            const currentContent = currentLines.join('\n');
            const currentSize = Buffer.byteLength(currentContent, 'utf8');
            
            // 如果达到大小限制或是最后一行
            if (currentSize >= maxSize - 100 || i === lines.length - 1) { // 留100字节余量
                if (currentSize > maxSize && currentLines.length > 1) {
                    // 移除最后一行，保存当前块
                    currentLines.pop();
                    const finalContent = currentLines.join('\n');
                    
                    chunks.push({
                        chunkId: `${block.chunkId}_part_${partIndex++}`,
                        filePath: block.filePath,
                        language: block.language || this._detectLanguage(block.filePath),
                        startLine: currentStartLine,
                        endLine: currentStartLine + currentLines.length - 1,
                        content: finalContent,
                        parser: block.parser || 'ast_parser'
                    });
                    
                    // 从当前行重新开始 - 修复Bug: 应该基于处理的行数更新起始行号
                    const processedLines = currentLines.length;
                    currentLines = [lines[i]];
                    currentStartLine = currentStartLine + processedLines;
                } else {
                    // 保存当前块
                    chunks.push({
                        chunkId: `${block.chunkId}_part_${partIndex++}`,
                        filePath: block.filePath,
                        language: block.language || this._detectLanguage(block.filePath),
                        startLine: currentStartLine,
                        endLine: currentStartLine + currentLines.length - 1,
                        content: currentContent,
                        parser: block.parser || 'ast_parser'
                    });
                    
                    // 重置 - 修复Bug: 在重置currentLines之前先保存长度
                    const processedLines = currentLines.length;
                    currentLines = [];
                    currentStartLine = currentStartLine + processedLines;
                }
            }
        }
        
        this._log('info', `Split large code block ${block.chunkId} into ${chunks.length} parts`);
        return chunks;
    }

    /**
     * 检测文件语言
     */
    _detectLanguage(filePath) {
        if (!filePath) return 'unknown';
        
        const ext = filePath.split('.').pop()?.toLowerCase();
        
        const languageMap = {
            'js': 'javascript',
            'ts': 'typescript',
            'py': 'python',
            'java': 'java',
            'cpp': 'cpp',
            'c': 'c',
            'cs': 'csharp',
            'go': 'go',
            'rs': 'rust',
            'php': 'php',
            'rb': 'ruby',
            'json': 'json',
            'yaml': 'yaml',
            'yml': 'yaml',
            'xml': 'xml',
            'html': 'html',
            'css': 'css',
            'md': 'markdown'
        };
        
        return languageMap[ext] || 'unknown';
    }

    /**
     * 发送HTTP请求
     */
    async _makeRequest(method, endpoint, data = null) {
        const requestStartTime = process.hrtime.bigint(); // 高精度请求开始时间
        const url = new URL(endpoint, this.baseURL);
        const isHttps = url.protocol === 'https:';
        
        // 特别标记upsert请求
        const isUpsertRequest = endpoint.includes('/upsert');
        
        if (isUpsertRequest) {
            console.log(`\n🌐 ===== HTTP 网络请求详情 =====`);
            console.log(`📡 URL: ${method} ${this.baseURL}${endpoint}`);
            console.log(`🔗 协议: ${isHttps ? 'HTTPS' : 'HTTP'}`);
            console.log(`🏠 主机: ${url.hostname}:${url.port || (isHttps ? 443 : 80)}`);
            console.log(`🔑 认证: Bearer ${this.config.token.substring(0, 10)}...`);
            console.log(`⏱️ 超时: ${this.config.timeout}ms`);
        }
        
        const options = {
            hostname: url.hostname,
            port: url.port || (isHttps ? 443 : 80),
            path: url.pathname + url.search,
            method: method,
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${this.config.token}`,
                'User-Agent': 'CodeChunker-EmbeddingClient/1.0.0'
            },
            timeout: this.config.timeout
        };

        if (data) {
            const postData = JSON.stringify(data);
            options.headers['Content-Length'] = Buffer.byteLength(postData);
            
            if (isUpsertRequest) {
                console.log(`📦 请求体大小: ${Buffer.byteLength(postData)} bytes`);
                console.log(`📝 Content-Length: ${options.headers['Content-Length']}`);
            }
        }

        return new Promise((resolve, reject) => {
            let connectionStartTime;
            let firstByteTime;
            let responseEndTime;
            
            const req = (isHttps ? https : http).request(options, (res) => {
                firstByteTime = process.hrtime.bigint(); // 接收到第一个字节的时间
                let responseData = '';
                
                res.on('data', (chunk) => {
                    responseData += chunk;
                });
                
                res.on('end', () => {
                    responseEndTime = process.hrtime.bigint(); // 响应完全接收完成时间
                    
                    try {
                        // 检查响应数据是否为空或不完整
                        if (!responseData || responseData.trim().length === 0) {
                            reject(new Error('Empty response from server'));
                            return;
                        }
                        
                        // 检查响应是否看起来像JSON
                        if (!responseData.trim().startsWith('{') && !responseData.trim().startsWith('[')) {
                            this._log('error', `Non-JSON response received: ${responseData.substring(0, 200)}...`);
                            reject(new Error(`Invalid response format: expected JSON, got: ${responseData.substring(0, 100)}...`));
                            return;
                        }
                        
                        const parsed = JSON.parse(responseData);
                        
                        // 计算网络通信时间
                        const totalRequestTime = Number(responseEndTime - requestStartTime) / 1000000; // 转换为毫秒
                        const serverProcessingTime = 14; // 已知的服务器内部处理时间
                        const networkCommunicationTime = totalRequestTime - serverProcessingTime;
                        
                        // 详细的时间分析
                        const connectionTime = connectionStartTime ? Number(connectionStartTime - requestStartTime) / 1000000 : 0;
                        const timeToFirstByte = Number(firstByteTime - requestStartTime) / 1000000;
                        const dataTransferTime = Number(responseEndTime - firstByteTime) / 1000000;
                        
                        // 记录网络性能分析（强制输出重要性能信息）
                        console.log(`\n📊 [网络性能分析] ${endpoint} 接口调用时间统计:`);
                        console.log(`├─ 总请求时间: ${totalRequestTime.toFixed(2)}ms`);
                        console.log(`├─ 服务器处理时间: ${serverProcessingTime}ms (已知)`);
                        console.log(`├─ 网络通信时间: ${networkCommunicationTime.toFixed(2)}ms`);
                        console.log(`├─ 连接建立时间: ${connectionTime.toFixed(2)}ms`);
                        console.log(`├─ 首字节响应时间: ${timeToFirstByte.toFixed(2)}ms`);
                        console.log(`├─ 数据传输时间: ${dataTransferTime.toFixed(2)}ms`);
                        console.log(`├─ 响应数据大小: ${Buffer.byteLength(responseData, 'utf8')} bytes`);
                        console.log(`└─ 网络通信占比: ${((networkCommunicationTime / totalRequestTime) * 100).toFixed(1)}%\n`);
                        
                        // 记录到性能分析数组中
                        if (!this.networkPerformanceData) {
                            this.networkPerformanceData = [];
                        }
                        
                        this.networkPerformanceData.push({
                            timestamp: new Date().toISOString(),
                            totalRequestTime: totalRequestTime,
                            serverProcessingTime: serverProcessingTime,
                            networkCommunicationTime: networkCommunicationTime,
                            connectionTime: connectionTime,
                            timeToFirstByte: timeToFirstByte,
                            dataTransferTime: dataTransferTime,
                            responseSize: Buffer.byteLength(responseData, 'utf8'),
                            networkRatio: (networkCommunicationTime / totalRequestTime) * 100
                        });
                        
                        // 如果有外部性能分析器，记录详细网络数据
                        if (this.performanceAnalyzer) {
                            this.performanceAnalyzer.recordDetailedNetworkRequest(
                                'embedding',
                                totalRequestTime,
                                networkCommunicationTime,
                                serverProcessingTime,
                                true
                            );
                        }
                        
                        if (isUpsertRequest) {
                            console.log(`\n📥 ===== HTTP 响应详情 =====`);
                            console.log(`📊 状态码: ${res.statusCode} ${res.statusMessage || ''}`);
                            console.log(`📋 响应头:`, JSON.stringify(res.headers, null, 2));
                            console.log(`📄 响应体:`, JSON.stringify(parsed, null, 2));
                            console.log(`📥 ============================\n`);
                        }
                        
                        if (res.statusCode >= 200 && res.statusCode < 300) {
                            resolve(parsed);
                        } else {
                            if (isUpsertRequest) {
                                console.error(`\n❌ ===== HTTP 错误响应 =====`);
                                console.error(`📊 状态码: ${res.statusCode} ${res.statusMessage || ''}`);
                                console.error(`📋 响应头:`, JSON.stringify(res.headers, null, 2));
                                console.error(`📄 错误响应体:`, JSON.stringify(parsed, null, 2));
                                console.error(`❌ ===========================\n`);
                            }
                            
                            const error = new Error(parsed.error || `HTTP ${res.statusCode}`);
                            error.statusCode = res.statusCode;
                            error.response = parsed;
                            reject(error);
                        }
                    } catch (error) {
                        this._log('error', `JSON parse error. Response length: ${responseData.length}, Content: ${responseData.substring(0, 200)}...`);
                        reject(new Error(`Failed to parse response: ${error.message}. Response was: ${responseData.substring(0, 200)}...`));
                    }
                });
            });

            req.on('connect', () => {
                connectionStartTime = process.hrtime.bigint(); // 连接建立时间
            });

            req.on('error', (error) => {
                if (isUpsertRequest) {
                    console.error(`\n💥 ===== HTTP 网络错误 =====`);
                    console.error(`📡 URL: ${method} ${this.baseURL}${endpoint}`);
                    console.error(`❌ 错误类型: ${error.constructor.name}`);
                    console.error(`📝 错误消息: ${error.message}`);
                    console.error(`🔧 错误代码: ${error.code || 'N/A'}`);
                    console.error(`📚 错误堆栈:`, error.stack);
                    console.error(`💥 ========================\n`);
                }
                reject(new Error(`Request failed: ${error.message}`));
            });

            req.on('timeout', () => {
                if (isUpsertRequest) {
                    console.error(`\n⏰ ===== HTTP 请求超时 =====`);
                    console.error(`📡 URL: ${method} ${this.baseURL}${endpoint}`);
                    console.error(`⏱️ 超时设置: ${this.config.timeout}ms`);
                    console.error(`⏰ ========================\n`);
                }
                req.destroy();
                reject(new Error('Request timeout'));
            });

            if (data) {
                req.write(JSON.stringify(data));
            }
            
            req.end();
        });
    }

    /**
     * 更新统计信息
     */
    _updateStats(success, processingTime) {
        this.stats.totalRequests++;
        if (success) {
            this.stats.successfulRequests++;
        } else {
            this.stats.failedRequests++;
        }
        this.stats.totalProcessingTime += processingTime;
    }

    /**
     * 日志记录
     */
    _log(level, message) {
        if (level === 'error' || this.config.logLevel === 'debug' || 
            (this.config.logLevel === 'info' && level === 'info')) {
    
        }
    }

    /**
     * 获取统计信息
     */
    getStats() {
        return {
            ...this.stats,
            averageProcessingTime: this.stats.totalRequests > 0 
                ? this.stats.totalProcessingTime / this.stats.totalRequests 
                : 0
        };
    }

    /**
     * 生成网络性能分析报告
     */
    generateNetworkPerformanceReport() {
        if (!this.networkPerformanceData || this.networkPerformanceData.length === 0) {
            console.log('\n📊 [网络性能报告] 暂无性能数据');
            return null;
        }

        const data = this.networkPerformanceData;
        const count = data.length;

        // 计算统计信息
        const totalRequestTimes = data.map(d => d.totalRequestTime);
        const networkTimes = data.map(d => d.networkCommunicationTime);
        const connectionTimes = data.map(d => d.connectionTime);
        const firstByteTimes = data.map(d => d.timeToFirstByte);
        const transferTimes = data.map(d => d.dataTransferTime);
        const responseSizes = data.map(d => d.responseSize);
        const networkRatios = data.map(d => d.networkRatio);

        const calculateStats = (arr) => ({
            min: Math.min(...arr),
            max: Math.max(...arr),
            avg: arr.reduce((a, b) => a + b, 0) / arr.length,
            median: arr.sort((a, b) => a - b)[Math.floor(arr.length / 2)]
        });

        const totalStats = calculateStats(totalRequestTimes);
        const networkStats = calculateStats(networkTimes);
        const connectionStats = calculateStats(connectionTimes);
        const firstByteStats = calculateStats(firstByteTimes);
        const transferStats = calculateStats(transferTimes);
        const sizeStats = calculateStats(responseSizes);
        const ratioStats = calculateStats(networkRatios);

        const report = {
            summary: {
                totalRequests: count,
                timeRange: {
                    start: data[0].timestamp,
                    end: data[data.length - 1].timestamp
                },
                serverProcessingTime: 14 // 固定值
            },
            performance: {
                totalRequestTime: totalStats,
                networkCommunicationTime: networkStats,
                connectionTime: connectionStats,
                timeToFirstByte: firstByteStats,
                dataTransferTime: transferStats,
                responseSize: sizeStats,
                networkRatio: ratioStats
            },
            rawData: data
        };

        // 输出详细报告
        console.log('\n' + '='.repeat(80));
        console.log('📊 网络性能分析报告');
        console.log('='.repeat(80));
        console.log(`\n📈 总体统计 (基于 ${count} 次请求)`);
        console.log(`├─ 时间范围: ${new Date(report.summary.timeRange.start).toLocaleString()} ~ ${new Date(report.summary.timeRange.end).toLocaleString()}`);
        console.log(`└─ 服务器处理时间: ${report.summary.serverProcessingTime}ms (固定值)\n`);

        console.log('⏱️  时间性能分析:');
        console.log(`├─ 总请求时间    : 平均 ${totalStats.avg.toFixed(2)}ms | 最小 ${totalStats.min.toFixed(2)}ms | 最大 ${totalStats.max.toFixed(2)}ms | 中位数 ${totalStats.median.toFixed(2)}ms`);
        console.log(`├─ 网络通信时间  : 平均 ${networkStats.avg.toFixed(2)}ms | 最小 ${networkStats.min.toFixed(2)}ms | 最大 ${networkStats.max.toFixed(2)}ms | 中位数 ${networkStats.median.toFixed(2)}ms`);
        console.log(`├─ 连接建立时间  : 平均 ${connectionStats.avg.toFixed(2)}ms | 最小 ${connectionStats.min.toFixed(2)}ms | 最大 ${connectionStats.max.toFixed(2)}ms | 中位数 ${connectionStats.median.toFixed(2)}ms`);
        console.log(`├─ 首字节响应时间: 平均 ${firstByteStats.avg.toFixed(2)}ms | 最小 ${firstByteStats.min.toFixed(2)}ms | 最大 ${firstByteStats.max.toFixed(2)}ms | 中位数 ${firstByteStats.median.toFixed(2)}ms`);
        console.log(`└─ 数据传输时间  : 平均 ${transferStats.avg.toFixed(2)}ms | 最小 ${transferStats.min.toFixed(2)}ms | 最大 ${transferStats.max.toFixed(2)}ms | 中位数 ${transferStats.median.toFixed(2)}ms\n`);

        console.log('📦 数据传输分析:');
        console.log(`├─ 响应数据大小  : 平均 ${(sizeStats.avg / 1024).toFixed(2)}KB | 最小 ${(sizeStats.min / 1024).toFixed(2)}KB | 最大 ${(sizeStats.max / 1024).toFixed(2)}KB`);
        console.log(`└─ 网络时间占比  : 平均 ${ratioStats.avg.toFixed(1)}% | 最小 ${ratioStats.min.toFixed(1)}% | 最大 ${ratioStats.max.toFixed(1)}%\n`);

        console.log('🎯 性能优化建议:');
        if (networkStats.avg > 100) {
            console.log('├─ ⚠️  网络通信时间较长，建议检查网络连接质量');
        }
        if (connectionStats.avg > 50) {
            console.log('├─ ⚠️  连接建立时间较长，建议考虑连接复用或更近的服务器');
        }
        if (ratioStats.avg > 70) {
            console.log('├─ ⚠️  网络时间占比过高，主要瓶颈在网络通信而非服务器处理');
        }
        if (sizeStats.avg > 100 * 1024) { // 100KB
            console.log('├─ ⚠️  响应数据较大，建议考虑数据压缩或分批处理');
        }
        if (networkStats.avg < 30 && ratioStats.avg < 50) {
            console.log('├─ ✅ 网络性能良好，主要处理时间在服务器端');
        }
        console.log('└─ 💡 持续监控这些指标有助于识别性能瓶颈和优化方向\n');

        console.log('='.repeat(80));

        return report;
    }

    /**
     * 清除网络性能数据
     */
    clearNetworkPerformanceData() {
        this.networkPerformanceData = [];
        console.log('🗑️  [网络性能] 已清除历史性能数据');
    }

    /**
     * 获取网络性能数据
     */
    getNetworkPerformanceData() {
        return this.networkPerformanceData || [];
    }
}

module.exports = EmbeddingClient;


/***/ }),
/* 232 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);
const path = __webpack_require__(4);
const KeyManager = __webpack_require__(233);
const CryptoUtils = __webpack_require__(234);
const Logger = __webpack_require__(225);

class PathEncryption {
    constructor(config = {}) {
        this.config = config;
        this.logger = new Logger('PathEncryption', config.logLevel || 'info');
        
        // 加密配置
        this.algorithm = config.algorithm || 'aes-256-ctr';
        this.nonceLength = config.nonceLength || 6; // 6字节nonce
        this.encoding = config.encoding || 'base64';
        
        // 密钥管理器
        this.keyManager = null;
        this.cryptoUtils = null;
        
        // 缓存配置
        this.enableCache = config.enableCache !== false;
        this.encryptionCache = new Map(); // path -> encrypted
        this.decryptionCache = new Map(); // encrypted -> path
        this.maxCacheSize = config.maxCacheSize || 1000;
        
        // 分隔符配置
        this.pathSeparator = config.pathSeparator || '/';
        this.extensionSeparator = config.extensionSeparator || '.';
    }

    async initialize() {
        try {
            this.logger.info('Initializing PathEncryption...');
            
            // 检查是否启用安全功能
            if (this.config.enabled === false) {
                this.logger.info('Security is disabled, PathEncryption will use passthrough mode');
                return;
            }
            
            // 1. 初始化密钥管理器
            this.keyManager = new KeyManager(this.config.keyManager);
            await this.keyManager.initialize();
            
            // 2. 初始化加密工具
            this.cryptoUtils = new CryptoUtils({
                algorithm: this.algorithm,
                nonceLength: this.nonceLength
            });
            
            // 3. 验证加密设置（仅在生产环境）
            if (process.env.NODE_ENV === 'production') {
                await this._validateEncryptionSetup();
            } else {
                this.logger.info('Skipping encryption validation in non-production environment');
            }
            
            this.logger.info('PathEncryption initialized successfully');
            
        } catch (error) {
            this.logger.error('Failed to initialize PathEncryption:', error);
            throw error;
        }
    }

    encryptPath(originalPath) {
        if (!originalPath || typeof originalPath !== 'string') {
            throw new Error('Invalid path for encryption');
        }
        
        // 如果安全功能禁用，直接返回原始路径
        if (this.config.enabled === false) {
            return originalPath;
        }
        
        try {
            // 检查缓存
            if (this.enableCache && this.encryptionCache.has(originalPath)) {
                return this.encryptionCache.get(originalPath);
            }
            
            // 标准化路径
            const normalizedPath = this._normalizePath(originalPath);
            console.log('标准化路径:', normalizedPath);
            
            // 分解路径
            const pathInfo = this._segmentPath(normalizedPath);
            console.log('路径分段结果:', JSON.stringify(pathInfo, null, 2));
            
            if (!pathInfo || !pathInfo.segments || !Array.isArray(pathInfo.segments)) {
                throw new Error('Invalid path segmentation result');
            }
            
            // 加密每个段
            const encryptedSegments = {
                isAbsolute: pathInfo.isAbsolute,
                segments: pathInfo.segments.map(segment => this._encryptSegment(segment))
            };
            
            // 重组路径
            const encryptedPath = this._reassemblePath(encryptedSegments, pathInfo.isAbsolute);
            
            // 更新缓存
            if (this.enableCache) {
                this._updateEncryptionCache(originalPath, encryptedPath);
            }
            
            this.logger.debug(`Encrypted path: ${originalPath.length} chars -> ${encryptedPath.length} chars`);
            
            return encryptedPath;
            
        } catch (error) {
            this.logger.error(`Error encrypting path "${originalPath}":`, error);
            throw error;
        }
    }

    decryptPath(encryptedPath) {
        if (!encryptedPath || typeof encryptedPath !== 'string') {
            throw new Error('Invalid encrypted path for decryption');
        }
        
        // 如果安全功能禁用，直接返回原始路径
        if (this.config.enabled === false) {
            return encryptedPath;
        }
        
        try {
            // 检查缓存
            if (this.enableCache && this.decryptionCache.has(encryptedPath)) {
                return this.decryptionCache.get(encryptedPath);
            }
            
            // 分解加密路径
            const encryptedSegments = this._segmentEncryptedPath(encryptedPath);
            console.log('加密路径分段结果:', JSON.stringify(encryptedSegments, null, 2));
            
            if (!encryptedSegments || !encryptedSegments.segments || !Array.isArray(encryptedSegments.segments)) {
                throw new Error('Invalid encrypted path segmentation result');
            }
            
            // 解密每个段
            const decryptedSegments = {
                isAbsolute: encryptedSegments.isAbsolute,
                segments: encryptedSegments.segments.map(segment => this._decryptSegment(segment))
            };
            
            // 重组原始路径
            const originalPath = this._reassembleOriginalPath(decryptedSegments, encryptedPath);
            
            // 更新缓存
            if (this.enableCache) {
                this._updateDecryptionCache(encryptedPath, originalPath);
            }
            
            this.logger.debug(`Decrypted path: ${encryptedPath.length} chars -> ${originalPath.length} chars`);
            
            return originalPath;
            
        } catch (error) {
            this.logger.error(`Error decrypting path "${encryptedPath}":`, error);
            throw error;
        }
    }

    // 批量加密
    encryptPaths(paths) {
        if (!Array.isArray(paths)) {
            throw new Error('Paths must be an array');
        }
        
        return paths.map(path => ({
            original: path,
            encrypted: this.encryptPath(path)
        }));
    }

    // 批量解密
    decryptPaths(encryptedPaths) {
        if (!Array.isArray(encryptedPaths)) {
            throw new Error('Encrypted paths must be an array');
        }
        
        return encryptedPaths.map(encryptedPath => ({
            encrypted: encryptedPath,
            decrypted: this.decryptPath(encryptedPath)
        }));
    }

    // 内部方法
    _normalizePath(pathStr) {
        // 标准化路径分隔符
        return pathStr.replace(/\\/g, this.pathSeparator);
    }

    _segmentPath(pathStr) {
        // 分解路径为段
        const segments = [];
        
        // 处理绝对路径标识
        let workingPath = pathStr;
        let isAbsolute = false;
        
        if (workingPath.startsWith(this.pathSeparator)) {
            isAbsolute = true;
            workingPath = workingPath.substring(1);
        }
        
        // 分割路径段
        const pathParts = workingPath.split(this.pathSeparator).filter(part => part.length > 0);
        
        for (const part of pathParts) {
            // 处理文件名和扩展名
            if (part.includes(this.extensionSeparator)) {
                const lastDotIndex = part.lastIndexOf(this.extensionSeparator);
                const filename = part.substring(0, lastDotIndex);
                const extension = part.substring(lastDotIndex + 1);
                
                if (filename.length > 0) {
                    segments.push({ type: 'filename', value: filename });
                }
                if (extension.length > 0) {
                    segments.push({ type: 'extension', value: extension });
                }
            } else {
                segments.push({ type: 'directory', value: part });
            }
        }
        
        return {
            isAbsolute,
            segments
        };
    }

    _encryptSegment(segment) {
        const key = this.keyManager.getEncryptionKey();
        const nonce = this._generateNonce(segment.value);
        
        // 加密数据
        const encrypted = this.cryptoUtils.encrypt(segment.value, key, nonce);
        
        // 返回加密后的段
        return {
            type: segment.type,
            value: encrypted
        };
    }

    _decryptSegment(encryptedSegment) {
        const key = this.keyManager.getEncryptionKey();
        
        try {
            // 直接传递加密字符串给cryptoUtils.decrypt
            const decrypted = this.cryptoUtils.decrypt(encryptedSegment.value, key);
            
            return {
                type: encryptedSegment.type,
                value: decrypted
            };
        } catch (error) {
            this.logger.error(`Failed to decrypt segment: ${error.message}`);
            throw error;
        }
    }

    _generateNonce(value) {
        // 生成确定性nonce
        const hash = crypto.createHash('sha256').update(value).digest();
        return hash.subarray(0, this.nonceLength);
    }

    _reassemblePath(encryptedSegments, originalPath) {
        const { isAbsolute, segments } = encryptedSegments;
        
        let path = '';
        if (isAbsolute) {
            path = this.pathSeparator;
        }
        
        let currentFileName = '';
        
        for (let i = 0; i < segments.length; i++) {
            const segment = segments[i];
            
            switch (segment.type) {
                case 'directory':
                    if (currentFileName) {
                        path += currentFileName + this.pathSeparator;
                        currentFileName = '';
                    }
                    path += segment.value + this.pathSeparator;
                    break;
                    
                case 'filename':
                    if (currentFileName) {
                        path += currentFileName + this.pathSeparator;
                    }
                    currentFileName = segment.value;
                    break;
                    
                case 'extension':
                    if (currentFileName) {
                        currentFileName += this.extensionSeparator + segment.value;
                    } else {
                        path += this.extensionSeparator + segment.value;
                    }
                    break;
            }
        }
        
        if (currentFileName) {
            path += currentFileName;
        }
        
        // 移除末尾的分隔符（如果不是根目录）
        if (path.length > 1 && path.endsWith(this.pathSeparator)) {
            path = path.substring(0, path.length - 1);
        }
        
        return path;
    }

    _segmentEncryptedPath(encryptedPath) {
        // 分解路径为段
        const segments = [];
        
        // 处理绝对路径标识
        let workingPath = encryptedPath;
        let isAbsolute = false;
        
        if (workingPath.startsWith(this.pathSeparator)) {
            isAbsolute = true;
            workingPath = workingPath.substring(1);
        }
        
        // 分割路径段
        const pathParts = workingPath.split(this.pathSeparator).filter(part => part.length > 0);
        
        for (let i = 0; i < pathParts.length; i++) {
            const part = pathParts[i];
            const isLastPart = i === pathParts.length - 1;
            
            if (isLastPart && part.includes('.')) {
                // 处理最后一个部分，它可能包含文件名和扩展名
                const parts = part.split('.');
                if (parts.length >= 2) {
                    // 第一个部分是文件名
                    segments.push({
                        type: 'filename',
                        value: parts[0] + '.' + parts[1]
                    });
                    // 第二个部分是扩展名
                    if (parts.length >= 3) {
                        segments.push({
                            type: 'extension',
                            value: parts[2] + '.' + parts[3]
                        });
                    }
                } else {
                    segments.push({
                        type: 'directory',
                        value: part
                    });
                }
            } else {
                segments.push({
                    type: 'directory',
                    value: part
                });
            }
        }
        
        return {
            isAbsolute,
            segments
        };
    }

    _reassembleOriginalPath(decryptedSegments, originalEncryptedPath) {
        return this._reassemblePath(decryptedSegments, originalEncryptedPath);
    }

    _updateEncryptionCache(original, encrypted) {
        if (this.encryptionCache.size >= this.maxCacheSize) {
            // 简单的LRU策略：删除最早的条目
            const firstKey = this.encryptionCache.keys().next().value;
            this.encryptionCache.delete(firstKey);
        }
        
        this.encryptionCache.set(original, encrypted);
    }

    _updateDecryptionCache(encrypted, decrypted) {
        if (this.decryptionCache.size >= this.maxCacheSize) {
            const firstKey = this.decryptionCache.keys().next().value;
            this.decryptionCache.delete(firstKey);
        }
        
        this.decryptionCache.set(encrypted, decrypted);
    }

    async _validateEncryptionSetup() {
        try {
            const testPath = '/test/path/file.txt';
            console.log('验证加密设置，测试路径:', testPath);
            
            // 测试路径分段
            const pathInfo = this._segmentPath(testPath);
            console.log('路径分段结果:', JSON.stringify(pathInfo, null, 2));
            
            // 测试加密
            const encrypted = this.encryptPath(testPath);
            console.log('加密结果:', encrypted);
            
            // 测试解密
            const decrypted = this.decryptPath(encrypted);
            console.log('解密结果:', decrypted);
            
            if (decrypted !== testPath) {
                throw new Error(`Encryption/decryption validation failed: ${decrypted} !== ${testPath}`);
            }
            
            this.logger.debug('Encryption setup validation passed');
            
        } catch (error) {
            console.error('加密设置验证失败:', error);
            throw new Error(`Encryption setup validation failed: ${error.message}`);
        }
    }

    // 工具方法
    clearCache() {
        this.encryptionCache.clear();
        this.decryptionCache.clear();
        this.logger.debug('Encryption cache cleared');
    }

    getCacheStats() {
        return {
            encryptionCacheSize: this.encryptionCache.size,
            decryptionCacheSize: this.decryptionCache.size,
            maxCacheSize: this.maxCacheSize
        };
    }

    async shutdown() {
        try {
            if (this.keyManager) {
                await this.keyManager.shutdown();
                this.keyManager = null;
            }
            
            if (this.enableCache) {
                this.clearCache();
            }
            
            this.logger.info('PathEncryption shutdown completed');
            
        } catch (error) {
            this.logger.error('Error during PathEncryption shutdown:', error);
        }
    }
}

module.exports = PathEncryption;

/***/ }),
/* 233 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);
const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const Logger = __webpack_require__(225);

class KeyManager {
    constructor(config = {}) {
        this.config = config;
        this.logger = new Logger('KeyManager', config.logLevel || 'info');
        
        // 密钥配置
        this.keyLength = config.keyLength || 32; // 256位密钥
        this.keyDerivationIterations = config.keyDerivationIterations || 100000;
        this.keyDerivationAlgorithm = config.keyDerivationAlgorithm || 'pbkdf2';
        
        // 存储配置
        this.keyStorePath = config.keyStorePath || path.join(process.cwd(), '.vector-keys');
        this.keyFileName = config.keyFileName || 'master.key';
        this.secureStorage = config.secureStorage !== false;
        
        // 内存中的密钥
        this.masterKey = null;
        this.derivedKeys = new Map(); // purpose -> key
        
        // 密钥轮换
        this.enableKeyRotation = config.enableKeyRotation !== false;
        
        // 根据环境设置不同的轮换间隔
        if (process.env.NODE_ENV === 'test' || process.env.NODE_ENV === 'development') {
            // 测试和开发环境：禁用自动轮换
            this.enableKeyRotation = false;
            this.keyRotationInterval = 60 * 60 * 1000; // 1小时（如果手动启用）
        } else {
            // 生产环境：30天
            this.keyRotationInterval = config.keyRotationInterval || 30 * 24 * 60 * 60 * 1000;
        }
        
        this.keyRotationTimer = null;
        
        // 如果父级配置明确禁用了VectorManager，也禁用密钥轮换
        if (config.enabled === false) {
            this.enableKeyRotation = false;
        }
    }

    
    async initialize() {
        try {
            this.logger.info('Initializing KeyManager...');
            
            // 1. 确保密钥存储目录存在
            await this._ensureKeyStoreDirectory();
            
            // 2. 加载或生成主密钥
            await this._loadOrGenerateMasterKey();
            
            // 3. 派生工作密钥
            await this._deriveWorkingKeys();
            
            // 4. 启动密钥轮换（如果启用）
            if (this.enableKeyRotation) {
                this._startKeyRotation();
            }
            
            this.logger.info('KeyManager initialized successfully');
            
        } catch (error) {
            this.logger.error('Failed to initialize KeyManager:', error);
            throw error;
        }
    }

    getEncryptionKey(purpose = 'default') {
        const key = this.derivedKeys.get(purpose);
        if (!key) {
            throw new Error(`No key found for purpose: ${purpose}`);
        }
        return key;
    }

    async generateNewKey(purpose = 'default') {
        try {
            const salt = crypto.randomBytes(16);
            const key = await this._deriveKey(this.masterKey, salt, purpose);
            
            this.derivedKeys.set(purpose, key);
            
            // 可选：持久化派生密钥信息（不包含密钥本身）
            await this._saveKeyMetadata(purpose, salt);
            
            this.logger.info(`Generated new key for purpose: ${purpose}`);
            return key;
            
        } catch (error) {
            this.logger.error(`Error generating key for purpose ${purpose}:`, error);
            throw error;
        }
    }

    async rotateKeys() {
        try {
            this.logger.info('Starting key rotation...');
            
            // 1. 生成新的主密钥
            const newMasterKey = crypto.randomBytes(this.keyLength);
            
            // 2. 备份当前密钥
            await this._backupCurrentKey();
            
            // 3. 更新主密钥
            this.masterKey = newMasterKey;
            
            // 4. 重新派生工作密钥
            await this._deriveWorkingKeys();
            
            // 5. 保存新密钥
            await this._saveMasterKey();
            
            this.logger.info('Key rotation completed successfully');
            
        } catch (error) {
            this.logger.error('Error during key rotation:', error);
            throw error;
        }
    }

    // 内部方法
    async _ensureKeyStoreDirectory() {
        try {
            await fs.ensureDir(this.keyStorePath);
            
            // 设置目录权限（仅所有者可访问）
            if (process.platform !== 'win32') {
                await fs.chmod(this.keyStorePath, 0o700);
            }
            
        } catch (error) {
            throw new Error(`Failed to create key store directory: ${error.message}`);
        }
    }

    async _loadOrGenerateMasterKey() {
        const keyFilePath = path.join(this.keyStorePath, this.keyFileName);

        try {
            if (await fs.pathExists(keyFilePath)) {
                // 加载现有密钥
                await this._loadMasterKey();
                this.logger.debug('Loaded existing master key');
            } else {
                // 生成新密钥
                await this._generateMasterKey();
                await this._saveMasterKey();
                this.logger.info('Generated new master key');
            }
            
        } catch (error) {
            console.error('加载或生成密钥失败:', error);
            throw new Error(`Failed to load or generate master key: ${error.message}`);
        }
    }

    async _generateMasterKey() {
        this.masterKey = crypto.randomBytes(this.keyLength);
    }

    async _loadMasterKey() {
        const keyFilePath = path.join(this.keyStorePath, this.keyFileName);
        
        try {
            const keyData = await fs.readFile(keyFilePath);
            
            // 检查空文件
            if (keyData.length === 0) {
                await fs.remove(keyFilePath);
                await this._generateMasterKey();
                await this._saveMasterKey();
                return;
            }
            
            if (this.secureStorage) {
                this.masterKey = this._decryptStoredKey(keyData);
            } else {
                // 如果密钥长度不足，用0填充
                if (keyData.length < this.keyLength) {
                    this.masterKey = Buffer.concat([keyData, Buffer.alloc(this.keyLength - keyData.length)]);
                } else if (keyData.length > this.keyLength) {
                    this.masterKey = keyData.slice(0, this.keyLength);
                } else {
                    this.masterKey = keyData;
                }
            }
            
            if (this.masterKey.length !== this.keyLength) {
                throw new Error(`Invalid key length: ${this.masterKey.length} (expected ${this.keyLength})`);
            }
            
        } catch (error) {
            console.error('加载密钥失败:', error);
            throw new Error(`Failed to load master key: ${error.message}`);
        }
    }

    async _saveMasterKey() {
        const keyFilePath = path.join(this.keyStorePath, this.keyFileName);
        
        try {
            let keyData = this.masterKey;
            
            if (this.secureStorage) {
                // 如果启用了安全存储，加密密钥后存储
                keyData = this._encryptKeyForStorage(this.masterKey);
            }
            
            await fs.writeFile(keyFilePath, keyData);
            
            // 设置文件权限（仅所有者可读写）
            if (process.platform !== 'win32') {
                await fs.chmod(keyFilePath, 0o600);
            }
            
        } catch (error) {
            throw new Error(`Failed to save master key: ${error.message}`);
        }
    }

    async _deriveWorkingKeys() {
        const purposes = ['default', 'path', 'metadata'];
        
        for (const purpose of purposes) {
            const salt = this._generateDeterministicSalt(purpose);
            const key = await this._deriveKey(this.masterKey, salt, purpose);
            this.derivedKeys.set(purpose, key);
        }
        
        this.logger.debug(`Derived ${purposes.length} working keys`);
    }

    async _deriveKey(masterKey, salt, purpose) {
        return new Promise((resolve, reject) => {
            crypto.pbkdf2(masterKey, salt, this.keyDerivationIterations, this.keyLength, 'sha256', (err, derivedKey) => {
                if (err) {
                    reject(new Error(`Key derivation failed for ${purpose}: ${err.message}`));
                } else {
                    resolve(derivedKey);
                }
            });
        });
    }

    _generateDeterministicSalt(purpose) {
        // 生成确定性盐值，基于用途和一些固定值
        const hash = crypto.createHash('sha256');
        hash.update(purpose);
        hash.update(this.config.applicationId || 'vectormanager');
        return hash.digest().subarray(0, 16); // 使用前16字节作为盐值
    }

    async _backupCurrentKey() {
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const backupFileName = `master_${timestamp}.key.bak`;
        const backupPath = path.join(this.keyStorePath, backupFileName);
        
        try {
            const currentKeyPath = path.join(this.keyStorePath, this.keyFileName);
            
            if (await fs.pathExists(currentKeyPath)) {
                await fs.copy(currentKeyPath, backupPath);
                this.logger.debug(`Backed up current key to ${backupFileName}`);
            }
            
        } catch (error) {
            this.logger.warn(`Failed to backup current key: ${error.message}`);
        }
    }

    async _saveKeyMetadata(purpose, salt) {
        const metadataPath = path.join(this.keyStorePath, `${purpose}.metadata`);
        
        const metadata = {
            purpose: purpose,
            salt: salt.toString('base64'),
            createdAt: new Date().toISOString(),
            algorithm: this.keyDerivationAlgorithm,
            iterations: this.keyDerivationIterations
        };
        
        try {
            await fs.writeFile(metadataPath, JSON.stringify(metadata, null, 2));
            
        } catch (error) {
            this.logger.warn(`Failed to save key metadata for ${purpose}: ${error.message}`);
        }
    }

    _encryptKeyForStorage(key) {
        // 简化实现：使用系统特定的信息作为密码
        const password = this._getSystemPassword();
        const salt = crypto.randomBytes(16);
        const iv = crypto.randomBytes(16);
        
        const derivedKey = crypto.pbkdf2Sync(password, salt, 10000, 32, 'sha256');
        const cipher = crypto.createCipheriv('aes-256-gcm', derivedKey, iv);
        
        let encrypted = cipher.update(key);
        encrypted = Buffer.concat([encrypted, cipher.final()]);
        
        const authTag = cipher.getAuthTag();
        
        // 组合 salt + iv + authTag + encrypted
        return Buffer.concat([salt, iv, authTag, encrypted]);
    }

    _decryptStoredKey(encryptedData) {
        const password = this._getSystemPassword();
        // 解析组合数据
        const salt = encryptedData.subarray(0, 16);
        const iv = encryptedData.subarray(16, 32);
        const authTag = encryptedData.subarray(32, 48);
        const encrypted = encryptedData.subarray(48);
    

    
        const derivedKey = crypto.pbkdf2Sync(password, salt, 10000, 32, 'sha256');
        const decipher = crypto.createDecipheriv('aes-256-gcm', derivedKey, iv);
        decipher.setAuthTag(authTag);
    
        let decrypted = decipher.update(encrypted);
        decrypted = Buffer.concat([decrypted, decipher.final()]);
    
        return decrypted;
    }

    _getSystemPassword() {
        // 基于系统信息生成密码（简化实现）
        const systemInfo = [
            process.platform,
            process.arch,
            (__webpack_require__(146).hostname)(),
            this.config.applicationId || 'vectormanager'
        ].join('|');
        
        return crypto.createHash('sha256').update(systemInfo).digest();
    }

    _startKeyRotation() {
        // 防止重复启动定时器
        if (this.keyRotationTimer) {
            this.logger.warn('Key rotation timer already running, skipping start');
            return;
        }
        
        // 确保轮换间隔合理（至少1分钟）
        if (this.keyRotationInterval < 60000) {
            this.logger.warn(`Key rotation interval too short: ${this.keyRotationInterval}ms, setting to 1 hour`);
            this.keyRotationInterval = 60 * 60 * 1000; // 1小时
        }
        
        this.keyRotationTimer = setInterval(async () => {
            try {
                await this.rotateKeys();
            } catch (error) {
                this.logger.error('Automatic key rotation failed:', error);
            }
        }, this.keyRotationInterval);
        
        const dayInterval = this.keyRotationInterval / 1000 / 60 / 60 / 24;
        if (dayInterval >= 1) {
            this.logger.info(`Key rotation scheduled every ${dayInterval.toFixed(1)} days`);
        } else {
            const hourInterval = this.keyRotationInterval / 1000 / 60 / 60;
            this.logger.info(`Key rotation scheduled every ${hourInterval.toFixed(1)} hours`);
        }
    }

    async shutdown() {
        if (this.keyRotationTimer) {
            clearInterval(this.keyRotationTimer);
            this.keyRotationTimer = null;
        }
        
        // 清除内存中的密钥
        if (this.masterKey) {
            this.masterKey.fill(0);
            this.masterKey = null;
        }
        
        for (const [purpose, key] of this.derivedKeys) {
            key.fill(0);
        }
        this.derivedKeys.clear();
        
        this.logger.info('KeyManager shutdown completed');
    }
}

module.exports = KeyManager;

/***/ }),
/* 234 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);

class CryptoUtils {
    constructor(config) {
        this.algorithm = config.algorithm || 'aes-256-ctr';
        this.nonceLength = config.nonceLength || 6;
        this.encoding = config.encoding || 'base64';
    }

    encrypt(plaintext, key, nonce) {
        try {
            console.log('加密参数:', {
                plaintext,
                keyLength: key.length,
                nonceLength: nonce ? nonce.length : 0
            });
            
            // 创建cipher实例
            let cipher;
            
            // 如果提供了nonce，设置初始向量
            if (nonce) {
                const iv = Buffer.alloc(16);
                nonce.copy(iv, 0, 0, Math.min(nonce.length, 16));
                console.log('使用IV:', iv.toString('hex'));
                cipher = crypto.createCipheriv(this.algorithm, key, iv);
            } else {
                // 为兼容性，如果没有nonce则使用零初始向量
                const iv = Buffer.alloc(16, 0);
                cipher = crypto.createCipheriv(this.algorithm, key, iv);
            }
            
            // 加密数据
            let encrypted = cipher.update(plaintext, 'utf8', this.encoding);
            encrypted += cipher.final(this.encoding);
            
            // 如果使用了nonce，将其添加到结果前面
            if (nonce) {
                const nonceStr = nonce.toString(this.encoding);
                const result = nonceStr + '.' + encrypted;
                console.log('加密结果:', result);
                return result;
            }
            
            console.log('加密结果:', encrypted);
            return encrypted;
            
        } catch (error) {
            console.error('加密失败:', error);
            throw new Error(`Encryption failed: ${error.message}`);
        }
    }
    
    decrypt(ciphertext, key) {
        try {
            console.log('解密参数:', {
                ciphertext,
                keyLength: key.length
            });
            
            let nonce = null;
            let encrypted = ciphertext;
            
            // 检查是否包含nonce
            if (ciphertext.includes('.')) {
                const parts = ciphertext.split('.');
                if (parts.length === 2) {
                    nonce = Buffer.from(parts[0], this.encoding);
                    encrypted = parts[1];
                    console.log('提取的nonce:', nonce.toString('hex'));
                }
            }
            
            // 创建decipher实例
            let decipher;
            if (nonce) {
                const iv = Buffer.alloc(16);
                nonce.copy(iv, 0, 0, Math.min(nonce.length, 16));
                console.log('使用IV:', iv.toString('hex'));
                decipher = crypto.createDecipheriv(this.algorithm, key, iv);
            } else {
                // 为兼容性，如果没有nonce则使用零初始向量
                const iv = Buffer.alloc(16, 0);
                decipher = crypto.createDecipheriv(this.algorithm, key, iv);
            }
            
            // 解密数据
            let decrypted = decipher.update(encrypted, this.encoding, 'utf8');
            decrypted += decipher.final('utf8');
            
            console.log('解密结果:', decrypted);
            return decrypted;
            
        } catch (error) {
            console.error('解密失败:', error);
            throw new Error(`Decryption failed: ${error.message}`);
        }
    }

    hash(data, algorithm = 'sha256') {
        try {
            return crypto.createHash(algorithm).update(data).digest('hex');
        } catch (error) {
            throw new Error(`Hashing failed: ${error.message}`);
        }
    }

    generateRandomBytes(length) {
        return crypto.randomBytes(length);
    }

    generateSecureToken(length = 32) {
        return crypto.randomBytes(length).toString('hex');
    }

    verifyIntegrity(data, expectedHash, algorithm = 'sha256') {
        const actualHash = this.hash(data, algorithm);
        return actualHash === expectedHash;
    }
}

module.exports = CryptoUtils;

/***/ }),
/* 235 */
/***/ ((module) => {

class Validator {
    constructor(config = {}) {
        this.config = config;
        this.customValidators = new Map();
        
        // 注册内置验证器
        this._registerBuiltinValidators();
    }

    // 验证对象
    validate(data, schema) {
        const errors = [];
        
        if (!schema || typeof schema !== 'object') {
            throw new Error('Schema must be an object');
        }
        
        this._validateObject(data, schema, '', errors);
        
        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }

    // 验证单个字段
    validateField(value, rules, fieldName = 'field') {
        const errors = [];
        
        if (!Array.isArray(rules)) {
            rules = [rules];
        }
        
        for (const rule of rules) {
            const result = this._applyRule(value, rule, fieldName);
            if (!result.isValid) {
                errors.push(result.error);
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }

    // 注册自定义验证器
    registerValidator(name, validatorFn) {
        if (typeof validatorFn !== 'function') {
            throw new Error('Validator must be a function');
        }
        
        this.customValidators.set(name, validatorFn);
    }

    // 内部方法
    _validateObject(data, schema, path, errors) {
        for (const [key, rules] of Object.entries(schema)) {
            const fieldPath = path ? `${path}.${key}` : key;
            const value = data ? data[key] : undefined;
            
            if (Array.isArray(rules)) {
                // 多个验证规则
                for (const rule of rules) {
                    const result = this._applyRule(value, rule, fieldPath);
                    if (!result.isValid) {
                        errors.push(result.error);
                    }
                }
            } else if (typeof rules === 'object' && rules.type) {
                // 单个验证规则
                const result = this._applyRule(value, rules, fieldPath);
                if (!result.isValid) {
                    errors.push(result.error);
                }
            } else if (typeof rules === 'object') {
                // 嵌套对象验证
                if (value && typeof value === 'object') {
                    this._validateObject(value, rules, fieldPath, errors);
                }
            }
        }
    }

    _applyRule(value, rule, fieldPath) {
        if (typeof rule === 'string') {
            // 简单类型验证
            return this._validateType(value, rule, fieldPath);
        }
        
        if (typeof rule === 'function') {
            // 自定义验证函数
            return this._validateCustom(value, rule, fieldPath);
        }
        
        if (typeof rule === 'object') {
            return this._validateComplexRule(value, rule, fieldPath);
        }
        
        return { isValid: true };
    }

    _validateType(value, type, fieldPath) {
        const validator = this.customValidators.get(type) || 
                         this._getBuiltinValidator(type);
        
        if (!validator) {
            return {
                isValid: false,
                error: `Unknown validator type: ${type} for field ${fieldPath}`
            };
        }
        
        return validator(value, fieldPath);
    }

    _validateCustom(value, validatorFn, fieldPath) {
        try {
            const result = validatorFn(value, fieldPath);
            
            if (typeof result === 'boolean') {
                return {
                    isValid: result,
                    error: result ? null : `Validation failed for field ${fieldPath}`
                };
            }
            
            return result;
            
        } catch (error) {
            return {
                isValid: false,
                error: `Validation error for field ${fieldPath}: ${error.message}`
            };
        }
    }

    _validateComplexRule(value, rule, fieldPath) {
        const errors = [];
        
        // 必填验证
        if (rule.required && (value === undefined || value === null)) {
            return {
                isValid: false,
                error: `Field ${fieldPath} is required`
            };
        }
        
        // 如果字段不是必填且值为空，跳过其他验证
        if (!rule.required && (value === undefined || value === null)) {
            return { isValid: true };
        }
        
        // 类型验证
        if (rule.type) {
            const typeResult = this._validateType(value, rule.type, fieldPath);
            if (!typeResult.isValid) {
                return typeResult;
            }
        }
        
        // 长度验证
        if (rule.minLength !== undefined || rule.maxLength !== undefined) {
            const lengthResult = this._validateLength(value, rule, fieldPath);
            if (!lengthResult.isValid) {
                errors.push(lengthResult.error);
            }
        }
        
        // 范围验证
        if (rule.min !== undefined || rule.max !== undefined) {
            const rangeResult = this._validateRange(value, rule, fieldPath);
            if (!rangeResult.isValid) {
                errors.push(rangeResult.error);
            }
        }
        
        // 正则表达式验证
        if (rule.pattern) {
            const patternResult = this._validatePattern(value, rule.pattern, fieldPath);
            if (!patternResult.isValid) {
                errors.push(patternResult.error);
            }
        }
        
        // 枚举值验证
        if (rule.enum) {
            const enumResult = this._validateEnum(value, rule.enum, fieldPath);
            if (!enumResult.isValid) {
                errors.push(enumResult.error);
            }
        }
        
        // 自定义验证器
        if (rule.validator) {
            const customResult = this._validateCustom(value, rule.validator, fieldPath);
            if (!customResult.isValid) {
                errors.push(customResult.error);
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors: errors
        };
    }

    _validateLength(value, rule, fieldPath) {
        const length = value ? value.length : 0;
        
        if (rule.minLength !== undefined && length < rule.minLength) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be at least ${rule.minLength} characters long`
            };
        }
        
        if (rule.maxLength !== undefined && length > rule.maxLength) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be no more than ${rule.maxLength} characters long`
            };
        }
        
        return { isValid: true };
    }

    _validateRange(value, rule, fieldPath) {
        const numValue = Number(value);
        
        if (isNaN(numValue)) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be a number for range validation`
            };
        }
        
        if (rule.min !== undefined && numValue < rule.min) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be at least ${rule.min}`
            };
        }
        
        if (rule.max !== undefined && numValue > rule.max) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be no more than ${rule.max}`
            };
        }
        
        return { isValid: true };
    }

    _validatePattern(value, pattern, fieldPath) {
        const regex = pattern instanceof RegExp ? pattern : new RegExp(pattern);
        
        if (!regex.test(String(value))) {
            return {
                isValid: false,
                error: `Field ${fieldPath} does not match required pattern`
            };
        }
        
        return { isValid: true };
    }

    _validateEnum(value, enumValues, fieldPath) {
        if (!enumValues.includes(value)) {
            return {
                isValid: false,
                error: `Field ${fieldPath} must be one of: ${enumValues.join(', ')}`
            };
        }
        
        return { isValid: true };
    }

    _registerBuiltinValidators() {
        // 基本类型验证器
        this.customValidators.set('string', (value, field) => ({
            isValid: typeof value === 'string',
            error: typeof value === 'string' ? null : `Field ${field} must be a string`
        }));
        
        this.customValidators.set('number', (value, field) => ({
            isValid: typeof value === 'number' && !isNaN(value),
            error: typeof value === 'number' && !isNaN(value) ? null : `Field ${field} must be a number`
        }));
        
        this.customValidators.set('boolean', (value, field) => ({
            isValid: typeof value === 'boolean',
            error: typeof value === 'boolean' ? null : `Field ${field} must be a boolean`
        }));
        
        this.customValidators.set('array', (value, field) => ({
            isValid: Array.isArray(value),
            error: Array.isArray(value) ? null : `Field ${field} must be an array`
        }));
        
        this.customValidators.set('object', (value, field) => ({
            isValid: value && typeof value === 'object' && !Array.isArray(value),
            error: value && typeof value === 'object' && !Array.isArray(value) ? null : `Field ${field} must be an object`
        }));
        
        // 特殊验证器
        this.customValidators.set('email', (value, field) => {
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return {
                isValid: emailRegex.test(value),
                error: emailRegex.test(value) ? null : `Field ${field} must be a valid email address`
            };
        });
        
        this.customValidators.set('url', (value, field) => {
            try {
                new URL(value);
                return { isValid: true };
            } catch {
                return {
                    isValid: false,
                    error: `Field ${field} must be a valid URL`
                };
            }
        });
        
        this.customValidators.set('uuid', (value, field) => {
            const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;
            return {
                isValid: uuidRegex.test(value),
                error: uuidRegex.test(value) ? null : `Field ${field} must be a valid UUID`
            };
        });
        
        this.customValidators.set('datestring', (value, field) => {
            const date = new Date(value);
            return {
                isValid: !isNaN(date.getTime()),
                error: !isNaN(date.getTime()) ? null : `Field ${field} must be a valid date string`
            };
        });
    }

    _getBuiltinValidator(type) {
        return this.customValidators.get(type);
    }
}

module.exports = Validator;

/***/ }),
/* 236 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * 腾讯云向量数据库适配器
 * 将TencentVectorDB的接口适配为VectorManager期望的标准接口
 */

const TencentVectorDB = __webpack_require__(226);
const crypto = __webpack_require__(8);

class TencentVectorDBAdapter {
    constructor(config = {}) {
        this.config = config;
        
        // 适配配置格式
        const tencentConfig = {
            username: config.username,
            apiKey: config.password, // 将password映射为apiKey
            host: this._extractHost(config.endpoint),
            port: this._extractPort(config.endpoint),
            useHttps: config.endpoint?.startsWith('https'),
            timeout: config.connectionTimeout || 30000,
            logLevel: config.logLevel || 'info'
        };
        
        this.tencentDB = new TencentVectorDB(tencentConfig);
        this.defaultDatabase = 'code_chunker_db';
        this.isInitialized = false;
    }

    _extractHost(endpoint) {
        if (!endpoint) return 'localhost';
        const url = new URL(endpoint);
        return url.hostname;
    }

    _extractPort(endpoint) {
        if (!endpoint) return 8100;
        const url = new URL(endpoint);
        return parseInt(url.port) || (endpoint.startsWith('https') ? 443 : 80);
    }

    async initialize() {
        if (this.isInitialized) {
            return;
        }

        try {
            // 初始化底层数据库连接
            await this.tencentDB.initialize();
            
            // 确保默认数据库存在
            await this._ensureDatabase(this.defaultDatabase);
            
            this.isInitialized = true;
            console.log('TencentVectorDB Adapter initialized successfully');
            
        } catch (error) {
            console.error('Failed to initialize TencentVectorDB Adapter:', error);
            throw error;
        }
    }

    async _ensureDatabase(databaseName) {
        try {
            // 尝试列出数据库，检查是否存在
            const response = await this.tencentDB.listDatabases();
            const databases = response.data?.databases || [];
            
            const exists = databases.some(db => db.database === databaseName);
            
            if (!exists) {
                console.log(`Creating database: ${databaseName}`);
                await this.tencentDB.createDatabase(databaseName);
            }
            
        } catch (error) {
            console.warn(`Error ensuring database ${databaseName}:`, error.message);
            // 不抛出错误，因为数据库可能已存在
        }
    }

    async ensureCollection(collectionName) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            // 检查集合是否存在
            const response = await this.tencentDB.listCollections(this.defaultDatabase);
            const collections = response.data?.collections || [];
            
            const existingCollection = collections.find(col => col.collection === collectionName);
            
            if (!existingCollection) {
                console.log(`Creating collection: ${collectionName}`);
                
                // 创建集合，使用代码向量化的标准配置
                const createParams = {
                    replicaNum: 0, // 腾讯云要求
                    shardNum: this.config.collections?.shards || 1,
                    description: `Code chunker collection: ${collectionName}`,
                    indexes: [
                        {
                            fieldName: "id",
                            fieldType: "string",
                            indexType: "primaryKey"
                        },
                        {
                            fieldName: "vector",
                            fieldType: "vector",
                            indexType: this.config.collections?.indexType || "IVF_FLAT",
                            dimension: this.config.collections?.defaultDimension || 768,
                            metricType: this.config.collections?.metric?.toUpperCase() || "COSINE",
                            params: {
                                nlist: 1024
                            }
                        }
                    ]
                };
                
                await this.tencentDB.createCollection(this.defaultDatabase, collectionName, createParams);
                
                // 等待索引构建完成
                await this._waitForIndexReady(collectionName);
            } else {
                // 即使集合已存在，也要检查索引是否准备好
                await this._waitForIndexReady(collectionName);
            }
            
        } catch (error) {
            console.warn(`Error ensuring collection ${collectionName}:`, error.message);
            // 不抛出错误，因为集合可能已存在
        }
    }

    async _waitForIndexReady(collectionName, maxWaitTime = 30000) {
        const startTime = Date.now();
        const checkInterval = 2000; // 2秒检查一次
        let initialStateCount = 0; // 计算处于initial状态的次数
        
        console.log(`⏳ 等待集合 ${collectionName} 的索引构建完成...`);
        
        while (Date.now() - startTime < maxWaitTime) {
            try {
                // 尝试描述集合以检查状态
                const response = await this.tencentDB.describeCollection(this.defaultDatabase, collectionName);
                
                if (response.success && response.data && response.data.collection) {
                    // 检查索引状态 - 修正路径
                    const indexStatus = response.data.collection.indexStatus?.status || 'unknown';
                    console.log(`📊 索引状态: ${indexStatus}`);
                    
                    // 腾讯云索引状态：initial -> building -> ready
                    if (indexStatus === 'ready' || indexStatus === 'normal') {
                        console.log(`✅ 集合 ${collectionName} 索引已准备就绪`);
                        return true;
                    } else if (indexStatus === 'initial') {
                        initialStateCount++;
                        console.log(`🔄 索引状态为初始状态 (${initialStateCount}/${Math.floor(maxWaitTime/checkInterval)})`);
                        
                        // 如果长时间处于initial状态，可能需要数据才能触发索引构建
                        if (initialStateCount >= 5) { // 等待10秒后
                            console.log(`💡 索引长时间处于初始状态，可能需要插入数据后才会开始构建`);
                            console.log(`✅ 继续执行，将在数据插入时触发索引构建`);
                            return true; // 允许继续执行
                        }
                    } else if (indexStatus === 'building') {
                        console.log(`🏗️ 索引正在构建中...`);
                        initialStateCount = 0; // 重置计数器
                    }
                }
                
                // 等待后再次检查
                await new Promise(resolve => setTimeout(resolve, checkInterval));
                
            } catch (error) {
                console.warn(`检查索引状态时出错: ${error.message}`);
                // 继续等待
                await new Promise(resolve => setTimeout(resolve, checkInterval));
            }
        }
        
        console.warn(`⚠️ 等待索引构建超时 (${maxWaitTime}ms)，继续执行`);
        return false;
    }

    async batchUpsert(collectionName, vectors) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            // 确保集合存在且索引准备完成
            await this.ensureCollection(collectionName);
            
            // 转换向量格式为腾讯云期望的格式，包含完整的元数据
            const documents = vectors.map(vector => ({
                id: vector.id,
                vector: vector.vector,
                
                // 基础文件信息
                filePath: vector.filePath || '',
                fileName: vector.fileName || '',
                offset: typeof vector.offset === 'number' ? vector.offset : 0,
                timestamp: typeof vector.timestamp === 'number' ? vector.timestamp : Date.now(),
                
                // 用户信息 - 关键的映射修复
                userId: vector.userId || 'unknown',
                deviceId: vector.deviceId || 'unknown', 
                workspacePath: vector.workspacePath || 'unknown',
                
                // 代码块元数据 - 从nested metadata中提取
                language: vector.language || vector.metadata?.language || 'unknown',
                startLine: vector.startLine || vector.metadata?.startLine || 0,
                endLine: vector.endLine || vector.metadata?.endLine || 0,
                content: vector.content || vector.metadata?.content || '',
                parser: vector.parser || vector.metadata?.parser || 'unknown',
                type: vector.type || vector.metadata?.type || 'code',
                
                // 向量处理信息
                vectorModel: vector.vectorModel || vector.metadata?.vectorModel || 'CoCoSoDa-v1.0',
                processingTimeMs: vector.processingTimeMs || vector.metadata?.processingTimeMs || 0,
                createdAt: vector.createdAt || vector.metadata?.createdAt || new Date().toISOString()
            }));
            
            // 智能重试机制
            const maxRetries = 3;
            let lastError = null;
            
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    // 批量上传到腾讯云
                    const response = await this.tencentDB.upsertDocuments(
                        this.defaultDatabase,
                        collectionName,
                        documents
                    );
                    
                    if (response.success) {
                        if (attempt > 1) {
                            console.log(`✅ 第${attempt}次重试成功，上传了${vectors.length}个向量`);
                        }
                        return {
                            success: true,
                            count: vectors.length,
                            collectionName: collectionName
                        };
                    } else {
                        lastError = new Error(response.error || 'Batch upsert failed');
                    }
                    
                } catch (error) {
                    lastError = error;
                    
                    // 检查是否是索引未准备好的错误
                    if (error.message.includes('current index is not ready')) {
                        console.log(`⏳ 第${attempt}次尝试：索引未准备好，等待${attempt * 2}秒后重试...`);
                        await new Promise(resolve => setTimeout(resolve, attempt * 2000));
                        continue;
                    } else {
                        // 其他类型的错误，直接失败
                        break;
                    }
                }
            }
            
            // 所有重试都失败了
            console.warn(`⚠️ 向量上传失败，已重试${maxRetries}次: ${lastError.message}`);
            return {
                success: false,
                error: lastError.message,
                count: 0
            };
            
        } catch (error) {
            console.error(`Batch upsert failed for collection ${collectionName}:`, error);
            return {
                success: false,
                error: error.message,
                count: 0
            };
        }
    }

    async search(queryVector, topK = 10, collectionName, options = {}) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            // 构建搜索参数 - 包含所有重要字段
            const searchParams = {
                limit: topK,
                outputFields: [
                    'id', 'filePath', 'fileName', 'offset', 'timestamp',
                    'userId', 'deviceId', 'workspacePath',
                    'language', 'startLine', 'endLine', 'content', 'parser', 'type',
                    'vectorModel', 'processingTimeMs', 'createdAt'
                ],
                searchParams: {
                    ef: 64  // HNSW搜索参数
                }
            };
            
            // 添加过滤条件
            if (options.filter) {
                searchParams.filter = options.filter;
            }
            
            // 执行向量搜索
            const response = await this.tencentDB.searchVectors(
                this.defaultDatabase,
                collectionName,
                queryVector, // 直接传递向量，不使用数组
                searchParams
            );
            
            if (response.success && response.data?.results) {
                // 转换结果格式，保持与VectorManager期望的格式一致
                return response.data.results.map(result => ({
                    chunkId: result.id,
                    id: result.id,
                    score: result.score,
                    similarity: result.score, // 向后兼容
                    filePath: result.filePath || '',
                    fileName: result.fileName || '',
                    startLine: result.startLine || 0,
                    endLine: result.endLine || 0,
                    content: result.content || '',
                    
                    metadata: {
                        userId: result.userId || 'unknown',
                        deviceId: result.deviceId || 'unknown',  
                        workspacePath: result.workspacePath || 'unknown',
                        language: result.language || 'unknown',
                        parser: result.parser || 'unknown',
                        type: result.type || 'code',
                        vectorModel: result.vectorModel || 'CoCoSoDa-v1.0',
                        processingTimeMs: result.processingTimeMs || 0,
                        createdAt: result.createdAt || '',
                        timestamp: result.timestamp || Date.now(),
                        offset: result.offset || 0,
                        originalScore: result.score // 原始分数
                    }
                }));
            } else {
                console.warn('Search returned no results or failed:', response);
                return [];
            }
            
        } catch (error) {
            console.error(`Search failed for collection ${collectionName}:`, error);
            return [];
        }
    }

    async deleteCollection(collectionName) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            const response = await this.tencentDB.dropCollection(this.defaultDatabase, collectionName);
            return response.success;
        } catch (error) {
            console.error(`Delete collection failed:`, error);
            return false;
        }
    }

    async getCollectionStats(collectionName) {
        if (!this.isInitialized) {
            throw new Error('TencentVectorDB Adapter not initialized');
        }

        try {
            const response = await this.tencentDB.describeCollection(this.defaultDatabase, collectionName);
            
            if (response.success && response.data) {
                return {
                    name: collectionName,
                    vectorCount: response.data.documentCount || 0,
                    dimension: this.config.collections?.defaultDimension || 768,
                    metric: this.config.collections?.metric || 'cosine'
                };
            } else {
                return null;
            }
        } catch (error) {
            console.error(`Get collection stats failed:`, error);
            return null;
        }
    }

    async shutdown() {
        try {
            if (this.tencentDB && typeof this.tencentDB.close === 'function') {
                await this.tencentDB.close();
            }
            this.isInitialized = false;
            console.log('TencentVectorDB Adapter shutdown completed');
        } catch (error) {
            console.error('Error during shutdown:', error);
        }
    }
}

module.exports = TencentVectorDBAdapter; 

/***/ }),
/* 237 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const crypto = __webpack_require__(8);

class MerkleTree {
    constructor() {
        this.leaves = [];
        this.tree = [];
    }

    /**
     * 计算单个文件的哈希值
     * @param {string} content - 文件内容
     * @returns {string} - 文件的哈希值
     */
    hashFile(content) {
        return crypto.createHash('sha256').update(content).digest('hex');
    }

    /**
     * 计算两个哈希值的组合哈希
     * @param {string} hash1 - 第一个哈希值
     * @param {string} hash2 - 第二个哈希值
     * @returns {string} - 组合后的哈希值
     */
    combineHashes(hash1, hash2) {
        return crypto.createHash('sha256')
            .update(hash1 + hash2)
            .digest('hex');
    }

    /**
     * 构建 Merkle 树
     * @param {Array<string>} fileHashes - 文件哈希值数组（已预计算）
     * @returns {Object} - 包含根哈希和完整树的对象
     */
    buildTree(fileHashes) {
        // 清空现有数据
        this.leaves = [];
        this.tree = [];

        // 直接使用已计算的哈希值作为叶节点
        this.leaves = [...fileHashes];
        this.tree.push([...this.leaves]);

        // 构建树
        let currentLevel = this.leaves;
        while (currentLevel.length > 1) {
            const nextLevel = [];
            for (let i = 0; i < currentLevel.length; i += 2) {
                if (i + 1 === currentLevel.length) {
                    // 如果是奇数个节点，复制最后一个节点
                    nextLevel.push(this.combineHashes(currentLevel[i], currentLevel[i]));
                } else {
                    nextLevel.push(this.combineHashes(currentLevel[i], currentLevel[i + 1]));
                }
            }
            this.tree.push(nextLevel);
            currentLevel = nextLevel;
        }

        return {
            rootHash: this.tree[this.tree.length - 1][0],
            tree: this.tree
        };
    }

    /**
     * 构建 Merkle 树（兼容旧版本，接收文件内容）
     * @param {Array<string>} fileContents - 文件内容数组
     * @returns {Object} - 包含根哈希和完整树的对象
     * @deprecated 请使用 buildTree(fileHashes) 以避免重复哈希计算
     */
    buildTreeFromContents(fileContents) {
        // 计算文件内容的哈希值
        const fileHashes = fileContents.map(content => this.hashFile(content));
        return this.buildTree(fileHashes);
    }

    /**
     * 获取文件的证明路径
     * @param {number} index - 文件在原始数组中的索引
     * @returns {Array<{hash: string, isLeft: boolean}>} - 证明路径
     */
    getProof(index) {
        const proof = [];
        let currentIndex = index;

        for (let level = 0; level < this.tree.length - 1; level++) {
            const isLeft = currentIndex % 2 === 0;
            const siblingIndex = isLeft ? currentIndex + 1 : currentIndex - 1;
            
            if (siblingIndex < this.tree[level].length) {
                proof.push({
                    hash: this.tree[level][siblingIndex],
                    isLeft: !isLeft
                });
            }

            currentIndex = Math.floor(currentIndex / 2);
        }

        return proof;
    }

    /**
     * 验证文件是否在树中
     * @param {string} content - 文件内容
     * @param {Array<{hash: string, isLeft: boolean}>} proof - 证明路径
     * @param {string} rootHash - 根哈希值
     * @returns {boolean} - 验证结果
     */
    verifyProof(content, proof, rootHash) {
        let hash = this.hashFile(content);

        for (const { hash: siblingHash, isLeft } of proof) {
            hash = isLeft ? 
                this.combineHashes(siblingHash, hash) : 
                this.combineHashes(hash, siblingHash);
        }

        return hash === rootHash;
    }
}

module.exports = MerkleTree; 

/***/ }),
/* 238 */
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const fs = __webpack_require__(11);
const path = __webpack_require__(4);
const os = __webpack_require__(146);

/**
 * 代码分块性能分析器
 * 监控整个处理流程中各个环节的耗时，生成详细的性能报告
 */
class PerformanceAnalyzer {
    constructor() {
        this.metrics = {
            // 总体时间
            totalTime: { start: 0, end: 0, duration: 0 },
            
            // 文件扫描阶段
            fileScanning: { start: 0, end: 0, duration: 0, fileCount: 0, skippedCount: 0 },
            
            // 文件解析阶段
            fileParsing: { 
                start: 0, end: 0, duration: 0, 
                totalFiles: 0, 
                successFiles: 0, 
                failedFiles: 0,
                workerCreationFailures: 0,
                syncProcessingCount: 0,
                workerProcessingCount: 0
            },
            
            // 分块生成阶段
            chunkGeneration: { 
                start: 0, end: 0, duration: 0, 
                totalChunks: 0,
                averageChunkSize: 0,
                largestChunk: 0
            },
            
            // Embedding生成阶段
            embeddingGeneration: { 
                start: 0, end: 0, duration: 0, 
                totalRequests: 0,
                successRequests: 0,
                failedRequests: 0,
                averageRequestTime: 0,
                batchSizes: [],
                networkCommunicationTime: 0,
                serverProcessingTime: 0
            },
            
            // 网络请求阶段 - 扩展更详细的网络监控
            networkRequests: {
                embedding: { 
                    count: 0, 
                    totalTime: 0, 
                    failures: 0, 
                    averageTime: 0,
                    minTime: Infinity,
                    maxTime: 0,
                    networkTime: 0,
                    serverTime: 0
                },
                vectorDB: { 
                    count: 0, 
                    totalTime: 0, 
                    failures: 0, 
                    averageTime: 0,
                    minTime: Infinity,
                    maxTime: 0,
                    insertOperations: 0,
                    queryOperations: 0
                }
            },
            
            // 向量数据库操作 - 细化各种操作
            vectorDatabase: { 
                start: 0, end: 0, duration: 0,
                collectionOps: { 
                    create: { count: 0, totalTime: 0 }, 
                    delete: { count: 0, totalTime: 0 }, 
                    insert: { count: 0, totalTime: 0 }, 
                    query: { count: 0, totalTime: 0 } 
                },
                insertedVectors: 0,
                batchInsertCount: 0,
                averageBatchSize: 0
            },
            
            // 模块详细耗时追踪
            moduleTimings: {
                fileScanner: { initTime: 0, scanTime: 0, filterTime: 0 },
                parserSelector: { initTime: 0, parseTime: 0, chunkTime: 0 },
                dispatcher: { initTime: 0, dispatchTime: 0, workerTime: 0 },
                sender: { initTime: 0, prepareTime: 0, sendTime: 0, batchTime: 0 },
                vectorManager: { initTime: 0, cacheTime: 0, dbTime: 0, embeddingTime: 0 },
                merkleTree: { buildTime: 0, proofTime: 0 }
            },
            
            // 系统资源使用
            systemResources: {
                initialMemory: 0,
                peakMemory: 0,
                finalMemory: 0,
                cpuUsage: [],
                processId: process.pid,
                memoryTimeline: []
            }
        };
        
        this.timers = new Map();
        this.isAnalyzing = false;
        this.reportPath = null;
        this.workspaceInfo = {};
        this.reportFolder = null; // 固定报告文件夹
    }

    /**
     * 开始性能分析
     */
    startAnalysis(workspacePath, userId, deviceId) {
        this.isAnalyzing = true;
        this.workspaceInfo = {
            path: workspacePath,
            name: path.basename(workspacePath),
            userId,
            deviceId,
            timestamp: new Date().toISOString()
        };
        
        // 创建固定的报告文件夹
        this.reportFolder = path.join(workspacePath, 'performance-reports');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T')[0] + '_' + 
                         new Date().toTimeString().split(' ')[0].replace(/:/g, '-');
        
        this.reportPath = path.join(this.reportFolder, `性能测速报告_${timestamp}.json`);
        
        this.metrics.totalTime.start = Date.now();
        this.metrics.systemResources.initialMemory = this._getMemoryUsage();
        this.metrics.systemResources.memoryTimeline.push({
            timestamp: Date.now(),
            memory: this._getMemoryUsage(),
            phase: 'start'
        });
        
        console.log(`📊 [性能分析] 开始监控项目性能 - 报告将保存到: ${this.reportFolder}`);
    }

    /**
     * 结束性能分析并生成报告
     */
    async endAnalysis() {
        if (!this.isAnalyzing) return;
        
        this.metrics.totalTime.end = Date.now();
        this.metrics.totalTime.duration = this.metrics.totalTime.end - this.metrics.totalTime.start;
        this.metrics.systemResources.finalMemory = this._getMemoryUsage();
        
        const report = await this._generateReport();
        await this._saveReport(report);
        

        
        this.isAnalyzing = false;
        return report;
    }

    /**
     * 记录文件扫描开始
     */
    startFileScanning() {
        this.metrics.fileScanning.start = Date.now();

    }

    /**
     * 记录文件扫描结束
     */
    endFileScanning(fileCount, skippedCount) {
        this.metrics.fileScanning.end = Date.now();
        this.metrics.fileScanning.duration = this.metrics.fileScanning.end - this.metrics.fileScanning.start;
        this.metrics.fileScanning.fileCount = fileCount;
        this.metrics.fileScanning.skippedCount = skippedCount;
        

    }

    /**
     * 记录文件解析开始
     */
    startFileParsing(totalFiles) {
        this.metrics.fileParsing.start = Date.now();
        this.metrics.fileParsing.totalFiles = totalFiles;

    }

    /**
     * 记录文件解析结束
     */
    endFileParsing(successFiles, failedFiles, workerFailures, syncCount, workerCount) {
        this.metrics.fileParsing.end = Date.now();
        this.metrics.fileParsing.duration = this.metrics.fileParsing.end - this.metrics.fileParsing.start;
        this.metrics.fileParsing.successFiles = successFiles;
        this.metrics.fileParsing.failedFiles = failedFiles;
        this.metrics.fileParsing.workerCreationFailures = workerFailures;
        this.metrics.fileParsing.syncProcessingCount = syncCount;
        this.metrics.fileParsing.workerProcessingCount = workerCount;
        

    }

    /**
     * 记录分块生成信息
     */
    recordChunkGeneration(totalChunks, chunkSizes) {
        this.metrics.chunkGeneration.totalChunks = totalChunks;
        if (chunkSizes && chunkSizes.length > 0) {
            this.metrics.chunkGeneration.averageChunkSize = Math.round(chunkSizes.reduce((a, b) => a + b, 0) / chunkSizes.length);
            this.metrics.chunkGeneration.largestChunk = Math.max(...chunkSizes);
        }
        

    }

    /**
     * 记录Embedding生成开始
     */
    startEmbeddingGeneration() {
        this.metrics.embeddingGeneration.start = Date.now();

    }

    /**
     * 记录Embedding生成结束
     */
    endEmbeddingGeneration(totalRequests, successRequests, failedRequests) {
        this.metrics.embeddingGeneration.end = Date.now();
        this.metrics.embeddingGeneration.duration = this.metrics.embeddingGeneration.end - this.metrics.embeddingGeneration.start;
        this.metrics.embeddingGeneration.totalRequests = totalRequests;
        this.metrics.embeddingGeneration.successRequests = successRequests;
        this.metrics.embeddingGeneration.failedRequests = failedRequests;
        
        if (totalRequests > 0) {
            this.metrics.embeddingGeneration.averageRequestTime = Math.round(this.metrics.embeddingGeneration.duration / totalRequests);
        }
        

    }

    /**
     * 记录网络请求
     */
    recordNetworkRequest(type, duration, success = true) {
        if (!this.metrics.networkRequests[type]) {
            this.metrics.networkRequests[type] = { count: 0, totalTime: 0, failures: 0, averageTime: 0 };
        }
        
        this.metrics.networkRequests[type].count++;
        this.metrics.networkRequests[type].totalTime += duration;
        if (!success) {
            this.metrics.networkRequests[type].failures++;
        }
        this.metrics.networkRequests[type].averageTime = Math.round(this.metrics.networkRequests[type].totalTime / this.metrics.networkRequests[type].count);
    }

    /**
     * 记录向量数据库操作开始
     */
    startVectorDBOperations() {
        this.metrics.vectorDatabase.start = Date.now();

    }

    /**
     * 记录向量数据库操作结束
     */
    endVectorDBOperations(insertedVectors, batchCount) {
        this.metrics.vectorDatabase.end = Date.now();
        this.metrics.vectorDatabase.duration = this.metrics.vectorDatabase.end - this.metrics.vectorDatabase.start;
        this.metrics.vectorDatabase.insertedVectors = insertedVectors;
        this.metrics.vectorDatabase.batchInsertCount = batchCount;
        

    }

    /**
     * 记录数据库操作
     */
    recordDBOperation(operation, duration = 0) {
        if (this.metrics.vectorDatabase.collectionOps[operation]) {
            this.metrics.vectorDatabase.collectionOps[operation].count++;
            this.metrics.vectorDatabase.collectionOps[operation].totalTime += duration;
        }
    }

    /**
     * 记录模块计时开始
     */
    startModuleTimer(moduleName, operation) {
        const key = `${moduleName}_${operation}`;
        this.timers.set(key, Date.now());
    }

    /**
     * 记录模块计时结束
     */
    endModuleTimer(moduleName, operation) {
        const key = `${moduleName}_${operation}`;
        const startTime = this.timers.get(key);
        if (startTime) {
            const duration = Date.now() - startTime;
            this.timers.delete(key);
            
            // 记录到模块计时中
            if (this.metrics.moduleTimings[moduleName] && this.metrics.moduleTimings[moduleName][operation] !== undefined) {
                this.metrics.moduleTimings[moduleName][operation] += duration;
            }
            
            return duration;
        }
        return 0;
    }

    /**
     * 记录网络请求详细信息（包含网络通信时间分析）
     */
    recordDetailedNetworkRequest(type, totalTime, networkTime, serverTime, success = true) {
        if (!this.metrics.networkRequests[type]) return;
        
        const metric = this.metrics.networkRequests[type];
        metric.count++;
        metric.totalTime += totalTime;
        
        if (totalTime < metric.minTime) metric.minTime = totalTime;
        if (totalTime > metric.maxTime) metric.maxTime = totalTime;
        
        if (networkTime !== undefined) metric.networkTime += networkTime;
        if (serverTime !== undefined) metric.serverTime += serverTime;
        
        if (!success) metric.failures++;
        
        metric.averageTime = Math.round(metric.totalTime / metric.count);
        
        // 更新embedding生成的网络分析数据
        if (type === 'embedding') {
            this.metrics.embeddingGeneration.networkCommunicationTime += networkTime || 0;
            this.metrics.embeddingGeneration.serverProcessingTime += serverTime || 0;
        }
    }

    /**
     * 记录内存使用情况
     */
    recordMemoryUsage(phase) {
        const currentMemory = this._getMemoryUsage();
        this.metrics.systemResources.memoryTimeline.push({
            timestamp: Date.now(),
            memory: currentMemory,
            phase: phase
        });
        
        if (currentMemory > this.metrics.systemResources.peakMemory) {
            this.metrics.systemResources.peakMemory = currentMemory;
        }
    }

    /**
     * 更新内存峰值
     */
    updatePeakMemory() {
        const currentMemory = this._getMemoryUsage();
        if (currentMemory > this.metrics.systemResources.peakMemory) {
            this.metrics.systemResources.peakMemory = currentMemory;
        }
    }

    /**
     * 获取内存使用情况
     */
    _getMemoryUsage() {
        const usage = process.memoryUsage();
        return Math.round(usage.heapUsed / 1024 / 1024); // MB
    }

    /**
     * 生成性能报告
     */
    async _generateReport() {
        const report = {
            metadata: {
                generatedAt: new Date().toISOString(),
                workspace: this.workspaceInfo,
                system: {
                    platform: os.platform(),
                    arch: os.arch(),
                    nodeVersion: process.version,
                    totalMemory: Math.round(os.totalmem() / 1024 / 1024), // MB
                    cpuCount: os.cpus().length
                }
            },
            
            summary: {
                totalDuration: this.metrics.totalTime.duration,
                totalFiles: this.metrics.fileScanning.fileCount,
                skippedFiles: this.metrics.fileScanning.skippedCount,
                processedFiles: this.metrics.fileParsing.successFiles,
                totalChunks: this.metrics.chunkGeneration.totalChunks,
                totalEmbeddingRequests: this.metrics.embeddingGeneration.totalRequests,
                insertedVectors: this.metrics.vectorDatabase.insertedVectors
            },
            
            performance: {
                breakdown: this._calculatePerformanceBreakdown(),
                bottlenecks: this._identifyBottlenecks(),
                recommendations: this._generateRecommendations()
            },
            
            detailed: this.metrics
        };

        return report;
    }

    /**
     * 计算性能分解
     */
    _calculatePerformanceBreakdown() {
        const total = this.metrics.totalTime.duration;
        if (total === 0) return {};

        return {
            fileScanning: {
                duration: this.metrics.fileScanning.duration,
                percentage: Math.round((this.metrics.fileScanning.duration / total) * 100)
            },
            fileParsing: {
                duration: this.metrics.fileParsing.duration,
                percentage: Math.round((this.metrics.fileParsing.duration / total) * 100)
            },
            embeddingGeneration: {
                duration: this.metrics.embeddingGeneration.duration,
                percentage: Math.round((this.metrics.embeddingGeneration.duration / total) * 100)
            },
            vectorDatabase: {
                duration: this.metrics.vectorDatabase.duration,
                percentage: Math.round((this.metrics.vectorDatabase.duration / total) * 100)
            }
        };
    }

    /**
     * 识别性能瓶颈
     */
    _identifyBottlenecks() {
        const breakdown = this._calculatePerformanceBreakdown();
        const bottlenecks = [];

        // 识别耗时最多的环节
        const phases = Object.entries(breakdown).sort((a, b) => b[1].percentage - a[1].percentage);
        
        if (phases.length > 0) {
            const topPhase = phases[0];
            if (topPhase[1].percentage > 40) {
                bottlenecks.push({
                    phase: topPhase[0],
                    impact: 'high',
                    percentage: topPhase[1].percentage,
                    description: this._getBottleneckDescription(topPhase[0])
                });
            }
        }

        // 检查Worker失败率
        if (this.metrics.fileParsing.workerCreationFailures > 5) {
            bottlenecks.push({
                phase: 'workerCreation',
                impact: 'medium',
                count: this.metrics.fileParsing.workerCreationFailures,
                description: 'Worker创建失败过多，影响并发处理效率'
            });
        }

        // 检查网络请求失败率
        const embeddingFailureRate = this.metrics.embeddingGeneration.failedRequests / Math.max(this.metrics.embeddingGeneration.totalRequests, 1);
        if (embeddingFailureRate > 0.1) {
            bottlenecks.push({
                phase: 'networkRequests',
                impact: 'high',
                failureRate: Math.round(embeddingFailureRate * 100),
                description: 'Embedding服务请求失败率过高'
            });
        }

        return bottlenecks;
    }

    /**
     * 获取瓶颈描述
     */
    _getBottleneckDescription(phase) {
        const descriptions = {
            fileScanning: '文件扫描耗时过长，可能是由于文件数量过多或磁盘IO性能问题',
            fileParsing: '文件解析耗时过长，可能是Worker创建失败导致同步处理过多',
            embeddingGeneration: 'Embedding生成耗时过长，可能是网络延迟或服务器响应慢',
            vectorDatabase: '向量数据库操作耗时过长，可能是网络连接或数据库性能问题'
        };
        return descriptions[phase] || '未知性能问题';
    }

    /**
     * 生成优化建议
     */
    _generateRecommendations() {
        const recommendations = [];
        const breakdown = this._calculatePerformanceBreakdown();

        // 基于瓶颈给出建议
        if (breakdown.fileScanning.percentage > 30) {
            recommendations.push({
                category: 'fileScanning',
                priority: 'medium',
                suggestion: '考虑增加更多文件类型到忽略列表，或启用更激进的智能筛选',
                impact: '可减少文件扫描时间20-40%'
            });
        }

        if (breakdown.embeddingGeneration.percentage > 50) {
            recommendations.push({
                category: 'embedding',
                priority: 'high',
                suggestion: '考虑增加批处理大小、使用本地embedding服务或切换到更快的embedding模型',
                impact: '可减少embedding生成时间30-60%'
            });
        }

        if (this.metrics.fileParsing.workerCreationFailures > this.metrics.fileParsing.totalFiles * 0.3) {
            recommendations.push({
                category: 'workerOptimization',
                priority: 'high',
                suggestion: '减少最大Worker数量，优化Worker创建策略，或完全使用同步处理',
                impact: '可提高处理稳定性和速度'
            });
        }

        if (breakdown.vectorDatabase.percentage > 25) {
            recommendations.push({
                category: 'vectorDB',
                priority: 'medium',
                suggestion: '考虑增加批量插入大小、优化网络连接或使用本地向量数据库',
                impact: '可减少数据库操作时间20-50%'
            });
        }

        return recommendations;
    }

    /**
     * 保存报告到文件
     */
    async _saveReport(report) {
        try {
            await fs.ensureDir(path.dirname(this.reportPath));
            await fs.writeJson(this.reportPath, report, { spaces: 2 });
            
            // 同时生成一个简化的markdown报告
            const markdownPath = this.reportPath.replace('.json', '.md');
            await this._generateMarkdownReport(report, markdownPath);
            
        } catch (error) {
            console.error('❌ [PerformanceAnalyzer] 保存报告失败:', error);
        }
    }

    /**
     * 生成Markdown格式的报告
     */
    async _generateMarkdownReport(report, markdownPath) {
        const formatTime = (ms) => {
            if (ms >= 1000) return `${(ms / 1000).toFixed(2)}s`;
            return `${ms.toFixed(0)}ms`;
        };

        const formatMemory = (mb) => {
            if (mb >= 1024) return `${(mb / 1024).toFixed(2)}GB`;
            return `${mb.toFixed(0)}MB`;
        };

        // 计算各模块的总耗时和占比
        const moduleTimings = report.detailed.moduleTimings || {};

        const md = `# 🚀 智能代码分块工具 - 性能测速报告

## 📊 项目基本信息
- **项目名称**: ${report.metadata.workspace.name}
- **项目路径**: \`${report.metadata.workspace.path}\`
- **用户ID**: ${report.metadata.workspace.userId}
- **设备ID**: ${report.metadata.workspace.deviceId}
- **分析时间**: ${new Date(report.metadata.generatedAt).toLocaleString('zh-CN')}
- **总处理时间**: **${formatTime(report.summary.totalDuration)}**

## 📈 处理结果统计
| 指标 | 数量 | 备注 |
|------|------|------|
| 📁 扫描文件总数 | ${report.summary.totalFiles} | 符合条件的代码文件 |
| ⏭️ 跳过文件数 | ${report.summary.skippedFiles} | 被过滤器排除的文件 |
| ✅ 成功处理文件 | ${report.summary.processedFiles} | 成功解析并分块的文件 |
| 🧩 生成代码块 | ${report.summary.totalChunks} | 总共生成的代码分块数 |
| 🌐 Embedding请求 | ${report.summary.totalEmbeddingRequests} | 发送给向量化服务的请求数 |
| 📊 插入向量数 | ${report.summary.insertedVectors} | 成功插入数据库的向量数 |

## ⏱️ 各阶段性能分解
| 阶段 | 耗时 | 占总时间比例 | 状态 |
|------|------|-------------|------|
| 🔍 文件扫描 | ${formatTime(report.performance.breakdown.fileScanning?.duration || 0)} | ${report.performance.breakdown.fileScanning?.percentage || 0}% | ${(report.performance.breakdown.fileScanning?.percentage || 0) < 10 ? '✅ 良好' : (report.performance.breakdown.fileScanning?.percentage || 0) < 30 ? '⚠️ 一般' : '🔴 较慢'} |
| 🔧 文件解析 | ${formatTime(report.performance.breakdown.fileParsing?.duration || 0)} | ${report.performance.breakdown.fileParsing?.percentage || 0}% | ${(report.performance.breakdown.fileParsing?.percentage || 0) < 20 ? '✅ 良好' : (report.performance.breakdown.fileParsing?.percentage || 0) < 40 ? '⚠️ 一般' : '🔴 较慢'} |
| 🧠 Embedding生成 | ${formatTime(report.performance.breakdown.embeddingGeneration?.duration || 0)} | ${report.performance.breakdown.embeddingGeneration?.percentage || 0}% | ${(report.performance.breakdown.embeddingGeneration?.percentage || 0) < 40 ? '✅ 良好' : (report.performance.breakdown.embeddingGeneration?.percentage || 0) < 60 ? '⚠️ 一般' : '🔴 较慢'} |
| 🗄️ 向量数据库 | ${formatTime(report.performance.breakdown.vectorDatabase?.duration || 0)} | ${report.performance.breakdown.vectorDatabase?.percentage || 0}% | ${(report.performance.breakdown.vectorDatabase?.percentage || 0) < 20 ? '✅ 良好' : (report.performance.breakdown.vectorDatabase?.percentage || 0) < 40 ? '⚠️ 一般' : '🔴 较慢'} |

## 🔧 模块详细耗时分析

### 📂 FileScanner (文件扫描器)
- **初始化时间**: ${formatTime(moduleTimings.fileScanner?.initTime || 0)}
- **扫描时间**: ${formatTime(moduleTimings.fileScanner?.scanTime || 0)}
- **过滤时间**: ${formatTime(moduleTimings.fileScanner?.filterTime || 0)}

### 🔍 ParserSelector (解析器选择器)
- **初始化时间**: ${formatTime(moduleTimings.parserSelector?.initTime || 0)}
- **解析时间**: ${formatTime(moduleTimings.parserSelector?.parseTime || 0)}
- **分块时间**: ${formatTime(moduleTimings.parserSelector?.chunkTime || 0)}

### 🚀 Dispatcher (任务调度器)
- **初始化时间**: ${formatTime(moduleTimings.dispatcher?.initTime || 0)}
- **调度时间**: ${formatTime(moduleTimings.dispatcher?.dispatchTime || 0)}
- **Worker处理时间**: ${formatTime(moduleTimings.dispatcher?.workerTime || 0)}

### 📤 Sender (数据发送器)
- **初始化时间**: ${formatTime(moduleTimings.sender?.initTime || 0)}
- **准备时间**: ${formatTime(moduleTimings.sender?.prepareTime || 0)}
- **发送时间**: ${formatTime(moduleTimings.sender?.sendTime || 0)}
- **批处理时间**: ${formatTime(moduleTimings.sender?.batchTime || 0)}

### 📊 VectorManager (向量管理器)
- **初始化时间**: ${formatTime(moduleTimings.vectorManager?.initTime || 0)}
- **缓存操作时间**: ${formatTime(moduleTimings.vectorManager?.cacheTime || 0)}
- **数据库操作时间**: ${formatTime(moduleTimings.vectorManager?.dbTime || 0)}
- **向量化时间**: ${formatTime(moduleTimings.vectorManager?.embeddingTime || 0)}

### 🌳 MerkleTree (默克尔树)
- **构建时间**: ${formatTime(moduleTimings.merkleTree?.buildTime || 0)}
- **证明生成时间**: ${formatTime(moduleTimings.merkleTree?.proofTime || 0)}

## 🌐 网络性能分析

### Embedding服务网络表现
- **总请求数**: ${report.detailed.networkRequests.embedding?.count || 0}
- **总网络时间**: ${formatTime(report.detailed.networkRequests.embedding?.totalTime || 0)}
- **平均请求时间**: ${formatTime(report.detailed.networkRequests.embedding?.averageTime || 0)}
- **最快请求**: ${formatTime(report.detailed.networkRequests.embedding?.minTime === Infinity ? 0 : report.detailed.networkRequests.embedding?.minTime || 0)}
- **最慢请求**: ${formatTime(report.detailed.networkRequests.embedding?.maxTime || 0)}
- **失败次数**: ${report.detailed.networkRequests.embedding?.failures || 0}
- **成功率**: ${report.detailed.networkRequests.embedding?.count > 0 ? (((report.detailed.networkRequests.embedding.count - (report.detailed.networkRequests.embedding.failures || 0)) / report.detailed.networkRequests.embedding.count) * 100).toFixed(1) : 0}%

### 向量数据库网络表现
- **总请求数**: ${report.detailed.networkRequests.vectorDB?.count || 0}
- **总网络时间**: ${formatTime(report.detailed.networkRequests.vectorDB?.totalTime || 0)}
- **平均请求时间**: ${formatTime(report.detailed.networkRequests.vectorDB?.averageTime || 0)}
- **插入操作数**: ${report.detailed.networkRequests.vectorDB?.insertOperations || 0}
- **查询操作数**: ${report.detailed.networkRequests.vectorDB?.queryOperations || 0}
- **失败次数**: ${report.detailed.networkRequests.vectorDB?.failures || 0}

## 🗄️ 数据库操作详情
| 操作类型 | 执行次数 | 总耗时 | 平均耗时 |
|---------|---------|--------|----------|
| 创建集合 | ${report.detailed.vectorDatabase.collectionOps?.create?.count || 0} | ${formatTime(report.detailed.vectorDatabase.collectionOps?.create?.totalTime || 0)} | ${report.detailed.vectorDatabase.collectionOps?.create?.count > 0 ? formatTime((report.detailed.vectorDatabase.collectionOps.create.totalTime || 0) / report.detailed.vectorDatabase.collectionOps.create.count) : '0ms'} |
| 删除集合 | ${report.detailed.vectorDatabase.collectionOps?.delete?.count || 0} | ${formatTime(report.detailed.vectorDatabase.collectionOps?.delete?.totalTime || 0)} | ${report.detailed.vectorDatabase.collectionOps?.delete?.count > 0 ? formatTime((report.detailed.vectorDatabase.collectionOps.delete.totalTime || 0) / report.detailed.vectorDatabase.collectionOps.delete.count) : '0ms'} |
| 插入向量 | ${report.detailed.vectorDatabase.collectionOps?.insert?.count || 0} | ${formatTime(report.detailed.vectorDatabase.collectionOps?.insert?.totalTime || 0)} | ${report.detailed.vectorDatabase.collectionOps?.insert?.count > 0 ? formatTime((report.detailed.vectorDatabase.collectionOps.insert.totalTime || 0) / report.detailed.vectorDatabase.collectionOps.insert.count) : '0ms'} |
| 查询向量 | ${report.detailed.vectorDatabase.collectionOps?.query?.count || 0} | ${formatTime(report.detailed.vectorDatabase.collectionOps?.query?.totalTime || 0)} | ${report.detailed.vectorDatabase.collectionOps?.query?.count > 0 ? formatTime((report.detailed.vectorDatabase.collectionOps.query.totalTime || 0) / report.detailed.vectorDatabase.collectionOps.query.count) : '0ms'} |

## 🚨 性能瓶颈识别
${report.performance.bottlenecks.length > 0 ? 
  report.performance.bottlenecks.map(b => `### ${b.impact === 'high' ? '🔴' : b.impact === 'medium' ? '🟡' : '🟢'} ${b.phase} (${b.impact === 'high' ? '高影响' : b.impact === 'medium' ? '中等影响' : '低影响'})
- **问题**: ${b.description}
- **影响程度**: ${b.percentage ? `占总时间 ${b.percentage}%` : b.failureRate ? `失败率 ${b.failureRate}%` : b.count ? `失败 ${b.count} 次` : '影响较小'}`).join('\n\n') : 
  '✅ 未检测到明显的性能瓶颈，整体运行良好！'
}

## 💡 性能优化建议
${report.performance.recommendations.length > 0 ? 
  report.performance.recommendations.map(r => `### ${r.priority === 'high' ? '🔴' : r.priority === 'medium' ? '🟡' : '🟢'} ${r.category} (${r.priority === 'high' ? '高优先级' : r.priority === 'medium' ? '中优先级' : '低优先级'})
- **建议**: ${r.suggestion}
- **预期效果**: ${r.impact}`).join('\n\n') : 
  '✅ 当前性能表现良好，暂无特殊优化建议。'
}

## 🖥️ 系统环境信息
- **操作系统**: ${report.metadata.system.platform} (${report.metadata.system.arch})
- **Node.js版本**: ${report.metadata.system.nodeVersion}
- **CPU核心数**: ${report.metadata.system.cpuCount}
- **系统总内存**: ${formatMemory(report.metadata.system.totalMemory)}
- **进程ID**: ${report.detailed.systemResources.processId}

## 📊 内存使用情况
- **初始内存**: ${formatMemory(report.detailed.systemResources.initialMemory)}
- **峰值内存**: ${formatMemory(report.detailed.systemResources.peakMemory)}
- **结束内存**: ${formatMemory(report.detailed.systemResources.finalMemory)}
- **内存增长**: ${formatMemory(report.detailed.systemResources.finalMemory - report.detailed.systemResources.initialMemory)}

## 📈 性能评分

### 🎯 总体性能评分
${this._calculatePerformanceScore(report)}/100 分

### 📋 评分说明
- **90-100分**: 🏆 优秀 - 性能表现卓越
- **80-89分**: 🥇 良好 - 性能表现良好
- **70-79分**: 🥈 一般 - 性能可接受，有优化空间
- **60-69分**: 🥉 较差 - 存在明显性能问题
- **<60分**: ❌ 差 - 需要立即优化

---

**📋 报告生成时间**: ${new Date().toLocaleString('zh-CN')}  
**🔧 生成工具**: 智能代码分块工具 v0.1.0  
**📁 报告位置**: \`${markdownPath}\`

> 💡 **提示**: 此报告包含了项目处理的详细性能数据，建议定期生成报告以监控性能趋势。如有性能问题，请参考上述优化建议进行改进。
`;

        await fs.writeFile(markdownPath, md, 'utf8');
        console.log(`📄 [性能分析] 详细测速报告已生成: ${markdownPath}`);
    }

    /**
     * 计算性能评分
     */
    _calculatePerformanceScore(report) {
        let score = 100;
        
        // 根据各阶段耗时占比扣分
        const breakdown = report.performance.breakdown;
        if (breakdown.fileScanning?.percentage > 30) score -= 10;
        if (breakdown.fileParsing?.percentage > 40) score -= 15;
        if (breakdown.embeddingGeneration?.percentage > 60) score -= 20;
        if (breakdown.vectorDatabase?.percentage > 40) score -= 15;
        
        // 根据失败率扣分
        const embeddingFailureRate = (report.detailed.embeddingGeneration.failedRequests || 0) / 
                                   Math.max(report.detailed.embeddingGeneration.totalRequests || 1, 1);
        if (embeddingFailureRate > 0.1) score -= 20;
        if (embeddingFailureRate > 0.05) score -= 10;
        
        // 根据Worker失败率扣分
        const workerFailureRate = (report.detailed.fileParsing.workerCreationFailures || 0) / 
                                 Math.max(report.detailed.fileParsing.totalFiles || 1, 1);
        if (workerFailureRate > 0.3) score -= 15;
        if (workerFailureRate > 0.1) score -= 5;
        
        return Math.max(score, 0);
    }
}

module.exports = PerformanceAnalyzer; 

/***/ }),
/* 239 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerSearchCommands = registerSearchCommands;
const vscode = __importStar(__webpack_require__(2));
const searchService_1 = __webpack_require__(240);
let searchService;
/**
 * 注册搜索相关的所有命令
 */
function registerSearchCommands(context) {
    // 初始化服务
    searchService = new searchService_1.SearchService();
    // 注册智能代码搜索命令
    const searchCodeCommand = vscode.commands.registerCommand('test-electron-treesitter.searchCode', async (searchString) => {
        try {
            await searchService.performCodeSearch(searchString);
        }
        catch (error) {
            console.error('[CodeChunker] 代码搜索错误:', error);
            vscode.window.showErrorMessage(`代码搜索失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // 注册配置命令
    const configureCommand = vscode.commands.registerCommand('test-electron-treesitter.configure', async () => {
        try {
            await searchService.showConfiguration();
        }
        catch (error) {
            console.error('[CodeChunker] 配置错误:', error);
            vscode.window.showErrorMessage(`配置失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // 注册删除Collection命令
    const deleteCollectionCommand = vscode.commands.registerCommand('test-electron-treesitter.deleteCollection', async () => {
        try {
            await searchService.deleteCloudCollection();
        }
        catch (error) {
            console.error('[CodeChunker] 删除Collection错误:', error);
            vscode.window.showErrorMessage(`删除Collection失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    });
    // 保留原有的 Hello World 命令
    const helloWorldCommand = vscode.commands.registerCommand('test-electron-treesitter.helloWorld', () => {
        vscode.window.showInformationMessage('Hello World from test-electron-treeSitter!');
    });
    context.subscriptions.push(searchCodeCommand, configureCommand, deleteCollectionCommand, helloWorldCommand);
    console.log('[CodeChunker] 搜索相关命令已注册');
}


/***/ }),
/* 240 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchService = void 0;
const vscode = __importStar(__webpack_require__(2));
const path = __importStar(__webpack_require__(4));
const searchResultView_1 = __webpack_require__(241);
const commonViews_1 = __webpack_require__(6);
// 导入 code-chunker 模块
const codeChunker = __webpack_require__(9);
class SearchService {
    /**
     * 执行智能代码搜索
     */
    async performCodeSearch(searchString) {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('请先打开一个工作区');
            return "请先打开一个工作区";
        }
        // 获取配置
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        // 检查必要的配置
        if (!userId || !deviceId || !token) {
            const result = await vscode.window.showErrorMessage('缺少必要的配置信息（用户ID、设备ID或Token），是否现在配置？', '去配置', '取消');
            if (result === '去配置') {
                await this.showConfiguration();
            }
            return;
        }
        // 获取搜索查询 - 支持传入参数或弹出输入框
        let searchQuery;
        if (searchString && searchString.trim().length > 0) {
            // 使用传入的搜索字符串
            searchQuery = searchString.trim();
            // 验证传入的搜索字符串
            if (searchQuery.length < 2) {
                vscode.window.showErrorMessage('搜索关键词至少需要2个字符');
                return;
            }
        }
        else {
            // 没有传入参数，显示输入框
            const inputResult = await vscode.window.showInputBox({
                prompt: '请输入搜索关键词',
                placeHolder: '例如: function, class, import, 等...',
                validateInput: (value) => {
                    if (!value || value.trim().length === 0) {
                        return '搜索关键词不能为空';
                    }
                    if (value.trim().length < 2) {
                        return '搜索关键词至少需要2个字符';
                    }
                    return null;
                }
            });
            if (!inputResult) {
                return; // 用户取消了输入
            }
            searchQuery = inputResult.trim();
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        const workspaceName = path.basename(workspacePath);
        // 显示搜索进度
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: '智能代码搜索中...',
            cancellable: false
        }, async (progress) => {
            try {
                progress.report({ increment: 0, message: '初始化搜索环境...' });
                // 获取chunker实例
                const chunkerInstance = codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
                progress.report({ increment: 20, message: '连接向量数据库...' });
                // 确保VectorManager已初始化
                if (!chunkerInstance.vectorManager) {
                    throw new Error('VectorManager未初始化，请先运行代码分块处理');
                }
                await chunkerInstance.vectorManager.initialize();
                if (!chunkerInstance.vectorManager.vectorDB || !chunkerInstance.vectorManager.vectorDB.implementation) {
                    throw new Error('向量数据库连接失败，请检查配置或先运行代码分块');
                }
                progress.report({ increment: 40, message: '执行向量搜索...' });
                // 执行搜索
                if (!chunkerInstance.search || typeof chunkerInstance.search !== 'function') {
                    throw new Error('搜索功能未可用，请先运行代码分块处理');
                }
                const searchResults = await chunkerInstance.search(searchQuery, { topK: 10 });
                progress.report({ increment: 80, message: '处理搜索结果...' });
                if (!searchResults || searchResults.length === 0) {
                    vscode.window.showInformationMessage(`未找到与"${searchQuery}"相关的代码片段`);
                    return;
                }
                progress.report({ increment: 100, message: '搜索完成！' });
                // 显示搜索结果
                await searchResultView_1.SearchResultView.displaySearchResults(searchQuery, searchResults, workspaceName);
            }
            catch (error) {
                console.error('[CodeChunker] 搜索失败:', error);
                vscode.window.showErrorMessage(`搜索失败: ${error instanceof Error ? error.message : String(error)}`);
            }
        });
    }
    /**
     * 显示配置界面
     */
    async showConfiguration() {
        return await commonViews_1.CommonViews.showConfiguration();
    }
    /**
     * 删除云端Collection
     */
    async deleteCloudCollection() {
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder) {
            vscode.window.showErrorMessage('请先打开一个工作区');
            return;
        }
        // 获取配置
        const config = vscode.workspace.getConfiguration('codeChunker');
        const userId = config.get('userId');
        const deviceId = config.get('deviceId');
        const token = config.get('token');
        // 检查必要的配置
        if (!userId || !deviceId || !token) {
            vscode.window.showErrorMessage('缺少必要的配置信息（用户ID、设备ID或Token），请先配置');
            return;
        }
        const workspacePath = workspaceFolder.uri.fsPath;
        const workspaceName = path.basename(workspacePath);
        // 确认删除
        const confirmation = await vscode.window.showWarningMessage(`确定要删除工作区 "${workspaceName}" 在云端的向量数据吗？\n\n此操作不可撤销！`, { modal: true }, '确定删除', '取消');
        if (confirmation !== '确定删除') {
            return;
        }
        await vscode.window.withProgress({
            location: vscode.ProgressLocation.Notification,
            title: '删除云端Collection...',
            cancellable: false
        }, async (progress) => {
            try {
                progress.report({ increment: 0, message: '连接向量数据库...' });
                // 获取chunker实例
                const chunkerInstance = codeChunker.getChunkerInstance(userId, deviceId, workspacePath, token);
                if (!chunkerInstance.vectorManager) {
                    throw new Error('VectorManager未初始化');
                }
                await chunkerInstance.vectorManager.initialize();
                if (!chunkerInstance.vectorManager.vectorDB || !chunkerInstance.vectorManager.vectorDB.implementation) {
                    throw new Error('向量数据库连接失败');
                }
                progress.report({ increment: 30, message: '生成Collection名称...' });
                // 生成collection名称
                const crypto = __webpack_require__(8);
                const hasher = crypto.createHash('sha256');
                hasher.update(`${userId}_${deviceId}_${workspacePath}`);
                const collectionName = hasher.digest('hex');
                const databaseName = 'vectorservice-test';
                progress.report({ increment: 50, message: '删除Collection...' });
                // 删除collection
                const result = await chunkerInstance.vectorManager.vectorDB.implementation.dropCollection(databaseName, collectionName);
                progress.report({ increment: 90, message: '验证删除结果...' });
                // 验证删除是否成功
                try {
                    const collections = await chunkerInstance.vectorManager.vectorDB.implementation.listCollections(databaseName);
                    const collectionExists = collections && collections.collections &&
                        collections.collections.some((col) => col.collectionName === collectionName);
                    if (collectionExists) {
                        throw new Error('Collection删除失败，仍然存在于数据库中');
                    }
                }
                catch (listError) {
                    console.warn('无法验证删除结果:', listError);
                }
                progress.report({ increment: 100, message: '删除完成！' });
                vscode.window.showInformationMessage(`工作区 "${workspaceName}" 的云端向量数据已成功删除！\n\n` +
                    `Collection: ${collectionName.substring(0, 16)}...`);
            }
            catch (error) {
                console.error('[CodeChunker] 删除Collection失败:', error);
                vscode.window.showErrorMessage(`删除Collection失败: ${error instanceof Error ? error.message : String(error)}`);
            }
        });
    }
}
exports.SearchService = SearchService;


/***/ }),
/* 241 */
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchResultView = void 0;
const vscode = __importStar(__webpack_require__(2));
const fs = __importStar(__webpack_require__(5));
const path = __importStar(__webpack_require__(4));
class SearchResultView {
    /**
     * 显示搜索结果
     */
    static async displaySearchResults(query, results, workspaceName) {
        const outputChannel = vscode.window.createOutputChannel(`代码搜索结果 - ${workspaceName}`);
        try {
            outputChannel.clear();
            outputChannel.appendLine(`📊 智能代码搜索结果`);
            outputChannel.appendLine(`🔍 搜索关键词: "${query}"`);
            outputChannel.appendLine(`📁 工作区: ${workspaceName}`);
            outputChannel.appendLine(`📈 找到结果: ${results.length} 个相关代码片段`);
            outputChannel.appendLine(`⏰ 搜索时间: ${new Date().toLocaleString()}`);
            outputChannel.appendLine(`${'='.repeat(80)}\n`);
            // 按得分排序结果
            results.sort((a, b) => (b.score || 0) - (a.score || 0));
            // 显示每个搜索结果
            results.forEach((result, index) => {
                const score = result.score ? (result.score * 100).toFixed(1) : 'N/A';
                const fileName = result.fileName || result.filePath || 'unknown';
                const filePath = result.filePath || '';
                outputChannel.appendLine(`📄 结果 ${index + 1}: ${fileName}`);
                outputChannel.appendLine(`   📍 路径: ${filePath}`);
                outputChannel.appendLine(`   🎯 相似度: ${score}%`);
                if (result.content) {
                    // 限制内容显示长度
                    const maxLength = 200;
                    let content = result.content.trim();
                    if (content.length > maxLength) {
                        content = content.substring(0, maxLength) + '...';
                    }
                    // 高亮显示查询关键词
                    const highlightedContent = this.highlightQuery(content, query);
                    outputChannel.appendLine(`   📝 内容预览:`);
                    outputChannel.appendLine(`      ${highlightedContent.replace(/\n/g, '\n      ')}`);
                }
                outputChannel.appendLine('');
            });
            outputChannel.appendLine(`${'='.repeat(80)}`);
            outputChannel.appendLine(`💡 提示: 双击结果列表中的文件可以直接打开`);
            // 显示输出面板
            outputChannel.show(true);
            // 提供交互式选择
            await this.showSearchResultPicker(results, workspaceName);
        }
        catch (error) {
            console.error('[SearchResultView] 显示搜索结果失败:', error);
            vscode.window.showErrorMessage(`显示搜索结果失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
    /**
     * 高亮显示查询关键词
     */
    static highlightQuery(content, query) {
        if (!query || !content)
            return content;
        try {
            // 简单的关键词高亮 (用 >> << 包围)
            const regex = new RegExp(`(${query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
            return content.replace(regex, '>>$1<<');
        }
        catch (error) {
            return content;
        }
    }
    /**
     * 显示搜索结果选择器
     */
    static async showSearchResultPicker(results, workspaceName) {
        if (!results || results.length === 0) {
            return;
        }
        const quickPickItems = results.map((result, index) => {
            const score = result.score ? (result.score * 100).toFixed(1) : 'N/A';
            const fileName = result.fileName || result.filePath || 'unknown';
            const filePath = result.filePath || '';
            return {
                label: `$(file-code) ${fileName}`,
                description: `相似度: ${score}%`,
                detail: filePath,
                result: result,
                index: index
            };
        });
        const selected = await vscode.window.showQuickPick(quickPickItems, {
            placeHolder: `选择要打开的文件 (共找到 ${results.length} 个结果)`,
            matchOnDescription: true,
            matchOnDetail: true
        });
        if (selected) {
            await this.openSearchResultFile(selected.result);
        }
    }
    /**
     * 打开搜索结果文件
     */
    static async openSearchResultFile(result) {
        try {
            if (!result || !result.filePath) {
                vscode.window.showErrorMessage('无效的文件路径');
                return;
            }
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (!workspaceFolder) {
                vscode.window.showErrorMessage('请先打开一个工作区');
                return;
            }
            // 构建完整文件路径
            const fullPath = path.isAbsolute(result.filePath)
                ? result.filePath
                : path.join(workspaceFolder.uri.fsPath, result.filePath);
            // 检查文件是否存在
            if (!fs.existsSync(fullPath)) {
                vscode.window.showErrorMessage(`文件不存在: ${result.filePath}`);
                return;
            }
            // 打开文件
            const document = await vscode.workspace.openTextDocument(fullPath);
            const editor = await vscode.window.showTextDocument(document);
            // 如果有行号信息，跳转到指定位置
            if (result.startLine && result.startLine > 0) {
                const startLine = Math.max(0, result.startLine - 1); // VS Code 行号从0开始
                const endLine = result.endLine ? Math.max(startLine, result.endLine - 1) : startLine;
                const range = new vscode.Range(startLine, 0, endLine, 0);
                editor.selection = new vscode.Selection(range.start, range.end);
                editor.revealRange(range, vscode.TextEditorRevealType.InCenter);
            }
            vscode.window.showInformationMessage(`已打开文件: ${result.fileName || result.filePath}`);
        }
        catch (error) {
            console.error('[SearchResultView] 打开文件失败:', error);
            vscode.window.showErrorMessage(`打开文件失败: ${error instanceof Error ? error.message : String(error)}`);
        }
    }
}
exports.SearchResultView = SearchResultView;


/***/ })
/******/ 	]);
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;

/**
 * VS Code 扩展 - 智能代码分块工具
 *
 * 命令使用示例:
 * 1. 手动搜索: vscode.commands.executeCommand('test-electron-treesitter.searchCode')
 * 2. 程序化搜索: vscode.commands.executeCommand('test-electron-treesitter.searchCode', 'function')
 * 3. 其他命令:
 *    - 'test-electron-treesitter.chunkCode' - 开始代码分块
 *    - 'test-electron-treesitter.checkProgress' - 查看分块进度
 *    - 'test-electron-treesitter.configure' - 配置代码分块器
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.activate = activate;
exports.deactivate = deactivate;
const chunkingCommands_1 = __webpack_require__(1);
const searchCommands_1 = __webpack_require__(239);
function activate(context) {
    console.log('[CodeChunker] 扩展已激活');
    // 清除代理环境变量避免连接问题
    clearProxyEnvironment();
    // 注册所有命令
    (0, chunkingCommands_1.registerChunkingCommands)(context);
    (0, searchCommands_1.registerSearchCommands)(context);
    console.log('[CodeChunker] 所有命令已注册');
}
/**
 * 清除代理环境变量
 */
function clearProxyEnvironment() {
    const proxyVars = ['HTTP_PROXY', 'HTTPS_PROXY', 'http_proxy', 'https_proxy', 'ALL_PROXY', 'all_proxy'];
    proxyVars.forEach(varName => {
        if (process.env[varName]) {
            console.log(`[CodeChunker] 清除代理变量: ${varName}=${process.env[varName]}`);
            delete process.env[varName];
        }
    });
    process.env.NO_PROXY = '*';
    process.env.no_proxy = '*';
    console.log('[CodeChunker] 代理环境变量已清除，避免网络连接问题');
}
function deactivate() {
    console.log('[CodeChunker] 扩展已停用');
}

})();

module.exports = __webpack_exports__;
/******/ })()
;
//# sourceMappingURL=extension.js.map